type,content
Title,Standalone applications
Title,"There are several ways of mounting a Nest application. You can create a web app, a microservice or just a bare Nest standalone application (without any network listeners). The Nest standalone application is a wrapper around the Nest IoC container, which holds all instantiated classes. We can obtain a reference to any existing instance from within any imported module directly using the standalone application object. Thus, you can take advantage of the Nest framework anywhere, including, for example, scripted CRON jobs. You can even build a CLI on top of it."
Title,Getting started
Title,"To create a Nest standalone application, use the following construction:"
Title,typescript
Title,@@filename()
Title,async function bootstrap() {
Title,const app = await NestFactory.createApplicationContext(AppModule);
Title,// your application logic here ...
Title,}
Title,bootstrap();
Title,Retrieving providers from static modules
Title,The standalone application object allows you to obtain a reference to any instance registered within the Nest application. Let's imagine that we have a TasksService provider in the TasksModule module that was imported by our AppModule module. This class provides a set of methods that we want to call from within a CRON job.
Title,typescript
Title,@@filename()
Title,const tasksService = app.get(TasksService);
Title,"To access the TasksService instance we use the get() method. The get() method acts like a query that searches for an instance in each registered module. You can pass any provider's token to it. Alternatively, for strict context checking, pass an options object with the strict: true property. With this option in effect, you have to navigate through specific modules to obtain a particular instance from the selected context."
Title,typescript
Title,@@filename()
Title,"const tasksService = app.select(TasksModule).get(TasksService, { strict: true });"
Title,Following is a summary of the methods available for retrieving instance references from the standalone application object.
Title,
Title,
Title,
Title,get()
Title,
Title,
Title,"Retrieves an instance of a controller or provider (including guards, filters, and so on) available in the application context."
Title,
Title,
Title,
Title,
Title,select()
Title,
Title,
Title,Navigates through the module's graph to pull out a specific instance of the selected module (used together with strict mode as described above).
Title,
Title,
Title,
Title,
Title,"info Hint In non-strict mode, the root module is selected by default. To select any other module, you need to navigate the modules graph manually, step by step."
Title,
Title,"Keep in mind that a standalone application does not have any network listeners, so any Nest features related to HTTP (e.g., middleware, interceptors, pipes, guards, etc.) are not available in this context."
Title,"For example, even if you register a global interceptor in your application and then retrieve a controller's instance using the app.get() method, the interceptor will not be executed."
Title,Retrieving providers from dynamic modules
Title,"When dealing with dynamic modules, we should supply the same object that represents the registered dynamic module in the application to app.select. For example:"
Title,```typescript
Title,@@filename()
Title,export const dynamicConfigModule = ConfigModule.register({ folder: './config' });
Title,@Module({
Title,"imports: [dynamicConfigModule],"
Title,})
Title,export class AppModule {}
Title,```
Title,Then you can select that module later on:
Title,typescript
Title,@@filename()
Title,"const configService = app.select(dynamicConfigModule).get(ConfigService, { strict: true });"
Title,Terminating phase
Title,"If you want the Node application to close after the script finishes (e.g., for a script running CRON jobs), you must call the app.close() method in the end of your bootstrap function like this:"
Title,typescript
Title,@@filename()
Title,async function bootstrap() {
Title,const app = await NestFactory.createApplicationContext(AppModule);
Title,// application logic...
Title,await app.close();
Title,}
Title,bootstrap();
Title,"And as mentioned in the Lifecycle events chapter, that will trigger lifecycle hooks."
Title,Example
Title,A working example is available here.
Title,
Title,Libraries
Title,"Many applications need to solve the same general problems, or re-use a modular component in several different contexts. Nest has a few ways of addressing this, but each works at a different level to solve the problem in a way that helps meet different architectural and organizational objectives."
Title,"Nest modules are useful for providing an execution context that enables sharing components within a single application. Modules can also be packaged with npm to create a reusable library that can be installed in different projects. This can be an effective way to distribute configurable, re-usable libraries that can be used by different, loosely connected or unaffiliated organizations (e.g., by distributing/installing 3rd party libraries)."
Title,"For sharing code within closely organized groups (e.g., within company/project boundaries), it can be useful to have a more lightweight approach to sharing components. Monorepos have arisen as a construct to enable that, and within a monorepo, a library provides a way to share code in an easy, lightweight fashion. In a Nest monorepo, using libraries enables easy assembly of applications that share components. In fact, this encourages decomposition of monolithic applications and development processes to focus on building and composing modular components."
Title,Nest libraries
Title,A Nest library is a Nest project that differs from an application in that it cannot run on its own. A library must be imported into a containing application in order for its code to execute. The built-in support for libraries described in this section is only available for monorepos (standard mode projects can achieve similar functionality using npm packages).
Title,"For example, an organization may develop an AuthModule that manages authentication by implementing company policies that govern all internal applications. Rather than build that module separately for each application, or physically packaging the code with npm and requiring each project to install it, a monorepo can define this module as a library. When organized this way, all consumers of the library module can see an up-to-date version of the AuthModule as it is committed. This can have significant benefits for coordinating component development and assembly, and simplifying end-to-end testing."
Title,Creating libraries
Title,"Any functionality that is suitable for re-use is a candidate for being managed as a library. Deciding what should be a library, and what should be part of an application, is an architectural design decision. Creating libraries involves more than simply copying code from an existing application to a new library. When packaged as a library, the library code must be decoupled from the application. This may require more time up front and force some design decisions that you may not face with more tightly coupled code. But this additional effort can pay off when the library can be used to enable more rapid application assembly across multiple applications."
Title,"To get started with creating a library, run the following command:"
Title,bash
Title,$ nest g library my-library
Title,"When you run the command, the library schematic prompts you for a prefix (AKA alias) for the library:"
Title,bash
Title,What prefix would you like to use for the library (default: @app)?
Title,This creates a new project in your workspace called my-library.
Title,"A library-type project, like an application-type project, is generated into a named folder using a schematic. Libraries are managed under the libs folder of the monorepo root. Nest creates the libs folder the first time a library is created."
Title,The files generated for a library are slightly different from those generated for an application. Here is the contents of the libs folder after executing the command above:
Title,
Title,libs
Title,
Title,my-library
Title,
Title,src
Title,
Title,index.ts
Title,my-library.module.ts
Title,my-library.service.ts
Title,
Title,tsconfig.lib.json
Title,
Title,
Title,
Title,"The nest-cli.json file will have a new entry for the library under the ""projects"" key:"
Title,javascript
Title,...
Title,{
Title,"""my-library"": {"
Title,"""type"": ""library"","
Title,"""root"": ""libs/my-library"","
Title,"""entryFile"": ""index"","
Title,"""sourceRoot"": ""libs/my-library/src"","
Title,"""compilerOptions"": {"
Title,"""tsConfigPath"": ""libs/my-library/tsconfig.lib.json"""
Title,}
Title,}
Title,...
Title,There are two differences in nest-cli.json metadata between libraries and applications:
Title,
Title,"the ""type"" property is set to ""library"" instead of ""application"""
Title,"the ""entryFile"" property is set to ""index"" instead of ""main"""
Title,
Title,"These differences key the build process to handle libraries appropriately. For example, a library exports its functions through the index.js file."
Title,"As with application-type projects, libraries each have their own tsconfig.lib.json file that extends the root (monorepo-wide) tsconfig.json file. You can modify this file, if necessary, to provide library-specific compiler options."
Title,You can build the library with the CLI command:
Title,bash
Title,$ nest build my-library
Title,Using libraries
Title,"With the automatically generated configuration files in place, using libraries is straightforward. How would we import MyLibraryService from the my-library library into the my-project application?"
Title,"First, note that using library modules is the same as using any other Nest module. What the monorepo does is manage paths in a way that importing libraries and generating builds is now transparent. To use MyLibraryService, we need to import its declaring module. We can modify my-project/src/app.module.ts as follows to import MyLibraryModule."
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { AppController } from './app.controller';
Title,import { AppService } from './app.service';
Title,import { MyLibraryModule } from '@app/my-library';
Title,@Module({
Title,"imports: [MyLibraryModule],"
Title,"controllers: [AppController],"
Title,"providers: [AppService],"
Title,})
Title,export class AppModule {}
Title,```
Title,"Notice above that we've used a path alias of @app in the ES module import line, which was the prefix we supplied with the nest g library command above. Under the covers, Nest handles this through tsconfig path mapping. When adding a library, Nest updates the global (monorepo) tsconfig.json file's ""paths"" key like this:"
Title,javascript
Title,"""paths"": {"
Title,"""@app/my-library"": ["
Title,"""libs/my-library/src"""
Title,"],"
Title,"""@app/my-library/*"": ["
Title,"""libs/my-library/src/*"""
Title,]
Title,}
Title,"So, in a nutshell, the combination of the monorepo and library features has made it easy and intuitive to include library modules into applications."
Title,"This same mechanism enables building and deploying applications that compose libraries. Once you've imported the MyLibraryModule, running nest build handles all the module resolution automatically and bundles the app along with any library dependencies, for deployment. The default compiler for a monorepo is webpack, so the resulting distribution file is a single file that bundles all of the transpiled JavaScript files into a single file. You can also switch to tsc as described here."
Title,
Title,Overview
Title,"The Nest CLI is a command-line interface tool that helps you to initialize, develop, and maintain your Nest applications. It assists in multiple ways, including scaffolding the project, serving it in development mode, and building and bundling the application for production distribution. It embodies best-practice architectural patterns to encourage well-structured apps."
Title,Installation
Title,"Note: In this guide we describe using npm to install packages, including the Nest CLI. Other package managers may be used at your discretion. With npm, you have several options available for managing how your OS command line resolves the location of the nest CLI binary file. Here, we describe installing the nest binary globally using the -g option. This provides a measure of convenience, and is the approach we assume throughout the documentation. Note that installing any npm package globally leaves the responsibility of ensuring they're running the correct version up to the user. It also means that if you have different projects, each will run the same version of the CLI. A reasonable alternative is to use the npx program, built into the npm cli (or similar features with other package managers) to ensure that you run a managed version of the Nest CLI. We recommend you consult the npx documentation and/or your DevOps support staff for more information."
Title,Install the CLI globally using the npm install -g command (see the Note above for details about global installs).
Title,bash
Title,$ npm install -g @nestjs/cli
Title,
Title,"info Hint Alternatively, you can use this command npx @nestjs/cli@latest without installing the cli globally."
Title,
Title,Basic workflow
Title,"Once installed, you can invoke CLI commands directly from your OS command line through the nest executable. See the available nest commands by entering the following:"
Title,bash
Title,$ nest --help
Title,"Get help on an individual command using the following construct. Substitute any command, like new, add, etc., where you see generate in the example below to get detailed help on that command:"
Title,bash
Title,$ nest generate --help
Title,"To create, build and run a new basic Nest project in development mode, go to the folder that should be the parent of your new project, and run the following commands:"
Title,bash
Title,$ nest new my-nest-project
Title,$ cd my-nest-project
Title,$ npm run start:dev
Title,"In your browser, open http://localhost:3000 to see the new application running. The app will automatically recompile and reload when you change any of the source files."
Title,
Title,info Hint We recommend using the SWC builder for faster builds (10x more performant than the default TypeScript compiler).
Title,
Title,Project structure
Title,"When you run nest new, Nest generates a boilerplate application structure by creating a new folder and populating an initial set of files. You can continue working in this default structure, adding new components, as described throughout this documentation. We refer to the project structure generated by nest new as standard mode. Nest also supports an alternate structure for managing multiple projects and libraries called monorepo mode."
Title,"Aside from a few specific considerations around how the build process works (essentially, monorepo mode simplifies build complexities that can sometimes arise from monorepo-style project structures), and built-in library support, the rest of the Nest features, and this documentation, apply equally to both standard and monorepo mode project structures. In fact, you can easily switch from standard mode to monorepo mode at any time in the future, so you can safely defer this decision while you're still learning about Nest."
Title,You can use either mode to manage multiple projects. Here's a quick summary of the differences:
Title,| Feature                                               | Standard Mode                                                      | Monorepo Mode                                              |
Title,| ----------------------------------------------------- | ------------------------------------------------------------------ | ---------------------------------------------------------- |
Title,| Multiple projects                                     | Separate file system structure                                     | Single file system structure                               |
Title,| node_modules & package.json                       | Separate instances                                                 | Shared across monorepo                                     |
Title,| Default compiler                                      | tsc                                                              | webpack                                                    |
Title,| Compiler settings                                     | Specified separately                                               | Monorepo defaults that can be overridden per project       |
Title,"| Config files like .eslintrc.js, .prettierrc, etc. | Specified separately                                               | Shared across monorepo                                     |"
Title,| nest build and nest start commands                | Target defaults automatically to the (only) project in the context | Target defaults to the default project in the monorepo |
Title,"| Libraries                                             | Managed manually, usually via npm packaging                        | Built-in support, including path management and bundling   |"
Title,Read the sections on Workspaces and Libraries for more detailed information to help you decide which mode is most suitable for you.
Title,
Title,CLI command syntax
Title,All nest commands follow the same format:
Title,bash
Title,nest commandOrAlias requiredArg [optionalArg] [options]
Title,For example:
Title,bash
Title,$ nest new my-nest-project --dry-run
Title,"Here, new is the commandOrAlias. The new command has an alias of n. my-nest-project is the requiredArg. If a requiredArg is not supplied on the command line, nest will prompt for it. Also, --dry-run has an equivalent short-hand form -d. With this in mind, the following command is the equivalent of the above:"
Title,bash
Title,$ nest n my-nest-project -d
Title,"Most commands, and some options, have aliases. Try running nest new --help to see these options and aliases, and to confirm your understanding of the above constructs."
Title,Command overview
Title,Run nest <command> --help for any of the following commands to see command-specific options.
Title,See usage for detailed descriptions for each command.
Title,| Command    | Alias | Description                                                                                    |
Title,| ---------- | ----- | ---------------------------------------------------------------------------------------------- |
Title,| new      | n   | Scaffolds a new standard mode application with all boilerplate files needed to run.          |
Title,| generate | g   | Generates and/or modifies files based on a schematic.                                          |
Title,| build    |       | Compiles an application or workspace into an output folder.                                    |
Title,| start    |       | Compiles and runs an application (or default project in a workspace).                          |
Title,"| add      |       | Imports a library that has been packaged as a nest library, running its install schematic. |"
Title,| info     | i   | Displays information about installed nest packages and other helpful system info.              |
Title,Requirements
Title,"Nest CLI requires a Node.js binary built with internationalization support (ICU), such as the official binaries from the Node.js project page. If you encounter errors related to ICU, check that your binary meets this requirement."
Title,bash
Title,node -p process.versions.icu
Title,"If the command prints undefined, your Node.js binary has no internationalization support."
Title,
Title,Nest CLI and scripts
Title,This section provides additional background on how the nest command interacts with compilers and scripts to help DevOps personnel manage the development environment.
Title,"A Nest application is a standard TypeScript application that needs to be compiled to JavaScript before it can be executed. There are various ways to accomplish the compilation step, and developers/teams are free to choose a way that works best for them. With that in mind, Nest provides a set of tools out-of-the-box that seek to do the following:"
Title,
Title,"Provide a standard build/execute process, available at the command line, that ""just works"" with reasonable defaults."
Title,"Ensure that the build/execute process is open, so developers can directly access the underlying tools to customize them using native features and options."
Title,"Remain a completely standard TypeScript/Node.js framework, so that the entire compile/deploy/execute pipeline can be managed by any external tools that the development team chooses to use."
Title,
Title,"This goal is accomplished through a combination of the nest command, a locally installed TypeScript compiler, and package.json scripts. We describe how these technologies work together below. This should help you understand what's happening at each step of the build/execute process, and how to customize that behavior if necessary."
Title,The nest binary
Title,"The nest command is an OS level binary (i.e., runs from the OS command line). This command actually encompasses 3 distinct areas, described below. We recommend that you run the build (nest build) and execution (nest start) sub-commands via the package.json scripts provided automatically when a project is scaffolded (see typescript starter if you wish to start by cloning a repo, instead of running nest new)."
Title,Build
Title,"nest build is a wrapper on top of the standard tsc compiler or swc compiler (for standard projects) or the webpack bundler using the ts-loader (for monorepos). It does not add any other compilation features or steps except for handling tsconfig-paths out of the box. The reason it exists is that most developers, especially when starting out with Nest, do not need to adjust compiler options (e.g., tsconfig.json file) which can sometimes be tricky."
Title,See the nest build documentation for more details.
Title,Execution
Title,"nest start simply ensures the project has been built (same as nest build), then invokes the node command in a portable, easy way to execute the compiled application. As with builds, you are free to customize this process as needed, either using the nest start command and its options, or completely replacing it. The entire process is a standard TypeScript application build and execute pipeline, and you are free to manage the process as such."
Title,See the nest start documentation for more details.
Title,Generation
Title,"The nest generate commands, as the name implies, generate new Nest projects, or components within them."
Title,Package scripts
Title,"Running the nest commands at the OS command level requires that the nest binary be installed globally. This is a standard feature of npm, and outside of Nest's direct control. One consequence of this is that the globally installed nest binary is not managed as a project dependency in package.json. For example, two different developers can be running two different versions of the nest binary. The standard solution for this is to use package scripts so that you can treat the tools used in the build and execute steps as development dependencies."
Title,"When you run nest new, or clone the typescript starter, Nest populates the new project's package.json scripts with commands like build and start. It also installs the underlying compiler tools (such as typescript) as dev dependencies."
Title,You run the build and execute scripts with commands like:
Title,bash
Title,$ npm run build
Title,and
Title,bash
Title,$ npm run start
Title,"These commands use npm's script running capabilities to execute nest build or nest start using the locally installed nest binary. By using these built-in package scripts, you have full dependency management over the Nest CLI commands*. This means that, by following this recommended usage, all members of your organization can be assured of running the same version of the commands."
Title,"*This applies to the build and start commands. The nest new and nest generate commands aren't part of the build/execute pipeline, so they operate in a different context, and do not come with built-in package.json scripts."
Title,"For most developers/teams, it is recommended to utilize the package scripts for building and executing their Nest projects. You can fully customize the behavior of these scripts via their options (--path, --webpack, --webpackPath) and/or customize the tsc or webpack compiler options files (e.g., tsconfig.json) as needed. You are also free to run a completely custom build process to compile the TypeScript (or even to execute TypeScript directly with ts-node)."
Title,Backward compatibility
Title,"Because Nest applications are pure TypeScript applications, previous versions of the Nest build/execute scripts will continue to operate. You are not required to upgrade them. You can choose to take advantage of the new nest build and nest start commands when you are ready, or continue running previous or customized scripts."
Title,Migration
Title,"While you are not required to make any changes, you may want to migrate to using the new CLI commands instead of using tools such as tsc-watch or ts-node. In this case, simply install the latest version of the @nestjs/cli, both globally and locally:"
Title,bash
Title,$ npm install -g @nestjs/cli
Title,$ cd  /some/project/root/folder
Title,$ npm install -D @nestjs/cli
Title,You can then replace the scripts defined in package.json with the following ones:
Title,typescript
Title,"""build"": ""nest build"","
Title,"""start"": ""nest start"","
Title,"""start:dev"": ""nest start --watch"","
Title,"""start:debug"": ""nest start --debug --watch"","
Title,
Title,CLI command reference
Title,nest new
Title,Creates a new (standard mode) Nest project.
Title,bash
Title,$ nest new <name> [options]
Title,$ nest n <name> [options]
Title,Description
Title,Creates and initializes a new Nest project. Prompts for package manager.
Title,
Title,Creates a folder with the given <name>
Title,Populates the folder with configuration files
Title,Creates sub-folders for source code (/src) and end-to-end tests (/test)
Title,Populates the sub-folders with default files for app components and tests
Title,
Title,Arguments
Title,| Argument | Description                 |
Title,| -------- | --------------------------- |
Title,| <name> | The name of the new project |
Title,Options
Title,| Option                                | Description                                                                                                                                                                                          |
Title,| ------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
Title,"| --dry-run                           | Reports changes that would be made, but does not change the filesystem. Alias: -d                                                                                                             |"
Title,| --skip-git                          | Skip git repository initialization. Alias: -g                                                                                                                                                 |
Title,| --skip-install                      | Skip package installation. Alias: -s                                                                                                                                                          |
Title,"| --package-manager [package-manager] | Specify package manager. Use npm, yarn, or pnpm. Package manager must be installed globally. Alias: -p                                                                                  |"
Title,| --language [language]               | Specify programming language (TS or JS). Alias: -l                                                                                                                                        |
Title,| --collection [collectionName]       | Specify schematics collection. Use package name of installed npm package containing schematic. Alias: -c                                                                                      |
Title,"| --strict                            | Start the project with the following TypeScript compiler flags enabled: strictNullChecks, noImplicitAny, strictBindCallApply, forceConsistentCasingInFileNames, noFallthroughCasesInSwitch |"
Title,nest generate
Title,Generates and/or modifies files based on a schematic
Title,bash
Title,$ nest generate <schematic> <name> [options]
Title,$ nest g <schematic> <name> [options]
Title,Arguments
Title,| Argument      | Description                                                                                              |
Title,| ------------- | -------------------------------------------------------------------------------------------------------- |
Title,| <schematic> | The schematic or collection:schematic to generate. See the table below for the available schematics. |
Title,| <name>      | The name of the generated component.                                                                     |
Title,Schematics
Title,| Name          | Alias | Description                                                                                                           |
Title,| ------------- | ----- | ----------------------------------------------------------------------------------------------------------------------|
Title,| app         |       | Generate a new application within a monorepo (converting to monorepo if it's a standard structure).                   |
Title,| library     | lib | Generate a new library within a monorepo (converting to monorepo if it's a standard structure).                       |
Title,| class       | cl  | Generate a new class.                                                                                                 |
Title,| controller  | co  | Generate a controller declaration.                                                                                    |
Title,| decorator   | d   | Generate a custom decorator.                                                                                          |
Title,| filter      | f   | Generate a filter declaration.                                                                                        |
Title,| gateway     | ga  | Generate a gateway declaration.                                                                                       |
Title,| guard       | gu  | Generate a guard declaration.                                                                                         |
Title,| interface   | itf | Generate an interface.                                                                                                |
Title,| interceptor | itc | Generate an interceptor declaration.                                                                                  |
Title,| middleware  | mi  | Generate a middleware declaration.                                                                                    |
Title,| module      | mo  | Generate a module declaration.                                                                                        |
Title,| pipe        | pi  | Generate a pipe declaration.                                                                                          |
Title,| provider    | pr  | Generate a provider declaration.                                                                                      |
Title,| resolver    | r   | Generate a resolver declaration.                                                                                      |
Title,| resource    | res | Generate a new CRUD resource. See the CRUD (resource) generator for more details. (TS only)|
Title,| service     | s   | Generate a service declaration.                                                                                       |
Title,Options
Title,| Option                          | Description                                                                                                     |
Title,| ------------------------------- | --------------------------------------------------------------------------------------------------------------- |
Title,"| --dry-run                     | Reports changes that would be made, but does not change the filesystem. Alias: -d                        |"
Title,| --project [project]           | Project that element should be added to. Alias: -p                                                       |
Title,| --flat                        | Do not generate a folder for the element.                                                                       |
Title,| --collection [collectionName] | Specify schematics collection. Use package name of installed npm package containing schematic. Alias: -c |
Title,| --spec                        | Enforce spec files generation (default)                                                                         |
Title,| --no-spec                     | Disable spec files generation                                                                                   |
Title,nest build
Title,Compiles an application or workspace into an output folder.
Title,"Also, the build command is responsible for:"
Title,
Title,mapping paths (if using path aliases) via tsconfig-paths
Title,annotating DTOs with OpenAPI decorators (if @nestjs/swagger CLI plugin is enabled)
Title,annotating DTOs with GraphQL decorators (if @nestjs/graphql CLI plugin is enabled)
Title,
Title,bash
Title,$ nest build <name> [options]
Title,Arguments
Title,| Argument | Description                       |
Title,| -------- | --------------------------------- |
Title,| <name> | The name of the project to build. |
Title,Options
Title,| Option             | Description                                                                                                                                                                                |
Title,| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
Title,| --path [path]    | Path to tsconfig file. Alias -p                                                                                                                                                   |
Title,| --config [path]  | Path to nest-cli configuration file. Alias -c                                                                                                                                     |
Title,"| --watch          | Run in watch mode (live-reload). If you're using tsc for compilation, you can type rs to restart the application (when manualRestart option is set to true). Alias -w |"
Title,"| --builder [name] | Specify the builder to use for compilation (tsc, swc, or webpack). Alias -b                                                                                                   |"
Title,| --webpack        | Use webpack for compilation (deprecated: use --builder webpack instead).                                                                                                                 |
Title,| --webpackPath    | Path to webpack configuration.                                                                                                                                                             |
Title,| --tsc            | Force use tsc for compilation.                                                                                                                                                           |
Title,nest start
Title,Compiles and runs an application (or default project in a workspace).
Title,bash
Title,$ nest start <name> [options]
Title,Arguments
Title,| Argument | Description                     |
Title,| -------- | ------------------------------- |
Title,| <name> | The name of the project to run. |
Title,Options
Title,| Option                  | Description                                                                                                          |
Title,| ----------------------- | -------------------------------------------------------------------------------------------------------------------- |
Title,| --path [path]         | Path to tsconfig file. Alias -p                                                                             |
Title,| --config [path]       | Path to nest-cli configuration file. Alias -c                                                               |
Title,| --watch               | Run in watch mode (live-reload) Alias -w                                                                      |
Title,"| --builder [name]      | Specify the builder to use for compilation (tsc, swc, or webpack). Alias -b                             |"
Title,| --preserveWatchOutput | Keep outdated console output in watch mode instead of clearing the screen. (tsc watch mode only)                   |
Title,"| --watchAssets         | Run in watch mode (live-reload), watching non-TS files (assets). See Assets for more details. |"
Title,| --debug [hostport]    | Run in debug mode (with --inspect flag) Alias -d                                                              |
Title,| --webpack             | Use webpack for compilation. (deprecated: use --builder webpack instead)                                           |
Title,| --webpackPath         | Path to webpack configuration.                                                                                       |
Title,| --tsc                 | Force use tsc for compilation.                                                                                     |
Title,| --exec [binary]       | Binary to run (default: node). Alias -e                                                                     |
Title,| -- [key=value]        | Command-line arguments that can be referenced with process.argv.                                                   |
Title,nest add
Title,"Imports a library that has been packaged as a nest library, running its install schematic."
Title,bash
Title,$ nest add <name> [options]
Title,Arguments
Title,| Argument | Description                        |
Title,| -------- | ---------------------------------- |
Title,| <name> | The name of the library to import. |
Title,nest info
Title,Displays information about installed nest packages and other helpful system info. For example:
Title,bash
Title,$ nest info
Title,``bash
Title,_   _             _      ___  _____  _____  _     _____
Title,| \ | |           | |    |_  |/  ___|/  __ \| |   |_   _|
Title,|  \| |  ___  ___ | |_     | |\--. | /  \/| |     | |
Title,| . | / _ \/ __|| __|    | |--. \| |    | |     | |
Title,| |\  ||  /_ \| | /_/ //_/ /| _/\| |__| |
Title,_| _/ ___||___/ _|_/ _/  _/__/___/
Title,[System Information]
Title,OS Version : macOS High Sierra
Title,NodeJS Version : v16.18.0
Title,[Nest Information]
Title,microservices version : 10.0.0
Title,websockets version : 10.0.0
Title,testing version : 10.0.0
Title,common version : 10.0.0
Title,core version : 10.0.0
Title,```
Title,
Title,Workspaces
Title,Nest has two modes for organizing code:
Title,
Title,"standard mode: useful for building individual project-focused applications that have their own dependencies and settings, and don't need to optimize for sharing modules, or optimizing complex builds. This is the default mode."
Title,"monorepo mode: this mode treats code artifacts as part of a lightweight monorepo, and may be more appropriate for teams of developers and/or multi-project environments. It automates parts of the build process to make it easy to create and compose modular components, promotes code re-use, makes integration testing easier, makes it easy to share project-wide artifacts like eslint rules and other configuration policies, and is easier to use than alternatives like github submodules. Monorepo mode employs the concept of a workspace, represented in the nest-cli.json file, to coordinate the relationship between the components of the monorepo."
Title,
Title,"It's important to note that virtually all of Nest's features are independent of your code organization mode. The only effect of this choice is how your projects are composed and how build artifacts are generated. All other functionality, from the CLI to core modules to add-on modules work the same in either mode."
Title,"Also, you can easily switch from standard mode to monorepo mode at any time, so you can delay this decision until the benefits of one or the other approach become more clear."
Title,Standard mode
Title,"When you run nest new, a new project is created for you using a built-in schematic. Nest does the following:"
Title,
Title,"Create a new folder, corresponding to the name argument you provide to nest new"
Title,Populate that folder with default files corresponding to a minimal base-level Nest application. You can examine these files at the typescript-starter repository.
Title,"Provide additional files such as nest-cli.json, package.json and tsconfig.json that configure and enable various tools for compiling, testing and serving your application."
Title,
Title,"From there, you can modify the starter files, add new components, add dependencies (e.g., npm install), and otherwise develop your application as covered in the rest of this documentation."
Title,Monorepo mode
Title,"To enable monorepo mode, you start with a standard mode structure, and add projects. A project can be a full application (which you add to the workspace with the command nest generate app) or a library (which you add to the workspace with the command nest generate library). We'll discuss the details of these specific types of project components below. The key point to note now is that it is the act of adding a project to an existing standard mode structure that converts it to monorepo mode. Let's look at an example."
Title,If we run:
Title,bash
Title,$ nest new my-project
Title,"We've constructed a standard mode structure, with a folder structure that looks like this:"
Title,
Title,node_modules
Title,src
Title,
Title,app.controller.ts
Title,app.module.ts
Title,app.service.ts
Title,main.ts
Title,
Title,nest-cli.json
Title,package.json
Title,tsconfig.json
Title,.eslintrc.js
Title,
Title,We can convert this to a monorepo mode structure as follows:
Title,bash
Title,$ cd my-project
Title,$ nest generate app my-app
Title,"At this point, nest converts the existing structure to a monorepo mode structure. This results in a few important changes. The folder structure now looks like this:"
Title,
Title,apps
Title,
Title,my-app
Title,
Title,src
Title,
Title,app.controller.ts
Title,app.module.ts
Title,app.service.ts
Title,main.ts
Title,
Title,tsconfig.app.json
Title,
Title,my-project
Title,
Title,src
Title,
Title,app.controller.ts
Title,app.module.ts
Title,app.service.ts
Title,main.ts
Title,
Title,tsconfig.app.json
Title,
Title,
Title,nest-cli.json
Title,package.json
Title,tsconfig.json
Title,.eslintrc.js
Title,
Title,"The generate app schematic has reorganized the code - moving each application project under the apps folder, and adding a project-specific tsconfig.app.json file in each project's root folder. Our original my-project app has become the default project for the monorepo, and is now a peer with the just-added my-app, located under the apps folder. We'll cover default projects below."
Title,
Title,"error Warning The conversion of a standard mode structure to monorepo only works for projects that have followed the canonical Nest project structure. Specifically, during conversion, the schematic attempts to relocate the src and test folders in a project folder beneath the apps folder in the root. If a project does not use this structure, the conversion will fail or produce unreliable results."
Title,
Title,Workspace projects
Title,A monorepo uses the concept of a workspace to manage its member entities. Workspaces are composed of projects. A project may be either:
Title,
Title,"an application: a full Nest application including a main.ts file to bootstrap the application. Aside from compile and build considerations, an application-type project within a workspace is functionally identical to an application within a standard mode structure."
Title,"a library: a library is a way of packaging a general purpose set of features (modules, providers, controllers, etc.) that can be used within other projects. A library cannot run on its own, and has no main.ts file. Read more about libraries here."
Title,
Title,"All workspaces have a default project (which should be an application-type project). This is defined by the top-level ""root"" property in the nest-cli.json file, which points at the root of the default project (see CLI properties below for more details). Usually, this is the standard mode application you started with, and later converted to a monorepo using nest generate app. When you follow these steps, this property is populated automatically."
Title,Default projects are used by nest commands like nest build and nest start when a project name is not supplied.
Title,"For example, in the above monorepo structure, running"
Title,bash
Title,$ nest start
Title,"will start up the my-project app. To start my-app, we'd use:"
Title,bash
Title,$ nest start my-app
Title,Applications
Title,"Application-type projects, or what we might informally refer to as just ""applications"", are complete Nest applications that you can run and deploy. You generate an application-type project with nest generate app."
Title,"This command automatically generates a project skeleton, including the standard src and test folders from the typescript starter. Unlike standard mode, an application project in a monorepo does not have any of the package dependency (package.json) or other project configuration artifacts like .prettierrc and .eslintrc.js. Instead, the monorepo-wide dependencies and config files are used."
Title,"However, the schematic does generate a project-specific tsconfig.app.json file in the root folder of the project. This config file automatically sets appropriate build options, including setting the compilation output folder properly. The file extends the top-level (monorepo) tsconfig.json file, so you can manage global settings monorepo-wide, but override them if needed at the project level."
Title,Libraries
Title,"As mentioned, library-type projects, or simply ""libraries"", are packages of Nest components that need to be composed into applications in order to run. You generate a library-type project with nest generate library. Deciding what belongs in a library is an architectural design decision. We discuss libraries in depth in the libraries chapter."
Title,CLI properties
Title,"Nest keeps the metadata needed to organize, build and deploy both standard and monorepo structured projects in the nest-cli.json file. Nest automatically adds to and updates this file as you add projects, so you usually do not have to think about it or edit its contents. However, there are some settings you may want to change manually, so it's helpful to have an overview understanding of the file."
Title,"After running the steps above to create a monorepo, our nest-cli.json file looks like this:"
Title,javascript
Title,{
Title,"""collection"": ""@nestjs/schematics"","
Title,"""sourceRoot"": ""apps/my-project/src"","
Title,"""monorepo"": true,"
Title,"""root"": ""apps/my-project"","
Title,"""compilerOptions"": {"
Title,"""webpack"": true,"
Title,"""tsConfigPath"": ""apps/my-project/tsconfig.app.json"""
Title,"},"
Title,"""projects"": {"
Title,"""my-project"": {"
Title,"""type"": ""application"","
Title,"""root"": ""apps/my-project"","
Title,"""entryFile"": ""main"","
Title,"""sourceRoot"": ""apps/my-project/src"","
Title,"""compilerOptions"": {"
Title,"""tsConfigPath"": ""apps/my-project/tsconfig.app.json"""
Title,}
Title,"},"
Title,"""my-app"": {"
Title,"""type"": ""application"","
Title,"""root"": ""apps/my-app"","
Title,"""entryFile"": ""main"","
Title,"""sourceRoot"": ""apps/my-app/src"","
Title,"""compilerOptions"": {"
Title,"""tsConfigPath"": ""apps/my-app/tsconfig.app.json"""
Title,}
Title,}
Title,}
Title,}
Title,The file is divided into sections:
Title,
Title,a global section with top-level properties controlling standard and monorepo-wide settings
Title,"a top level property (""projects"") with metadata about each project. This section is present only for monorepo-mode structures."
Title,
Title,The top-level properties are as follows:
Title,
Title,"""collection"": points at the collection of schematics used to generate components; you generally should not change this value"
Title,"""sourceRoot"": points at the root of the source code for the single project in standard mode structures, or the default project in monorepo mode structures"
Title,"""compilerOptions"": a map with keys specifying compiler options and values specifying the option setting; see details below"
Title,"""generateOptions"": a map with keys specifying global generate options and values specifying the option setting; see details below"
Title,"""monorepo"": (monorepo only) for a monorepo mode structure, this value is always true"
Title,"""root"": (monorepo only) points at the project root of the default project"
Title,
Title,Global compiler options
Title,"These properties specify the compiler to use as well as various options that affect any compilation step, whether as part of nest build or nest start, and regardless of the compiler, whether tsc or webpack."
Title,| Property Name       | Property Value Type | Description                                                                                                                                                                                                                                                               |
Title,| ------------------- | ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
Title,"| webpack           | boolean             | If true, use webpack compiler. If false or not present, use tsc. In monorepo mode, the default is true (use webpack), in standard mode, the default is false (use tsc). See below for details. (deprecated: use builder instead) |"
Title,"| tsConfigPath      | string              | (monorepo only) Points at the file containing the tsconfig.json settings that will be used when nest build or nest start is called without a project option (e.g., when the default project is built or started).                                             |"
Title,"| webpackConfigPath | string              | Points at a webpack options file. If not specified, Nest looks for the file webpack.config.js. See below for more details.                                                                                                                                              |"
Title,"| deleteOutDir      | boolean             | If true, whenever the compiler is invoked, it will first remove the compilation output directory (as configured in tsconfig.json, where the default is ./dist).                                                                                                     |"
Title,| assets            | array               | Enables automatically distributing non-TypeScript assets whenever a compilation step begins (asset distribution does not happen on incremental compiles in --watch mode). See below for details.                                                                    |
Title,"| watchAssets       | boolean             | If true, run in watch-mode, watching all non-TypeScript assets. (For more fine-grained control of the assets to watch, see Assets section below).                                                                                            |"
Title,"| manualRestart     | boolean             | If true, enables the shortcut rs to manually restart the server. Default value is false.                                                                                                                                                                            |"
Title,"| builder           | string/object       | Instructs CLI on what builder to use to compile the project (tsc, swc, or webpack). To customize builder's behavior, you can pass an object containing two attributes: type (tsc, swc, or webpack) and options.                                         |"
Title,"| typeCheck         | boolean             | If true, enables type checking for SWC-driven projects (when builder is swc). Default value is false.                                                                                                                                                             |"
Title,Global generate options
Title,These properties specify the default generate options to be used by the nest generate command.
Title,| Property Name | Property Value Type | Description                                                                                                                                                                                                                                                                                                                                                                                                                                   |
Title,| ------------- | ------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
Title,"| spec        | boolean or object | If the value is boolean, a value of true enables spec generation by default and a value of false disables it. A flag passed on the CLI command line overrides this setting, as does a project-specific generateOptions setting (more below). If the value is an object, each key represents a schematic name, and the boolean value determines whether the default spec generation is enabled / disabled for that specific schematic. |"
Title,"| flat        | boolean             | If true, all generate commands will generate a flat structure                                                                                                                                                                                                                                                                                                                                                                                 |"
Title,The following example uses a boolean value to specify that spec file generation should be disabled by default for all projects:
Title,javascript
Title,{
Title,"""generateOptions"": {"
Title,"""spec"": false"
Title,"},"
Title,...
Title,}
Title,The following example uses a boolean value to specify flat file generation should be the default for all projects:
Title,javascript
Title,{
Title,"""generateOptions"": {"
Title,"""flat"": true"
Title,"},"
Title,...
Title,}
Title,"In the following example, spec file generation is disabled only for service schematics (e.g., nest generate service...):"
Title,javascript
Title,{
Title,"""generateOptions"": {"
Title,"""spec"": {"
Title,"""service"": false"
Title,}
Title,"},"
Title,...
Title,}
Title,
Title,"warning Warning When specifying the spec as an object, the key for the generation schematic does not currently support automatic alias handling. This means that specifying a key as for example service: false and trying to generate a service via the alias s, the spec would still be generated. To make sure both the normal schematic name and the alias work as intended, specify both the normal command name as well as the alias, as seen below."
Title,javascript
Title,{
Title,"""generateOptions"": {"
Title,"""spec"": {"
Title,"""service"": false,"
Title,"""s"": false"
Title,}
Title,"},"
Title,...
Title,}
Title,
Title,Project-specific generate options
Title,"In addition to providing global generate options, you may also specify project-specific generate options. The project specific generate options follow the exact same format as the global generate options, but are specified directly on each project."
Title,Project-specific generate options override global generate options.
Title,javascript
Title,{
Title,"""projects"": {"
Title,"""cats-project"": {"
Title,"""generateOptions"": {"
Title,"""spec"": {"
Title,"""service"": false"
Title,}
Title,"},"
Title,...
Title,}
Title,"},"
Title,...
Title,}
Title,
Title,warning Warning The order of precedence for generate options is as follows. Options specified on the CLI command line take precedence over project-specific options. Project-specific options override global options.
Title,
Title,Specified compiler
Title,"The reason for the different default compilers is that for larger projects (e.g., more typical in a monorepo) webpack can have significant advantages in build times and in producing a single file bundling all project components together. If you wish to generate individual files, set ""webpack"" to false, which will cause the build process to use tsc (or swc)."
Title,Webpack options
Title,"The webpack options file can contain standard webpack configuration options. For example, to tell webpack to bundle node_modules (which are excluded by default), add the following to webpack.config.js:"
Title,javascript
Title,module.exports = {
Title,"externals: [],"
Title,};
Title,"Since the webpack config file is a JavaScript file, you can even expose a function that takes default options and returns a modified object:"
Title,javascript
Title,module.exports = function (options) {
Title,return {
Title,"...options,"
Title,"externals: [],"
Title,};
Title,};
Title,Assets
Title,"TypeScript compilation automatically distributes compiler output (.js and .d.ts files) to the specified output directory. It can also be convenient to distribute non-TypeScript files, such as .graphql files, images, .html files and other assets. This allows you to treat nest build (and any initial compilation step) as a lightweight development build step, where you may be editing non-TypeScript files and iteratively compiling and testing."
Title,The assets should be located in the src folder otherwise they will not be copied.
Title,"The value of the assets key should be an array of elements specifying the files to be distributed. The elements can be simple strings with glob-like file specs, for example:"
Title,typescript
Title,"""assets"": [""**/*.graphql""],"
Title,"""watchAssets"": true,"
Title,"For finer control, the elements can be objects with the following keys:"
Title,
Title,"""include"": glob-like file specifications for the assets to be distributed"
Title,"""exclude"": glob-like file specifications for assets to be excluded from the include list"
Title,"""outDir"": a string specifying the path (relative to the root folder) where the assets should be distributed. Defaults to the same output directory configured for compiler output."
Title,"""watchAssets"": boolean; if true, run in watch mode watching specified assets"
Title,
Title,For example:
Title,typescript
Title,"""assets"": ["
Title,"{ ""include"": ""**/*.graphql"", ""exclude"": ""**/omitted.graphql"", ""watchAssets"": true },"
Title,]
Title,
Title,warning Warning Setting watchAssets in a top-level compilerOptions property overrides any watchAssets settings within the assets property.
Title,
Title,Project properties
Title,"This element exists only for monorepo-mode structures. You generally should not edit these properties, as they are used by Nest to locate projects and their configuration options within the monorepo."
Title,
Title,Providers
Title,"Providers are a fundamental concept in Nest. Many of the basic Nest classes may be treated as a provider – services, repositories, factories, helpers, and so on. The main idea of a provider is that it can be injected as a dependency; this means objects can create various relationships with each other, and the function of ""wiring up"" these objects can largely be delegated to the Nest runtime system."
Title,
Title,"In the previous chapter, we built a simple CatsController. Controllers should handle HTTP requests and delegate more complex tasks to providers. Providers are plain JavaScript classes that are declared as providers in a module."
Title,
Title,"info Hint Since Nest enables the possibility to design and organize dependencies in a more OO way, we strongly recommend following the SOLID principles."
Title,
Title,Services
Title,"Let's start by creating a simple CatsService. This service will be responsible for data storage and retrieval, and is designed to be used by the CatsController, so it's a good candidate to be defined as a provider."
Title,```typescript
Title,@@filename(cats.service)
Title,import { Injectable } from '@nestjs/common';
Title,import { Cat } from './interfaces/cat.interface';
Title,@Injectable()
Title,export class CatsService {
Title,private readonly cats: Cat[] = [];
Title,create(cat: Cat) {
Title,this.cats.push(cat);
Title,}
Title,findAll(): Cat[] {
Title,return this.cats;
Title,}
Title,}
Title,@@switch
Title,import { Injectable } from '@nestjs/common';
Title,@Injectable()
Title,export class CatsService {
Title,constructor() {
Title,this.cats = [];
Title,}
Title,create(cat) {
Title,this.cats.push(cat);
Title,}
Title,findAll() {
Title,return this.cats;
Title,}
Title,}
Title,```
Title,
Title,"info Hint To create a service using the CLI, simply execute the $ nest g service cats command."
Title,
Title,"Our CatsService is a basic class with one property and two methods. The only new feature is that it uses the @Injectable() decorator. The @Injectable() decorator attaches metadata, which declares that CatsService  is a class that can be managed by the Nest IoC container. By the way, this example also uses a Cat interface, which probably looks something like this:"
Title,typescript
Title,@@filename(interfaces/cat.interface)
Title,export interface Cat {
Title,name: string;
Title,age: number;
Title,breed: string;
Title,}
Title,"Now that we have a service class to retrieve cats, let's use it inside the CatsController:"
Title,```typescript
Title,@@filename(cats.controller)
Title,"import { Controller, Get, Post, Body } from '@nestjs/common';"
Title,import { CreateCatDto } from './dto/create-cat.dto';
Title,import { CatsService } from './cats.service';
Title,import { Cat } from './interfaces/cat.interface';
Title,@Controller('cats')
Title,export class CatsController {
Title,constructor(private catsService: CatsService) {}
Title,@Post()
Title,async create(@Body() createCatDto: CreateCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,@Get()
Title,async findAll(): Promise {
Title,return this.catsService.findAll();
Title,}
Title,}
Title,@@switch
Title,"import { Controller, Get, Post, Body, Bind, Dependencies } from '@nestjs/common';"
Title,import { CatsService } from './cats.service';
Title,@Controller('cats')
Title,@Dependencies(CatsService)
Title,export class CatsController {
Title,constructor(catsService) {
Title,this.catsService = catsService;
Title,}
Title,@Post()
Title,@Bind(Body())
Title,async create(createCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,@Get()
Title,async findAll() {
Title,return this.catsService.findAll();
Title,}
Title,}
Title,```
Title,The CatsService is injected through the class constructor. Notice the use of the private syntax. This shorthand allows us to both declare and initialize the catsService member immediately in the same location.
Title,Dependency injection
Title,Nest is built around the strong design pattern commonly known as Dependency injection. We recommend reading a great article about this concept in the official Angular documentation.
Title,"In Nest, thanks to TypeScript capabilities, it's extremely easy to manage dependencies because they are resolved just by type. In the example below, Nest will resolve the catsService by creating and returning an instance of CatsService (or, in the normal case of a singleton, returning the existing instance if it has already been requested elsewhere). This dependency is resolved and passed to your controller's constructor (or assigned to the indicated property):"
Title,typescript
Title,constructor(private catsService: CatsService) {}
Title,Scopes
Title,"Providers normally have a lifetime (""scope"") synchronized with the application lifecycle. When the application is bootstrapped, every dependency must be resolved, and therefore every provider has to be instantiated. Similarly, when the application shuts down, each provider will be destroyed. However, there are ways to make your provider lifetime request-scoped as well. You can read more about these techniques here."
Title,
Title,Custom providers
Title,"Nest has a built-in inversion of control (""IoC"") container that resolves relationships between providers. This feature underlies the dependency injection feature described above, but is in fact far more powerful than what we've described so far. There are several ways to define a provider: you can use plain values, classes, and either asynchronous or synchronous factories. More examples are provided here."
Title,Optional providers
Title,"Occasionally, you might have dependencies which do not necessarily have to be resolved. For instance, your class may depend on a configuration object, but if none is passed, the default values should be used. In such a case, the dependency becomes optional, because lack of the configuration provider wouldn't lead to errors."
Title,"To indicate a provider is optional, use the @Optional() decorator in the constructor's signature."
Title,```typescript
Title,"import { Injectable, Optional, Inject } from '@nestjs/common';"
Title,@Injectable()
Title,export class HttpService {
Title,constructor(@Optional() @Inject('HTTP_OPTIONS') private httpClient: T) {}
Title,}
Title,```
Title,"Note that in the example above we are using a custom provider, which is the reason we include the HTTP_OPTIONS custom token. Previous examples showed constructor-based injection indicating a dependency through a class in the constructor. Read more about custom providers and their associated tokens here."
Title,Property-based injection
Title,"The technique we've used so far is called constructor-based injection, as providers are injected via the constructor method. In some very specific cases, property-based injection might be useful. For instance, if your top-level class depends on either one or multiple providers, passing them all the way up by calling super() in sub-classes from the constructor can be very tedious. In order to avoid this, you can use the @Inject() decorator at the property level."
Title,```typescript
Title,"import { Injectable, Inject } from '@nestjs/common';"
Title,@Injectable()
Title,export class HttpService {
Title,@Inject('HTTP_OPTIONS')
Title,private readonly httpClient: T;
Title,}
Title,```
Title,
Title,"warning Warning If your class doesn't extend another class, you should always prefer using constructor-based injection. The constructor explicitly outlines what dependencies are required and provides better visibility than class attributes annotated with @Inject."
Title,
Title,Provider registration
Title,"Now that we have defined a provider (CatsService), and we have a consumer of that service (CatsController), we need to register the service with Nest so that it can perform the injection. We do this by editing our module file (app.module.ts) and adding the service to the providers array of the @Module() decorator."
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { CatsController } from './cats/cats.controller';
Title,import { CatsService } from './cats/cats.service';
Title,@Module({
Title,"controllers: [CatsController],"
Title,"providers: [CatsService],"
Title,})
Title,export class AppModule {}
Title,```
Title,Nest will now be able to resolve the dependencies of the CatsController class.
Title,This is how our directory structure should look now:
Title,
Title,src
Title,
Title,cats
Title,
Title,dto
Title,
Title,create-cat.dto.ts
Title,
Title,interfaces
Title,
Title,cat.interface.ts
Title,
Title,cats.controller.ts
Title,cats.service.ts
Title,
Title,app.module.ts
Title,main.ts
Title,
Title,
Title,Manual instantiation
Title,"Thus far, we've discussed how Nest automatically handles most of the details of resolving dependencies. In certain circumstances, you may need to step outside of the built-in Dependency Injection system and manually retrieve or instantiate providers. We briefly discuss two such topics below."
Title,"To get existing instances, or instantiate providers dynamically, you can use Module reference."
Title,"To get providers within the bootstrap() function (for example for standalone applications without controllers, or to utilize a configuration service during bootstrapping) see Standalone applications."
Title,
Title,Controllers
Title,Controllers are responsible for handling incoming requests and returning responses to the client.
Title,
Title,"A controller's purpose is to receive specific requests for the application. The routing mechanism controls which controller receives which requests. Frequently, each controller has more than one route, and different routes can perform different actions."
Title,"In order to create a basic controller, we use classes and decorators. Decorators associate classes with required metadata and enable Nest to create a routing map (tie requests to the corresponding controllers)."
Title,
Title,"info Hint For quickly creating a CRUD controller with the validation built-in, you may use the CLI's CRUD generator: nest g resource [name]."
Title,
Title,Routing
Title,"In the following example we'll use the @Controller() decorator, which is required to define a basic controller. We'll specify an optional route path prefix of cats. Using a path prefix in a @Controller() decorator allows us to easily group a set of related routes, and minimize repetitive code. For example, we may choose to group a set of routes that manage interactions with a cat entity under the route /cats. In that case, we could specify the path prefix cats in the @Controller() decorator so that we don't have to repeat that portion of the path for each route in the file."
Title,```typescript
Title,@@filename(cats.controller)
Title,"import { Controller, Get } from '@nestjs/common';"
Title,@Controller('cats')
Title,export class CatsController {
Title,@Get()
Title,findAll(): string {
Title,return 'This action returns all cats';
Title,}
Title,}
Title,@@switch
Title,"import { Controller, Get } from '@nestjs/common';"
Title,@Controller('cats')
Title,export class CatsController {
Title,@Get()
Title,findAll() {
Title,return 'This action returns all cats';
Title,}
Title,}
Title,```
Title,
Title,"info Hint To create a controller using the CLI, simply execute the $ nest g controller [name] command."
Title,
Title,"The @Get() HTTP request method decorator before the findAll() method tells Nest to create a handler for a specific endpoint for HTTP requests. The endpoint corresponds to the HTTP request method (GET in this case) and the route path. What is the route path? The route path for a handler is determined by concatenating the (optional) prefix declared for the controller, and any path specified in the method's decorator. Since we've declared a prefix for every route ( cats), and haven't added any path information in the decorator, Nest will map GET /cats requests to this handler. As mentioned, the path includes both the optional controller path prefix and any path string declared in the request method decorator. For example, a path prefix of cats combined with the decorator @Get('breed') would produce a route mapping for requests like GET /cats/breed."
Title,"In our example above, when a GET request is made to this endpoint, Nest routes the request to our user-defined findAll() method. Note that the method name we choose here is completely arbitrary. We obviously must declare a method to bind the route to, but Nest doesn't attach any significance to the method name chosen."
Title,"This method will return a 200 status code and the associated response, which in this case is just a string. Why does that happen? To explain, we'll first introduce the concept that Nest employs two different options for manipulating responses:"
Title,
Title,
Title,Standard (recommended)
Title,
Title,"Using this built-in method, when a request handler returns a JavaScript object or array, it will automatically"
Title,"be serialized to JSON. When it returns a JavaScript primitive type (e.g., string, number, boolean), however, Nest will send just the value without attempting to serialize it. This makes response handling simple: just return the value, and Nest takes care of the rest."
Title,
Title,"Furthermore, the response's status code is always 200 by default, except for POST"
Title,requests which use 201. We can easily change this behavior by adding the @HttpCode(...)
Title,decorator at a handler-level (see Status codes).
Title,
Title,
Title,
Title,Library-specific
Title,
Title,"We can use the library-specific (e.g., Express) response object, which can be injected using the @Res() decorator in the method handler signature (e.g., findAll(@Res() response)).  With this approach, you have the ability to use the native response handling methods exposed by that object.  For example, with Express, you can construct responses using code like response.status(200).send()."
Title,
Title,
Title,
Title,
Title,"warning Warning Nest detects when the handler is using either @Res() or @Next(), indicating you have chosen the library-specific option. If both approaches are used at the same time, the Standard approach is automatically disabled for this single route and will no longer work as expected. To use both approaches at the same time (for example, by injecting the response object to only set cookies/headers but still leave the rest to the framework), you must set the passthrough option to true in the @Res({{ '{' }} passthrough: true {{ '}' }}) decorator."
Title,
Title,
Title,Request object
Title,Handlers often need access to the client request details. Nest provides access to the request object of the underlying platform (Express by default). We can access the request object by instructing Nest to inject it by adding the @Req() decorator to the handler's signature.
Title,```typescript
Title,@@filename(cats.controller)
Title,"import { Controller, Get, Req } from '@nestjs/common';"
Title,import { Request } from 'express';
Title,@Controller('cats')
Title,export class CatsController {
Title,@Get()
Title,findAll(@Req() request: Request): string {
Title,return 'This action returns all cats';
Title,}
Title,}
Title,@@switch
Title,"import { Controller, Bind, Get, Req } from '@nestjs/common';"
Title,@Controller('cats')
Title,export class CatsController {
Title,@Get()
Title,@Bind(Req())
Title,findAll(request) {
Title,return 'This action returns all cats';
Title,}
Title,}
Title,```
Title,
Title,"info Hint In order to take advantage of express typings (as in the request: Request parameter example above), install @types/express package."
Title,
Title,"The request object represents the HTTP request and has properties for the request query string, parameters, HTTP headers, and body (read more here). In most cases, it's not necessary to grab these properties manually. We can use dedicated decorators instead, such as @Body() or @Query(), which are available out of the box. Below is a list of the provided decorators and the plain platform-specific objects they represent."
Title,
Title,
Title,
Title,"@Request(), @Req()"
Title,req
Title,
Title,"@Response(), @Res()*"
Title,res
Title,
Title,
Title,@Next()
Title,next
Title,
Title,
Title,@Session()
Title,req.session
Title,
Title,
Title,@Param(key?: string)
Title,req.params / req.params[key]
Title,
Title,
Title,@Body(key?: string)
Title,req.body / req.body[key]
Title,
Title,
Title,@Query(key?: string)
Title,req.query / req.query[key]
Title,
Title,
Title,@Headers(name?: string)
Title,req.headers / req.headers[name]
Title,
Title,
Title,@Ip()
Title,req.ip
Title,
Title,
Title,@HostParam()
Title,req.hosts
Title,
Title,
Title,
Title,"* For compatibility with typings across underlying HTTP platforms (e.g., Express and Fastify), Nest provides @Res() and @Response() decorators. @Res() is simply an alias for @Response(). Both directly expose the underlying native platform response object interface. When using them, you should also import the typings for the underlying library (e.g., @types/express) to take full advantage. Note that when you inject either @Res() or @Response() in a method handler, you put Nest into Library-specific mode for that handler, and you become responsible for managing the response. When doing so, you must issue some kind of response by making a call on the response object (e.g., res.json(...) or res.send(...)), or the HTTP server will hang."
Title,
Title,"info Hint To learn how to create your own custom decorators, visit this chapter."
Title,
Title,Resources
Title,"Earlier, we defined an endpoint to fetch the cats resource (GET route). We'll typically also want to provide an endpoint that creates new records. For this, let's create the POST handler:"
Title,```typescript
Title,@@filename(cats.controller)
Title,"import { Controller, Get, Post } from '@nestjs/common';"
Title,@Controller('cats')
Title,export class CatsController {
Title,@Post()
Title,create(): string {
Title,return 'This action adds a new cat';
Title,}
Title,@Get()
Title,findAll(): string {
Title,return 'This action returns all cats';
Title,}
Title,}
Title,@@switch
Title,"import { Controller, Get, Post } from '@nestjs/common';"
Title,@Controller('cats')
Title,export class CatsController {
Title,@Post()
Title,create() {
Title,return 'This action adds a new cat';
Title,}
Title,@Get()
Title,findAll() {
Title,return 'This action returns all cats';
Title,}
Title,}
Title,```
Title,"It's that simple. Nest provides decorators for all of the standard HTTP methods: @Get(), @Post(), @Put(), @Delete(), @Patch(), @Options(), and @Head(). In addition, @All() defines an endpoint that handles all of them."
Title,Route wildcards
Title,"Pattern based routes are supported as well. For instance, the asterisk is used as a wildcard, and will match any combination of characters."
Title,typescript
Title,@Get('ab*cd')
Title,findAll() {
Title,return 'This route uses a wildcard';
Title,}
Title,"The 'ab*cd' route path will match abcd, ab_cd, abecd, and so on. The characters ?, +, *, and () may be used in a route path, and are subsets of their regular expression counterparts. The hyphen ( -) and the dot (.) are interpreted literally by string-based paths."
Title,
Title,warning Warning A wildcard in the middle of the route is only supported by express.
Title,
Title,Status code
Title,"As mentioned, the response status code is always 200 by default, except for POST requests which are 201. We can easily change this behavior by adding the @HttpCode(...) decorator at a handler level."
Title,typescript
Title,@Post()
Title,@HttpCode(204)
Title,create() {
Title,return 'This action adds a new cat';
Title,}
Title,
Title,info Hint Import HttpCode from the @nestjs/common package.
Title,
Title,"Often, your status code isn't static but depends on various factors. In that case, you can use a library-specific response (inject using @Res()) object (or, in case of an error, throw an exception)."
Title,Headers
Title,"To specify a custom response header, you can either use a @Header() decorator or a library-specific response object (and call res.header() directly)."
Title,typescript
Title,@Post()
Title,"@Header('Cache-Control', 'no-store')"
Title,create() {
Title,return 'This action adds a new cat';
Title,}
Title,
Title,info Hint Import Header from the @nestjs/common package.
Title,
Title,Redirection
Title,"To redirect a response to a specific URL, you can either use a @Redirect() decorator or a library-specific response object (and call res.redirect() directly)."
Title,"@Redirect() takes two arguments, url and statusCode, both are optional. The default value of statusCode is 302 (Found) if omitted."
Title,typescript
Title,@Get()
Title,"@Redirect('https://nestjs.com', 301)"
Title,
Title,info Hint Sometimes you may want to determine the HTTP status code or the redirect URL dynamically. Do this by returning an object following the HttpRedirectResponse interface (from @nestjs/common).
Title,
Title,Returned values will override any arguments passed to the @Redirect() decorator. For example:
Title,typescript
Title,@Get('docs')
Title,"@Redirect('https://docs.nestjs.com', 302)"
Title,getDocs(@Query('version') version) {
Title,if (version && version === '5') {
Title,return { url: 'https://docs.nestjs.com/v5/' };
Title,}
Title,}
Title,Route parameters
Title,"Routes with static paths won't work when you need to accept dynamic data as part of the request (e.g., GET /cats/1 to get cat with id 1). In order to define routes with parameters, we can add route parameter tokens in the path of the route to capture the dynamic value at that position in the request URL. The route parameter token in the @Get() decorator example below demonstrates this usage. Route parameters declared in this way can be accessed using the @Param() decorator, which should be added to the method signature."
Title,
Title,info Hint Routes with parameters should be declared after any static paths. This prevents the parameterized paths from intercepting traffic destined for the static paths.
Title,
Title,typescript
Title,@@filename()
Title,@Get(':id')
Title,findOne(@Param() params: any): string {
Title,console.log(params.id);
Title,return `This action returns a #${params.id} cat`;
Title,}
Title,@@switch
Title,@Get(':id')
Title,@Bind(Param())
Title,findOne(params) {
Title,console.log(params.id);
Title,return `This action returns a #${params.id} cat`;
Title,}
Title,"@Param() is used to decorate a method parameter (params in the example above), and makes the route parameters available as properties of that decorated method parameter inside the body of the method. As seen in the code above, we can access the id parameter by referencing params.id. You can also pass in a particular parameter token to the decorator, and then reference the route parameter directly by name in the method body."
Title,
Title,info Hint Import Param from the @nestjs/common package.
Title,
Title,typescript
Title,@@filename()
Title,@Get(':id')
Title,findOne(@Param('id') id: string): string {
Title,return `This action returns a #${id} cat`;
Title,}
Title,@@switch
Title,@Get(':id')
Title,@Bind(Param('id'))
Title,findOne(id) {
Title,return `This action returns a #${id} cat`;
Title,}
Title,Sub-Domain Routing
Title,The @Controller decorator can take a host option to require that the HTTP host of the incoming requests matches some specific value.
Title,typescript
Title,@Controller({ host: 'admin.example.com' })
Title,export class AdminController {
Title,@Get()
Title,index(): string {
Title,return 'Admin page';
Title,}
Title,}
Title,
Title,"Warning Since Fastify lacks support for nested routers, when using sub-domain routing, the (default) Express adapter should be used instead."
Title,
Title,"Similar to a route path, the hosts option can use tokens to capture the dynamic value at that position in the host name. The host parameter token in the @Controller() decorator example below demonstrates this usage. Host parameters declared in this way can be accessed using the @HostParam() decorator, which should be added to the method signature."
Title,typescript
Title,@Controller({ host: ':account.example.com' })
Title,export class AccountController {
Title,@Get()
Title,getInfo(@HostParam('account') account: string) {
Title,return account;
Title,}
Title,}
Title,Scopes
Title,"For people coming from different programming language backgrounds, it might be unexpected to learn that in Nest, almost everything is shared across incoming requests. We have a connection pool to the database, singleton services with global state, etc. Remember that Node.js doesn't follow the request/response Multi-Threaded Stateless Model in which every request is processed by a separate thread. Hence, using singleton instances is fully safe for our applications."
Title,"However, there are edge-cases when request-based lifetime of the controller may be the desired behavior, for instance per-request caching in GraphQL applications, request tracking or multi-tenancy. Learn how to control scopes here."
Title,Asynchronicity
Title,We love modern JavaScript and we know that data extraction is mostly asynchronous. That's why Nest supports and works well with async functions.
Title,
Title,info Hint Learn more about async / await feature here
Title,
Title,Every async function has to return a Promise. This means that you can return a deferred value that Nest will be able to resolve by itself. Let's see an example of this:
Title,typescript
Title,@@filename(cats.controller)
Title,@Get()
Title,async findAll(): Promise<any[]> {
Title,return [];
Title,}
Title,@@switch
Title,@Get()
Title,async findAll() {
Title,return [];
Title,}
Title,"The above code is fully valid. Furthermore, Nest route handlers are even more powerful by being able to return RxJS observable streams. Nest will automatically subscribe to the source underneath and take the last emitted value (once the stream is completed)."
Title,typescript
Title,@@filename(cats.controller)
Title,@Get()
Title,findAll(): Observable<any[]> {
Title,return of([]);
Title,}
Title,@@switch
Title,@Get()
Title,findAll() {
Title,return of([]);
Title,}
Title,Both of the above approaches work and you can use whatever fits your requirements.
Title,Request payloads
Title,Our previous example of the POST route handler didn't accept any client params. Let's fix this by adding the @Body() decorator here.
Title,"But first (if you use TypeScript), we need to determine the DTO (Data Transfer Object) schema. A DTO is an object that defines how the data will be sent over the network. We could determine the DTO schema by using TypeScript interfaces, or by simple classes. Interestingly, we recommend using classes here. Why? Classes are part of the JavaScript ES6 standard, and therefore they are preserved as real entities in the compiled JavaScript. On the other hand, since TypeScript interfaces are removed during the transpilation, Nest can't refer to them at runtime. This is important because features such as Pipes enable additional possibilities when they have access to the metatype of the variable at runtime."
Title,Let's create the CreateCatDto class:
Title,typescript
Title,@@filename(create-cat.dto)
Title,export class CreateCatDto {
Title,name: string;
Title,age: number;
Title,breed: string;
Title,}
Title,It has only three basic properties. Thereafter we can use the newly created DTO inside the CatsController:
Title,typescript
Title,@@filename(cats.controller)
Title,@Post()
Title,async create(@Body() createCatDto: CreateCatDto) {
Title,return 'This action adds a new cat';
Title,}
Title,@@switch
Title,@Post()
Title,@Bind(Body())
Title,async create(createCatDto) {
Title,return 'This action adds a new cat';
Title,}
Title,
Title,"info Hint Our ValidationPipe can filter out properties that should not be received by the method handler. In this case, we can whitelist the acceptable properties, and any property not included in the whitelist is automatically stripped from the resulting object. In the CreateCatDto example, our whitelist is the name, age, and breed properties. Learn more here."
Title,
Title,Handling errors
Title,"There's a separate chapter about handling errors (i.e., working with exceptions) here."
Title,Full resource sample
Title,Below is an example that makes use of several of the available decorators to create a basic controller. This controller exposes a couple of methods to access and manipulate internal data.
Title,```typescript
Title,@@filename(cats.controller)
Title,"import { Controller, Get, Query, Post, Body, Put, Param, Delete } from '@nestjs/common';"
Title,"import { CreateCatDto, UpdateCatDto, ListAllEntities } from './dto';"
Title,@Controller('cats')
Title,export class CatsController {
Title,@Post()
Title,create(@Body() createCatDto: CreateCatDto) {
Title,return 'This action adds a new cat';
Title,}
Title,@Get()
Title,findAll(@Query() query: ListAllEntities) {
Title,return This action returns all cats (limit: ${query.limit} items);
Title,}
Title,@Get(':id')
Title,findOne(@Param('id') id: string) {
Title,return This action returns a #${id} cat;
Title,}
Title,@Put(':id')
Title,"update(@Param('id') id: string, @Body() updateCatDto: UpdateCatDto) {"
Title,return This action updates a #${id} cat;
Title,}
Title,@Delete(':id')
Title,remove(@Param('id') id: string) {
Title,return This action removes a #${id} cat;
Title,}
Title,}
Title,@@switch
Title,"import { Controller, Get, Query, Post, Body, Put, Param, Delete, Bind } from '@nestjs/common';"
Title,@Controller('cats')
Title,export class CatsController {
Title,@Post()
Title,@Bind(Body())
Title,create(createCatDto) {
Title,return 'This action adds a new cat';
Title,}
Title,@Get()
Title,@Bind(Query())
Title,findAll(query) {
Title,console.log(query);
Title,return This action returns all cats (limit: ${query.limit} items);
Title,}
Title,@Get(':id')
Title,@Bind(Param('id'))
Title,findOne(id) {
Title,return This action returns a #${id} cat;
Title,}
Title,@Put(':id')
Title,"@Bind(Param('id'), Body())"
Title,"update(id, updateCatDto) {"
Title,return This action updates a #${id} cat;
Title,}
Title,@Delete(':id')
Title,@Bind(Param('id'))
Title,remove(id) {
Title,return This action removes a #${id} cat;
Title,}
Title,}
Title,```
Title,
Title,"info Hint Nest CLI provides a generator (schematic) that automatically generates all the boilerplate code to help us avoid doing all of this, and make the developer experience much simpler. Read more about this feature here."
Title,
Title,Getting up and running
Title,"With the above controller fully defined, Nest still doesn't know that CatsController exists and as a result won't create an instance of this class."
Title,"Controllers always belong to a module, which is why we include the controllers array within the @Module() decorator. Since we haven't yet defined any other modules except the root AppModule, we'll use that to introduce the CatsController:"
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { CatsController } from './cats/cats.controller';
Title,@Module({
Title,"controllers: [CatsController],"
Title,})
Title,export class AppModule {}
Title,```
Title,"We attached the metadata to the module class using the @Module() decorator, and Nest can now easily reflect which controllers have to be mounted."
Title,Library-specific approach
Title,"So far we've discussed the Nest standard way of manipulating responses. The second way of manipulating the response is to use a library-specific response object. In order to inject a particular response object, we need to use the @Res() decorator. To show the differences, let's rewrite the CatsController to the following:"
Title,```typescript
Title,@@filename()
Title,"import { Controller, Get, Post, Res, HttpStatus } from '@nestjs/common';"
Title,import { Response } from 'express';
Title,@Controller('cats')
Title,export class CatsController {
Title,@Post()
Title,create(@Res() res: Response) {
Title,res.status(HttpStatus.CREATED).send();
Title,}
Title,@Get()
Title,findAll(@Res() res: Response) {
Title,res.status(HttpStatus.OK).json([]);
Title,}
Title,}
Title,@@switch
Title,"import { Controller, Get, Post, Bind, Res, Body, HttpStatus } from '@nestjs/common';"
Title,@Controller('cats')
Title,export class CatsController {
Title,@Post()
Title,"@Bind(Res(), Body())"
Title,"create(res, createCatDto) {"
Title,res.status(HttpStatus.CREATED).send();
Title,}
Title,@Get()
Title,@Bind(Res())
Title,findAll(res) {
Title,res.status(HttpStatus.OK).json([]);
Title,}
Title,}
Title,```
Title,"Though this approach works, and does in fact allow for more flexibility in some ways by providing full control of the response object (headers manipulation, library-specific features, and so on), it should be used with care. In general, the approach is much less clear and does have some disadvantages. The main disadvantage is that your code becomes platform-dependent (as underlying libraries may have different APIs on the response object), and harder to test (you'll have to mock the response object, etc.)."
Title,"Also, in the example above, you lose compatibility with Nest features that depend on Nest standard response handling, such as Interceptors and @HttpCode() / @Header() decorators. To fix this, you can set the passthrough option to true, as follows:"
Title,typescript
Title,@@filename()
Title,@Get()
Title,findAll(@Res({ passthrough: true }) res: Response) {
Title,res.status(HttpStatus.OK);
Title,return [];
Title,}
Title,@@switch
Title,@Get()
Title,@Bind(Res({ passthrough: true }))
Title,findAll(res) {
Title,res.status(HttpStatus.OK);
Title,return [];
Title,}
Title,"Now you can interact with the native response object (for example, set cookies or headers depending on certain conditions), but leave the rest to the framework."
Title,
Title,Custom route decorators
Title,"Nest is built around a language feature called decorators. Decorators are a well-known concept in a lot of commonly used programming languages, but in the JavaScript world, they're still relatively new. In order to better understand how decorators work, we recommend reading this article. Here's a simple definition:"
Title,
Title,"An ES2016 decorator is an expression which returns a function and can take a target, name and property descriptor as arguments."
Title,You apply it by prefixing the decorator with an @ character and placing this at the very top of what
Title,"you are trying to decorate. Decorators can be defined for either a class, a method or a property."
Title,
Title,Param decorators
Title,Nest provides a set of useful param decorators that you can use together with the HTTP route handlers. Below is a list of the provided decorators and the plain Express (or Fastify) objects they represent
Title,
Title,
Title,
Title,"@Request(), @Req()"
Title,req
Title,
Title,
Title,"@Response(), @Res()"
Title,res
Title,
Title,
Title,@Next()
Title,next
Title,
Title,
Title,@Session()
Title,req.session
Title,
Title,
Title,@Param(param?: string)
Title,req.params / req.params[param]
Title,
Title,
Title,@Body(param?: string)
Title,req.body / req.body[param]
Title,
Title,
Title,@Query(param?: string)
Title,req.query / req.query[param]
Title,
Title,
Title,@Headers(param?: string)
Title,req.headers / req.headers[param]
Title,
Title,
Title,@Ip()
Title,req.ip
Title,
Title,
Title,@HostParam()
Title,req.hosts
Title,
Title,
Title,
Title,"Additionally, you can create your own custom decorators. Why is this useful?"
Title,"In the node.js world, it's common practice to attach properties to the request object. Then you manually extract them in each route handler, using code like the following:"
Title,typescript
Title,const user = req.user;
Title,"In order to make your code more readable and transparent, you can create a @User() decorator and reuse it across all of your controllers."
Title,```typescript
Title,@@filename(user.decorator)
Title,"import { createParamDecorator, ExecutionContext } from '@nestjs/common';"
Title,export const User = createParamDecorator(
Title,"(data: unknown, ctx: ExecutionContext) => {"
Title,const request = ctx.switchToHttp().getRequest();
Title,return request.user;
Title,"},"
Title,);
Title,```
Title,"Then, you can simply use it wherever it fits your requirements."
Title,typescript
Title,@@filename()
Title,@Get()
Title,async findOne(@User() user: UserEntity) {
Title,console.log(user);
Title,}
Title,@@switch
Title,@Get()
Title,@Bind(User())
Title,async findOne(user) {
Title,console.log(user);
Title,}
Title,Passing data
Title,"When the behavior of your decorator depends on some conditions, you can use the data parameter to pass an argument to the decorator's factory function. One use case for this is a custom decorator that extracts properties from the request object by key. Let's assume, for example, that our authentication layer validates requests and attaches a user entity to the request object. The user entity for an authenticated request might look like:"
Title,json
Title,{
Title,"""id"": 101,"
Title,"""firstName"": ""Alan"","
Title,"""lastName"": ""Turing"","
Title,"""email"": ""alan@email.com"","
Title,"""roles"": [""admin""]"
Title,}
Title,"Let's define a decorator that takes a property name as key, and returns the associated value if it exists (or undefined if it doesn't exist, or if the user object has not been created)."
Title,```typescript
Title,@@filename(user.decorator)
Title,"import { createParamDecorator, ExecutionContext } from '@nestjs/common';"
Title,export const User = createParamDecorator(
Title,"(data: string, ctx: ExecutionContext) => {"
Title,const request = ctx.switchToHttp().getRequest();
Title,const user = request.user;
Title,return data ? user?.[data] : user;
Title,
Title,"},"
Title,);
Title,@@switch
Title,import { createParamDecorator } from '@nestjs/common';
Title,"export const User = createParamDecorator((data, ctx) => {"
Title,const request = ctx.switchToHttp().getRequest();
Title,const user = request.user;
Title,return data ? user && user[data] : user;
Title,});
Title,```
Title,Here's how you could then access a particular property via the @User() decorator in the controller:
Title,typescript
Title,@@filename()
Title,@Get()
Title,async findOne(@User('firstName') firstName: string) {
Title,console.log(`Hello ${firstName}`);
Title,}
Title,@@switch
Title,@Get()
Title,@Bind(User('firstName'))
Title,async findOne(firstName) {
Title,console.log(`Hello ${firstName}`);
Title,}
Title,"You can use this same decorator with different keys to access different properties. If the user object is deep or complex, this can make for easier and more readable request handler implementations."
Title,
Title,"info Hint For TypeScript users, note that createParamDecorator<T>() is a generic. This means you can explicitly enforce type safety, for example createParamDecorator<string>((data, ctx) => ...). Alternatively, specify a parameter type in the factory function, for example createParamDecorator((data: string, ctx) => ...). If you omit both, the type for data will be any."
Title,
Title,Working with pipes
Title,"Nest treats custom param decorators in the same fashion as the built-in ones (@Body(), @Param() and @Query()). This means that pipes are executed for the custom annotated parameters as well (in our examples, the user argument). Moreover, you can apply the pipe directly to the custom decorator:"
Title,typescript
Title,@@filename()
Title,@Get()
Title,async findOne(
Title,@User(new ValidationPipe({ validateCustomDecorators: true }))
Title,"user: UserEntity,"
Title,) {
Title,console.log(user);
Title,}
Title,@@switch
Title,@Get()
Title,@Bind(User(new ValidationPipe({ validateCustomDecorators: true })))
Title,async findOne(user) {
Title,console.log(user);
Title,}
Title,
Title,info Hint Note that validateCustomDecorators option must be set to true. ValidationPipe does not validate arguments annotated with the custom decorators by default.
Title,
Title,Decorator composition
Title,"Nest provides a helper method to compose multiple decorators. For example, suppose you want to combine all decorators related to authentication into a single decorator. This could be done with the following construction:"
Title,```typescript
Title,@@filename(auth.decorator)
Title,import { applyDecorators } from '@nestjs/common';
Title,export function Auth(...roles: Role[]) {
Title,return applyDecorators(
Title,"SetMetadata('roles', roles),"
Title,"UseGuards(AuthGuard, RolesGuard),"
Title,"ApiBearerAuth(),"
Title,"ApiUnauthorizedResponse({ description: 'Unauthorized' }),"
Title,);
Title,}
Title,@@switch
Title,import { applyDecorators } from '@nestjs/common';
Title,export function Auth(...roles) {
Title,return applyDecorators(
Title,"SetMetadata('roles', roles),"
Title,"UseGuards(AuthGuard, RolesGuard),"
Title,"ApiBearerAuth(),"
Title,"ApiUnauthorizedResponse({ description: 'Unauthorized' }),"
Title,);
Title,}
Title,```
Title,You can then use this custom @Auth() decorator as follows:
Title,typescript
Title,@Get('users')
Title,@Auth('admin')
Title,findAllUsers() {}
Title,This has the effect of applying all four decorators with a single declaration.
Title,
Title,warning Warning The @ApiHideProperty() decorator from the @nestjs/swagger package is not composable and won't work properly with the applyDecorators function.
Title,
Title,
Title,Deployment
Title,"When you're ready to deploy your NestJS application to production, there are key steps you can take to ensure it runs as efficiently as possible. In this guide, we'll explore essential tips and best practices to help you deploy your NestJS application successfully."
Title,Prerequisites
Title,"Before deploying your NestJS application, ensure you have:"
Title,
Title,A working NestJS application that is ready for deployment.
Title,Access to a deployment platform or server where you can host your application.
Title,All necessary environment variables set up for your application.
Title,"Any required services, like a database, set up and ready to go."
Title,At least an LTS version of Node.js installed on your deployment platform.
Title,
Title,
Title,"info Hint If you are looking for a cloud-based platform to deploy your NestJS application, check out Mau, our official platform for deploying NestJS applications on AWS. With Mau, deploying your NestJS application is as simple as clicking a few buttons and running a single command:"
Title,bash
Title,$ npm install -g @nestjs/mau
Title,$ mau deploy
Title,"Once the deployment is complete, you'll have your NestJS application up and running on AWS in seconds!"
Title,
Title,Building your application
Title,"To build your NestJS application, you need to compile your TypeScript code into JavaScript. This process generates a dist directory containing the compiled files. You can build your application by running the following command:"
Title,bash
Title,$ npm run build
Title,"This command typically runs the nest build command under the hood, which is basically a wrapper around the TypeScript compiler with some additional features (assets copying, etc.). In case you have a custom build script, you can run it directly. Also, for NestJS CLI mono-repos, make sure to pass the name of the project to build as an argument (npm run build my-app)."
Title,"Upon successful compilation, you should see a dist directory in your project root containing the compiled files, with the entry point being main.js. If you have any .ts files located in the root directory of your project (and your tsconfig.json configured to compile them), they will be copied to the dist directory as well, modifying the directory structure a bit (instead of dist/main.js, you will have dist/src/main.js so keep that in mind when configuring your server)."
Title,Production environment
Title,"Your production environment is where your application will be accessible to external users. This could be a cloud-based platform like AWS (with EC2, ECS, etc.), Azure, or Google Cloud, or even a dedicated server you manage, such as Hetzner."
Title,"To simplify the deployment process and avoid manual setup, you can use a service like Mau, our official platform for deploying NestJS applications on AWS. For more details, check out this section."
Title,Some of the pros of using a cloud-based platform or service like Mau include:
Title,
Title,Scalability: Easily scale your application as your user base grows.
Title,Security: Benefit from built-in security features and compliance certifications.
Title,Monitoring: Monitor your application's performance and health in real-time.
Title,Reliability: Ensure your application is always available with high uptime guarantees.
Title,
Title,"On the other hand, cloud-based platforms are typically more expensive than self-hosting, and you may have less control over the underlying infrastructure. Simple VPS can be a good choice if you're looking for a more cost-effective solution and have the technical expertise to manage the server yourself, but keep in mind that you'll need to handle tasks like server maintenance, security, and backups manually."
Title,NODE_ENV=production
Title,"While there's technically no difference between development and production in Node.js and NestJS, it's a good practice to set the NODE_ENV environment variable to production when running your application in a production environment, as some libraries in the ecosystem may behave differently based on this variable (e.g., enabling or disabling debugging output, etc.)."
Title,You can set the NODE_ENV environment variable when starting your application like so:
Title,bash
Title,$ NODE_ENV=production node dist/main.js
Title,Or just set it in your cloud provider's/Mau dashboard.
Title,Running your application
Title,"To run your NestJS application in production, just use the following command:"
Title,bash
Title,$ node dist/main.js # Adjust this based on your entry point location
Title,"This command starts your application, which will listen on the specified port (usually 3000 by default). Ensure that this matches the port you’ve configured in your application."
Title,"Alternatively, you can use the nest start command. This command is a wrapper around node dist/main.js, but it has one key difference: it automatically runs nest build before starting the application, so you don’t need to manually execute npm run build."
Title,Health checks
Title,"Health checks are essential for monitoring the health and status of your NestJS application in production. By setting up a health check endpoint, you can regularly verify that your app is running as expected and respond to issues before they become critical."
Title,"In NestJS, you can easily implement health checks using the @nestjs/terminus package, which provides a powerful tool for adding health checks, including database connections, external services, and custom checks."
Title,"Check out this guide to learn how to implement health checks in your NestJS application, and ensure your app is always monitored and responsive."
Title,Logging
Title,"Logging is essential for any production-ready application. It helps track errors, monitor behavior, and troubleshoot issues. In NestJS, you can easily manage logging with the built-in logger or opt for external libraries if you need more advanced features."
Title,Best practices for logging:
Title,
Title,"Log Errors, Not Exceptions: Focus on logging detailed error messages to speed up debugging and issue resolution."
Title,Avoid Sensitive Data: Never log sensitive information like passwords or tokens to protect security.
Title,"Use Correlation IDs: In distributed systems, include unique identifiers (like correlation IDs) in your logs to trace requests across different services."
Title,"Use Log Levels: Categorize logs by severity (e.g., info, warn, error) and disable debug or verbose logs in production to reduce noise."
Title,
Title,
Title,"info Hint If you're using AWS (with Mau or directly), consider JSON logging to make it easier to parse and analyze your logs."
Title,
Title,"For distributed applications, using a centralized logging service like ElasticSearch, Loggly, or Datadog can be incredibly useful. These tools offer powerful features like log aggregation, search, and visualization, making it easier to monitor and analyze your application's performance and behavior."
Title,Scaling up or out
Title,Scaling your NestJS application effectively is crucial for handling increased traffic and ensuring optimal performance. There are two primary strategies for scaling: vertical scaling and horizontal scaling. Understanding these approaches will help you design your application to manage load efficiently.
Title,"Vertical scaling, often referred to as ""scaling up"" involves increasing the resources of a single server to enhance its performance. This could mean adding more CPU, RAM, or storage to your existing machine. Here are some key points to consider:"
Title,
Title,Simplicity: Vertical scaling is generally simpler to implement since you only need to upgrade your existing server rather than manage multiple instances.
Title,"Limitations: There are physical limits to how much you can scale a single machine. Once you reach the maximum capacity, you may need to consider other options."
Title,"Cost-Effectiveness: For applications with moderate traffic, vertical scaling can be cost-effective, as it reduces the need for additional infrastructure."
Title,
Title,"Example: If your NestJS app is hosted on a virtual machine and you notice that it’s running slowly during peak hours, you can upgrade your VM to a larger instance with more resources. To upgrade your VM, just navigate to your current provider's dashboard and select a larger instance type."
Title,"Horizontal scaling, or ""scaling out"" involves adding more servers or instances to distribute the load. This strategy is widely used in cloud environments and is essential for applications expecting high traffic. Here are the benefits and considerations:"
Title,
Title,"Increased Capacity: By adding more instances of your application, you can handle a larger number of concurrent users without degrading performance."
Title,"Redundancy: Horizontal scaling offers redundancy, as the failure of one server won't bring down your entire application. Traffic can be redistributed among the remaining servers."
Title,"Load Balancing: To manage multiple instances effectively, use load balancers (like Nginx or AWS Elastic Load Balancing) to distribute incoming traffic evenly across your servers."
Title,
Title,"Example: For a NestJS application experiencing high traffic, you can deploy multiple instances of your app in a cloud environment and use a load balancer to route requests, ensuring that no single instance becomes a bottleneck."
Title,"This process is straightforward with containerization technologies like Docker and container orchestration platforms such as Kubernetes. Additionally, you can leverage cloud-specific load balancers like AWS Elastic Load Balancing or Azure Load Balancer to distribute traffic across your application instances."
Title,
Title,"info Hint Mau offers built-in support for horizontal scaling on AWS, allowing you to easily deploy multiple instances of your NestJS application and manage them with just a few clicks."
Title,
Title,Some other tips
Title,There are a few more tips to keep in mind when deploying your NestJS application:
Title,
Title,"Security: Ensure your application is secure and protected from common threats like SQL injection, XSS, etc. See the ""Security"" category for more details."
Title,"Monitoring: Use monitoring tools like Prometheus or New Relic to track your application's performance and health. If you're using a cloud provider/Mau, they may offer built-in monitoring services (like AWS CloudWatch etc.)"
Title,"Do not hardcode environment variables: Avoid hardcoding sensitive information like API keys, passwords, or tokens in your code. Use environment variables or a secrets manager to store and access these values securely."
Title,Backups: Regularly back up your data to prevent data loss in case of an incident.
Title,Automate deployments: Use CI/CD pipelines to automate your deployment process and ensure consistency across environments.
Title,"Rate limiting: Implement rate limiting to prevent abuse and protect your application from DDoS attacks. Check out Rate limiting chapter for more details, or use a service like AWS WAF for advanced protection."
Title,
Title,Dockerizing your application
Title,"Docker is a platform that uses containerization to allow developers to package applications along with their dependencies into a standardized unit called a container. Containers are lightweight, portable, and isolated, making them ideal for deploying applications in various environments, from local development to production."
Title,Benefits of Dockerizing your NestJS application:
Title,
Title,"Consistency: Docker ensures that your application runs the same way on any machine, eliminating the ""it works on my machine"" problem."
Title,"Isolation: Each container runs in its isolated environment, preventing conflicts between dependencies."
Title,Scalability: Docker makes it easy to scale your application by running multiple containers across different machines or cloud instances.
Title,"Portability: Containers can be easily moved between environments, making it simple to deploy your application on different platforms."
Title,
Title,"To install Docker, follow the instructions on the official website. Once Docker is installed, you can create a Dockerfile in your NestJS project to define the steps for building your container image."
Title,The Dockerfile is a text file that contains the instructions Docker uses to build your container image.
Title,Here's a sample Dockerfile for a NestJS application:
Title,```bash
Title,Use the official Node.js image as the base image
Title,FROM node:20
Title,Set the working directory inside the container
Title,WORKDIR /usr/src/app
Title,Copy package.json and package-lock.json to the working directory
Title,COPY package*.json ./
Title,Install the application dependencies
Title,RUN npm install
Title,Copy the rest of the application files
Title,COPY . .
Title,Build the NestJS application
Title,RUN npm run build
Title,Expose the application port
Title,EXPOSE 3000
Title,Command to run the application
Title,"CMD [""node"", ""dist/main""]"
Title,```
Title,
Title,info Hint Make sure to replace node:20 with the appropriate Node.js version you're using in your project. You can find the available Node.js Docker images on the official Docker Hub repository.
Title,
Title,"This is a basic Dockerfile that sets up a Node.js environment, installs the application dependencies, builds the NestJS application, and runs it. You can customize this file based on your project requirements (e.g., use different base images, optimize the build process, only install production dependencies, etc.)."
Title,Let's also create a .dockerignore file to specify which files and directories Docker should ignore when building the image. Create a .dockerignore file in your project root:
Title,bash
Title,node_modules
Title,dist
Title,*.log
Title,*.md
Title,.git
Title,"This file ensures that unnecessary files are not included in the container image, keeping it lightweight. Now that you have your Dockerfile set up, you can build your Docker image. Open your terminal, navigate to your project directory, and run the following command:"
Title,bash
Title,docker build -t my-nestjs-app .
Title,In this command:
Title,
Title,-t my-nestjs-app: Tags the image with the name my-nestjs-app.
Title,.: Indicates the current directory as the build context.
Title,
Title,"After building the image, you can run it as a container. Execute the following command:"
Title,bash
Title,docker run -p 3000:3000 my-nestjs-app
Title,In this command:
Title,
Title,-p 3000:3000: Maps port 3000 on your host machine to port 3000 in the container.
Title,my-nestjs-app: Specifies the image to run.
Title,
Title,Your NestJS application should now be running inside a Docker container.
Title,"If you want to deploy your Docker image to a cloud provider or share it with others, you'll need to push it to a Docker registry (like Docker Hub, AWS ECR, or Google Container Registry)."
Title,"Once you decide on a registry, you can push your image by following these steps:"
Title,bash
Title,docker login # Log in to your Docker registry
Title,docker tag my-nestjs-app your-dockerhub-username/my-nestjs-app # Tag your image
Title,docker push your-dockerhub-username/my-nestjs-app # Push your image
Title,"Replace your-dockerhub-username with your Docker Hub username or the appropriate registry URL. After pushing your image, you can pull it on any machine and run it as a container."
Title,"Cloud providers like AWS, Azure, and Google Cloud offer managed container services that simplify deploying and managing containers at scale. These services provide features like auto-scaling, load balancing, and monitoring, making it easier to run your NestJS application in production."
Title,Easy deployment with Mau
Title,"Mau is our official platform for deploying NestJS applications on AWS. If you're not ready to manage your infrastructure manually (or just want to save time), Mau is the perfect solution for you."
Title,"With Mau, provisioning and maintaining your infrastructure is as simple as clicking just a few buttons. Mau is designed to be simple and intuitive, so you can focus on building your applications and not worry about the underlying infrastructure. Under the hood, we use Amazon Web Services to provide you with a powerful and reliable platform, while abstracting away all the complexity of AWS. We take care of all the heavy lifting for you, so you can focus on building your applications and growing your business."
Title,"Mau is perfect for startups, small-to-medium businesses, large enterprises, and developers who want to get up and running quickly without having to spend a lot of time on learning and managing infrastructure. It's incredibly easy to use, and you can have your infrastructure up and running in minutes. It also leverages AWS behind the scenes, giving you all the advantages of AWS without the hassle of managing its complexities."
Title,
Title,"With Mau, you can:"
Title,
Title,"Deploy your NestJS applications with just a few clicks (APIs, microservices, etc.)."
Title,Provision databases such as:
Title,PostgreSQL
Title,MySQL
Title,MongoDB (DocumentDB)
Title,Redis
Title,more
Title,Set up broker services like:
Title,RabbitMQ
Title,Kafka
Title,NATS
Title,Deploy scheduled tasks (CRON jobs) and background workers.
Title,Deploy lambda functions and serverless applications.
Title,Setup CI/CD pipelines for automated deployments.
Title,And much more!
Title,
Title,"To deploy your NestJS application with Mau, just run the following command:"
Title,bash
Title,$ npm install -g @nestjs/mau
Title,$ mau deploy
Title,Sign up today and Deploy with Mau to get your NestJS applications up and running on AWS in minutes!
Title,
Title,CI/CD integration
Title,
Title,"info Hint This chapter covers the Nest Devtools integration with the Nest framework. If you are looking for the Devtools application, please visit the Devtools website."
Title,
Title,CI/CD integration is available for users with the Enterprise plan.
Title,You can watch this video to learn why & how CI/CD integration can help you:
Title,
Title,
Title,
Title,Publishing graphs
Title,"Let's first configure the application bootstrap file (main.ts) to use the GraphPublisher class (exported from the @nestjs/devtools-integration - see previous chapter for more details), as follows:"
Title,```typescript
Title,async function bootstrap() {
Title,"const shouldPublishGraph = process.env.PUBLISH_GRAPH === ""true"";"
Title,"const app = await NestFactory.create(AppModule, {"
Title,"snapshot: true,"
Title,"preview: shouldPublishGraph,"
Title,});
Title,if (shouldPublishGraph) {
Title,await app.init();
Title,const publishOptions = { ... } // NOTE: this options object will vary depending on the CI/CD provider you're using
Title,const graphPublisher = new GraphPublisher(app);
Title,await graphPublisher.publish(publishOptions);
Title,
Title,await app.close();
Title,
Title,} else {
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,}
Title,```
Title,"As we can see, we're using the GraphPublisher here to publish our serialized graph to the centralized registry. The PUBLISH_GRAPH is a custom environment variable that will let us control whether the graph should be published (CI/CD workflow), or not (regular application bootstrap). Also, we set the preview attribute here to true. With this flag enabled, our application will bootstrap in the preview mode - which basically means that constructors (and lifecycle hooks) of all controllers, enhancers, and providers in our application will not be executed. Note - this isn't required, but makes things simpler for us since in this case we won't really have to connect to the database etc. when running our application in the CI/CD pipeline."
Title,"The publishOptions object will vary depending on the CI/CD provider you're using. We will provide you with instructions for the most popular CI/CD providers below, in later sections."
Title,"Once the graph is successfully published, you'll see the following output in your workflow view:"
Title,
Title,"Every time our graph is published, we should see a new entry in the project's corresponding page:"
Title,
Title,Reports
Title,"Devtools generate a report for every build IF there's a corresponding snapshot already stored in the centralized registry. So for example, if you create a PR against the master branch for which the graph was already published - then the application will be able to detect differences and generate a report. Otherwise, the report will not be generated."
Title,"To see reports, navigate to the project's corresponding page (see organizations)."
Title,
Title,"This is particularly helpful in identifying changes that may have gone unnoticed during code reviews. For instance, let's say someone has changed the scope of a deeply nested provider. This change might not be immediately obvious to the reviewer, but with Devtools, we can easily spot such changes and make sure that they're intentional. Or if we remove a guard from a specific endpoint, it will show up as affected in the report. Now if we didn't have integration or e2e tests for that route, we might not notice that it's no longer protected, and by the time we do, it could be too late."
Title,"Similarly, if we're working on a large codebase and we modify a module to be global, we'll see how many edges were added to the graph, and this - in most cases - is a sign that we're doing something wrong."
Title,Build preview
Title,"For every published graph we can go back in time and preview how it looked before by clicking at the Preview button. Furthermore, if the report was generated, we should see the differences highlighted on our graph:"
Title,
Title,green nodes represent added elements
Title,light white nodes represent updated elements
Title,red nodes represent deleted elements
Title,
Title,See screenshot below:
Title,
Title,"The ability to go back in time lets you investigate and troubleshoot the issue by comparing the current graph with the previous one. Depending on how you set things up, every pull request (or even every commit) will have a corresponding snapshot in the registry, so you can easily go back in time and see what changed. Think of Devtools as a Git but with an understanding of how Nest constructs your application graph, and with the ability to visualize it."
Title,Integrations: GitHub Actions
Title,"First let's start from creating a new GitHub workflow in the .github/workflows directory in our project and call it, for example, publish-graph.yml. Inside this file, let's use the following definition:"
Title,```yaml
Title,name: Devtools
Title,on:
Title,push:
Title,branches:
Title,- master
Title,pull_request:
Title,branches:
Title,- '*'
Title,jobs:
Title,publish:
Title,if: github.actor!= 'dependabot[bot]'
Title,name: Publish graph
Title,runs-on: ubuntu-latest
Title,steps:
Title,- uses: actions/checkout@v3
Title,- uses: actions/setup-node@v3
Title,with:
Title,node-version: '16'
Title,cache: 'npm'
Title,- name: Install dependencies
Title,run: npm ci
Title,- name: Setup Environment (PR)
Title,if: {{ '${{' }} github.event_name == 'pull_request' {{ '}}' }}
Title,shell: bash
Title,run: |
Title,"echo ""COMMIT_SHA={{ '${{' }} github.event.pull_request.head.sha {{ '}}' }}"" >>\${GITHUB_ENV}"
Title,- name: Setup Environment (Push)
Title,if: {{ '${{' }} github.event_name == 'push' {{ '}}' }}
Title,shell: bash
Title,run: |
Title,"echo ""COMMIT_SHA=\${GITHUB_SHA}"" >> \${GITHUB_ENV}"
Title,- name: Publish
Title,run: PUBLISH_GRAPH=true npm run start
Title,env:
Title,DEVTOOLS_API_KEY: CHANGE_THIS_TO_YOUR_API_KEY
Title,REPOSITORY_NAME: {{ '${{' }} github.event.repository.name {{ '}}' }}
Title,BRANCH_NAME: {{ '${{' }} github.head_ref || github.ref_name {{ '}}' }}
Title,TARGET_SHA: {{ '${{' }} github.event.pull_request.base.sha {{ '}}' }}
Title,```
Title,"Ideally, DEVTOOLS_API_KEY environment variable should be retrieved from GitHub Secrets, read more here ."
Title,This workflow will run per each pull request that's targeting the master branch OR in case there's a direct commit to the master branch. Feel free to align this configuration to whatever your project needs. What's essential here is that we provide necessary environment variables for our GraphPublisher class (to run).
Title,"However, there's one variable that needs to be updated before we can start using this workflow - DEVTOOLS_API_KEY. We can generate an API key dedicated for our project on this page."
Title,"Lastly, let's navigate to the main.ts file again and update the publishOptions object we previously left empty."
Title,typescript
Title,const publishOptions = {
Title,"apiKey: process.env.DEVTOOLS_API_KEY,"
Title,"repository: process.env.REPOSITORY_NAME,"
Title,"owner: process.env.GITHUB_REPOSITORY_OWNER,"
Title,"sha: process.env.COMMIT_SHA,"
Title,"target: process.env.TARGET_SHA,"
Title,"trigger: process.env.GITHUB_BASE_REF ? 'pull' : 'push',"
Title,"branch: process.env.BRANCH_NAME,"
Title,};
Title,"For the best developer experience, make sure to integrate the GitHub application for your project by clicking on the ""Integrate GitHub app"" button (see screenshot below). Note - this isn't required."
Title,
Title,"With this integration, you'll be able to see the status of the preview/report generation process right in your pull request:"
Title,
Title,Integrations: Gitlab Pipelines
Title,"First let's start from creating a new Gitlab CI configuration file in the root directory of our project and call it, for example, .gitlab-ci.yml. Inside this file, let's use the following definition:"
Title,typescript
Title,const publishOptions = {
Title,"apiKey: process.env.DEVTOOLS_API_KEY,"
Title,"repository: process.env.REPOSITORY_NAME,"
Title,"owner: process.env.GITHUB_REPOSITORY_OWNER,"
Title,"sha: process.env.COMMIT_SHA,"
Title,"target: process.env.TARGET_SHA,"
Title,"trigger: process.env.GITHUB_BASE_REF ? 'pull' : 'push',"
Title,"branch: process.env.BRANCH_NAME,"
Title,};
Title,
Title,"info Hint Ideally, DEVTOOLS_API_KEY environment variable should be retrieved from secrets."
Title,
Title,This workflow will run per each pull request that's targeting the master branch OR in case there's a direct commit to the master branch. Feel free to align this configuration to whatever your project needs. What's essential here is that we provide necessary environment variables for our GraphPublisher class (to run).
Title,"However, there's one variable (in this workflow definition) that needs to be updated before we can start using this workflow - DEVTOOLS_API_KEY. We can generate an API key dedicated for our project on this page ."
Title,"Lastly, let's navigate to the main.ts file again and update the publishOptions object we previously left empty."
Title,```yaml
Title,image: node:16
Title,stages:
Title,- build
Title,cache:
Title,key:
Title,files:
Title,- package-lock.json
Title,paths:
Title,- node_modules/
Title,workflow:
Title,rules:
Title,"- if: $CI_PIPELINE_SOURCE == ""merge_request_event"""
Title,when: always
Title,"- if: $CI_COMMIT_BRANCH == ""master"" && $CI_PIPELINE_SOURCE == ""push"""
Title,when: always
Title,- when: never
Title,install_dependencies:
Title,stage: build
Title,script:
Title,- npm ci
Title,publish_graph:
Title,stage: build
Title,needs:
Title,- install_dependencies
Title,script: npm run start
Title,variables:
Title,PUBLISH_GRAPH: 'true'
Title,DEVTOOLS_API_KEY: 'CHANGE_THIS_TO_YOUR_API_KEY'
Title,```
Title,Other CI/CD tools
Title,"Nest Devtools CI/CD integration can be used with any CI/CD tool of your choice (e.g., Bitbucket Pipelines , CircleCI, etc) so don't feel limited to providers we described here."
Title,Look at the following publishOptions object configuration to understand what information is required to publish the graph for a given commit/build/PR.
Title,typescript
Title,const publishOptions = {
Title,"apiKey: process.env.DEVTOOLS_API_KEY,"
Title,"repository: process.env.CI_PROJECT_NAME,"
Title,"owner: process.env.CI_PROJECT_ROOT_NAMESPACE,"
Title,"sha: process.env.CI_COMMIT_SHA,"
Title,"target: process.env.CI_MERGE_REQUEST_DIFF_BASE_SHA,"
Title,"trigger: process.env.CI_MERGE_REQUEST_DIFF_BASE_SHA ? 'pull' : 'push',"
Title,"branch: process.env.CI_COMMIT_BRANCH ?? process.env.CI_MERGE_REQUEST_SOURCE_BRANCH_NAME,"
Title,};
Title,Most of this information is provided through CI/CD built-in environment variables (see CircleCI built-in environment list and Bitbucket variables ).
Title,"When it comes to the pipeline configuration for publishing graphs, we recommend using the following triggers:"
Title,
Title,"push event - only if the current branch represents a deployment environment, for example master, main, staging, production, etc."
Title,"pull request event - always, or when the target branch represents a deployment environment (see above)"
Title,
Title,
Title,Overview
Title,
Title,"info Hint This chapter covers the Nest Devtools integration with the Nest framework. If you are looking for the Devtools application, please visit the Devtools website."
Title,
Title,"To start debugging your local application, open up the main.ts file and make sure to set the snapshot attribute to true in the application options object, as follows:"
Title,typescript
Title,async function bootstrap() {
Title,"const app = await NestFactory.create(AppModule, {"
Title,"snapshot: true,"
Title,});
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,This will instruct the framework to collect necessary metadata that will let Nest Devtools visualize your application's graph.
Title,"Next up, let's install the required dependency:"
Title,bash
Title,$ npm i @nestjs/devtools-integration
Title,
Title,"warning Warning If you're using @nestjs/graphql package in your application, make sure to install the latest version (npm i @nestjs/graphql@11)."
Title,
Title,"With this dependency in place, let's open up the app.module.ts file and import the DevtoolsModule that we just installed:"
Title,typescript
Title,@Module({
Title,imports: [
Title,DevtoolsModule.register({
Title,"http: process.env.NODE_ENV !== 'production',"
Title,"}),"
Title,"],"
Title,"controllers: [AppController],"
Title,"providers: [AppService],"
Title,})
Title,export class AppModule {}
Title,
Title,warning Warning The reason we are checking the NODE_ENV environment variable here is that you should never use this module in production!
Title,
Title,"Once the DevtoolsModule is imported and your application is up and running (npm run start:dev), you should be able to navigate to Devtools URL and see the instrospected graph."
Title,
Title,
Title,"info Hint As you can see on the screenshot above, every module connects to the InternalCoreModule. InternalCoreModule is a global module that is always imported into the root module. Since it's registered as a global node, Nest automatically creates edges between all of the modules and the InternalCoreModule node. Now, if you want to hide global modules from the graph, you can use the ""Hide global modules"" checkbox (in the sidebar)."
Title,
Title,"So as we can see, DevtoolsModule makes your application expose an additional HTTP server (on port 8000) that the Devtools application will use to introspect your app."
Title,"Just to double-check that everything works as expected, change the graph view to ""Classes"". You should see the following screen:"
Title,
Title,"To focus on a specific node, click on the rectangle and the graph will show a popup window with the ""Focus"" button. You can also use the search bar (located in the sidebar) to find a specific node."
Title,
Title,"info Hint If you click on the Inspect button, application will take you to the /debug page with that specific node selected."
Title,
Title,
Title,
Title,"info Hint To export a graph as an image, click on the Export as PNG button in the right corner of the graph."
Title,
Title,"Using the form controls located in the sidebar (on the left), you can control edges proximity to, for example, visualize a specific application sub-tree:"
Title,
Title,"This can be particularly useful when you have new developers on your team and you want to show them how your application is structured. You can also use this feature to visualize a specific module (e.g. TasksModule) and all of its dependencies, which can come in handy when you're breaking down a large application into smaller modules (for example, individual micro-services)."
Title,You can watch this video to see the Graph Explorer feature in action:
Title,
Title,
Title,
Title,"Investigating the ""Cannot resolve dependency"" error"
Title,
Title,info Note This feature is supported for @nestjs/core >= v9.3.10.
Title,
Title,"Probably the most common error message you might have seen is about Nest not being able to resolve dependencies of a provider. Using Nest Devtools, you can effortlessly identify the issue and learn how to resolve it."
Title,"First, open up the main.ts file and update the bootstrap() call, as follows:"
Title,typescript
Title,bootstrap().catch((err) => {
Title,"fs.writeFileSync('graph.json', PartialGraphHost.toString() ?? '');"
Title,process.exit(1);
Title,});
Title,"Also, make sure to set the abortOnError to false:"
Title,typescript
Title,"const app = await NestFactory.create(AppModule, {"
Title,"snapshot: true,"
Title,"abortOnError: false, // <--- THIS"
Title,});
Title,"Now every time your application fails to bootstrap due to the ""Cannot resolve dependency"" error, you'll find the graph.json (that represents a partial graph) file in the root directory. You can then drag & drop this file into Devtools (make sure to switch the current mode from ""Interactive"" to ""Preview""):"
Title,
Title,"Upon successful upload, you should see the following graph & dialog window:"
Title,
Title,"As you can see, the highlighted TasksModule is the one we should look into. Also, in the dialog window you can already see some instructions on how to fix this issue."
Title,"If we switch to the ""Classes"" view instead, that's what we'll see:"
Title,
Title,"This graph illustrates that the DiagnosticsService which we want to inject into the TasksService was not found in the context of the TasksModule module, and we should likely just import the DiagnosticsModule into the TasksModule module to fix this up!"
Title,Routes explorer
Title,"When you navigate to the Routes explorer page, you should see all of the registered entrypoints:"
Title,
Title,
Title,"info Hint This page shows not only HTTP routes, but also all of the other entrypoints (e.g. WebSockets, gRPC, GraphQL resolvers etc.)."
Title,
Title,Entrypoints are grouped by their host controllers. You can also use the search bar to find a specific entrypoint.
Title,"If you click on a specific entrypoint, a flow graph will be displayed. This graph shows the execution flow of the entrypoint (e.g. guards, interceptors, pipes, etc. bound to this route). This is particularly useful when you want to understand how the request/response cycle looks for a specific route, or when troubleshooting why a specific guard/interceptor/pipe is not being executed."
Title,Sandbox
Title,"To execute JavaScript code on the fly & interact with your application in real-time, navigate to the Sandbox page:"
Title,
Title,"The playground can be used to test and debug API endpoints in real-time, allowing developers to quickly identify and fix issues without using, for example, an HTTP client. We can also bypass the authentication layer, and so we no longer need that extra step of logging in, or even a special user account for testing purposes. For event-driven applications, we can also trigger events directly from the playground, and see how the application reacts to them."
Title,"Anything that gets logged down is streamlined to the playground's console, so we can easily see what's going on."
Title,"Just execute the code on the fly and see the results instantly, without having to rebuild the application and restart the server."
Title,
Title,
Title,"info Hint To pretty display an array of objects, use the console.table() (or just table()) function."
Title,
Title,You can watch this video to see the Interactive Playground feature in action:
Title,
Title,
Title,
Title,Bootstrap performance analyzer
Title,"To see a list of all class nodes (controllers, providers, enhancers, etc.) and their corresponding instantiation times, navigate to the Bootstrap performance page:"
Title,
Title,"This page is particularly useful when you want to identify the slowest parts of your application's bootstrap process (e.g. when you want to optimize the application's startup time which is crucial for, for example, serverless environments)."
Title,Audit
Title,"To see the auto-generated audit - errors/warnings/hints that the application came up with while analyzing your serialized graph, navigate to the Audit page:"
Title,
Title,
Title,info Hint The screenshot above doesn't show all of the available audit rules.
Title,
Title,This page comes in handy when you want to identify potential issues in your application.
Title,Preview static files
Title,"To save a serialized graph to a file, use the following code:"
Title,typescript
Title,await app.listen(process.env.PORT ?? 3000); // OR await app.init()
Title,"fs.writeFileSync('./graph.json', app.get(SerializedGraph).toString());"
Title,
Title,info Hint SerializedGraph is exported from the @nestjs/core package.
Title,
Title,Then you can drag and drop/upload this file:
Title,
Title,"This is helpful when you want to share your graph with someone else (e.g., co-worker), or when you want to analyze it offline."
Title,
Title,Who is using Nest?
Title,We are proudly helping various companies building their products at scale.
Title,"If you are using Nest and would you like to be listed here, see this thread."
Title,We are willing to put your logo here!
Title,Companies
Title,"According to our knowledge, all the following companies have built awesome projects on top of our framework:"
Title,
Title,Official NestJS Consulting
Title,Our goal is to ensure that your developers are successful and productive with NestJS as well as other modern technologies in today's ever-changing tech world.
Title,Official Support
Title,"With official support, get expert help directly from the NestJS core team. We tackle your toughest challenges, and collaborate with your team on many levels such as:"
Title,
Title,Providing technical guidance & architectural reviews
Title,Mentoring team members
Title,Advising best practices
Title,Solving design decisions
Title,Addressing security & performance concerns
Title,Performing in-depth code reviews
Title,
Title,
Title,
Title,Team Augmentation & Development
Title,
Title,"With team augmentation, NestJS core team members can work directly with your team on a daily basis to help take your project to the next-level. Consider us “part of your team”, tackling the most ambitious projects - right by your side."
Title,
Title,
Title,
Title,
Title,
Title,
Title,
Title,
Title,
Title,
Title,
Title,NestJS Best Practices
Title,
Title,"Frequent code reviews can eliminate potentially hazardous bugs & issues at an early stage and help enforce best practices. Let us perform PR reviews & audits to ensure your code quality, performance, and security."
Title,
Title,
Title,
Title,First-hand access
Title,"Direct communication channel will boost team velocity, giving a quick access to discuss and solve problems."
Title,NestJS Workshops and Trainings
Title,We provide solid kick-off training as well as more advanced ones that give teams an in-depth understanding of NestJS. We offer on-site workshops and remote intensive sessions which help get you up and running quickly within the NestJS ecosystem.
Title,
Title,
Title,Contact us!
Title,
Title,Let's talk how we can help you become successful with NestJS.
Title,
Title,
Title,
Title,CONTACT US
Title,
Title,
Title,"Reach out to us at support@nestjs.com, and let’s talk about your project & teams needs!"
Title,
Title,Exception filters
Title,"Nest comes with a built-in exceptions layer which is responsible for processing all unhandled exceptions across an application. When an exception is not handled by your application code, it is caught by this layer, which then automatically sends an appropriate user-friendly response."
Title,
Title,
Title,
Title,"Out of the box, this action is performed by a built-in global exception filter, which handles exceptions of type HttpException (and subclasses of it). When an exception is unrecognized (is neither HttpException nor a class that inherits from HttpException), the built-in exception filter generates the following default JSON response:"
Title,json
Title,{
Title,"""statusCode"": 500,"
Title,"""message"": ""Internal server error"""
Title,}
Title,
Title,"info Hint The global exception filter partially supports the http-errors library. Basically, any thrown exception containing the statusCode and message properties will be properly populated and sent back as a response (instead of the default InternalServerErrorException for unrecognized exceptions)."
Title,
Title,Throwing standard exceptions
Title,"Nest provides a built-in HttpException class, exposed from the @nestjs/common package. For typical HTTP REST/GraphQL API based applications, it's best practice to send standard HTTP response objects when certain error conditions occur."
Title,"For example, in the CatsController, we have a findAll() method (a GET route handler). Let's assume that this route handler throws an exception for some reason. To demonstrate this, we'll hard-code it as follows:"
Title,typescript
Title,@@filename(cats.controller)
Title,@Get()
Title,async findAll() {
Title,"throw new HttpException('Forbidden', HttpStatus.FORBIDDEN);"
Title,}
Title,
Title,info Hint We used the HttpStatus here. This is a helper enum imported from the @nestjs/common package.
Title,
Title,"When the client calls this endpoint, the response looks like this:"
Title,json
Title,{
Title,"""statusCode"": 403,"
Title,"""message"": ""Forbidden"""
Title,}
Title,The HttpException constructor takes two required arguments which determine the
Title,response:
Title,
Title,The response argument defines the JSON response body. It can be a string
Title,or an object as described below.
Title,The status argument defines the HTTP status code.
Title,
Title,"By default, the JSON response body contains two properties:"
Title,
Title,statusCode: defaults to the HTTP status code provided in the status argument
Title,message: a short description of the HTTP error based on the status
Title,
Title,"To override just the message portion of the JSON response body, supply a string"
Title,"in the response argument. To override the entire JSON response body, pass an object in the response argument. Nest will serialize the object and return it as the JSON response body."
Title,The second constructor argument - status - should be a valid HTTP status code.
Title,Best practice is to use the HttpStatus enum imported from @nestjs/common.
Title,"There is a third constructor argument (optional) - options - that can be used to provide an error cause. This cause object is not serialized into the response object, but it can be useful for logging purposes, providing valuable information about the inner error that caused the HttpException to be thrown."
Title,Here's an example overriding the entire response body and providing an error cause:
Title,typescript
Title,@@filename(cats.controller)
Title,@Get()
Title,async findAll() {
Title,try {
Title,await this.service.findAll()
Title,} catch (error) {
Title,throw new HttpException({
Title,"status: HttpStatus.FORBIDDEN,"
Title,"error: 'This is a custom message',"
Title,"}, HttpStatus.FORBIDDEN, {"
Title,cause: error
Title,});
Title,}
Title,}
Title,"Using the above, this is how the response would look:"
Title,json
Title,{
Title,"""status"": 403,"
Title,"""error"": ""This is a custom message"""
Title,}
Title,Custom exceptions
Title,"In many cases, you will not need to write custom exceptions, and can use the built-in Nest HTTP exception, as described in the next section. If you do need to create customized exceptions, it's good practice to create your own exceptions hierarchy, where your custom exceptions inherit from the base HttpException class. With this approach, Nest will recognize your exceptions, and automatically take care of the error responses. Let's implement such a custom exception:"
Title,typescript
Title,@@filename(forbidden.exception)
Title,export class ForbiddenException extends HttpException {
Title,constructor() {
Title,"super('Forbidden', HttpStatus.FORBIDDEN);"
Title,}
Title,}
Title,"Since ForbiddenException extends the base HttpException, it will work seamlessly with the built-in exception handler, and therefore we can use it inside the findAll() method."
Title,typescript
Title,@@filename(cats.controller)
Title,@Get()
Title,async findAll() {
Title,throw new ForbiddenException();
Title,}
Title,Built-in HTTP exceptions
Title,"Nest provides a set of standard exceptions that inherit from the base HttpException. These are exposed from the @nestjs/common package, and represent many of the most common HTTP exceptions:"
Title,
Title,BadRequestException
Title,UnauthorizedException
Title,NotFoundException
Title,ForbiddenException
Title,NotAcceptableException
Title,RequestTimeoutException
Title,ConflictException
Title,GoneException
Title,HttpVersionNotSupportedException
Title,PayloadTooLargeException
Title,UnsupportedMediaTypeException
Title,UnprocessableEntityException
Title,InternalServerErrorException
Title,NotImplementedException
Title,ImATeapotException
Title,MethodNotAllowedException
Title,BadGatewayException
Title,ServiceUnavailableException
Title,GatewayTimeoutException
Title,PreconditionFailedException
Title,
Title,All the built-in exceptions can also provide both an error cause and an error description using the options parameter:
Title,typescript
Title,"throw new BadRequestException('Something bad happened', {"
Title,"cause: new Error(),"
Title,"description: 'Some error description',"
Title,});
Title,"Using the above, this is how the response would look:"
Title,json
Title,{
Title,"""message"": ""Something bad happened"","
Title,"""error"": ""Some error description"","
Title,"""statusCode"": 400"
Title,}
Title,Exception filters
Title,"While the base (built-in) exception filter can automatically handle many cases for you, you may want full control over the exceptions layer. For example, you may want to add logging or use a different JSON schema based on some dynamic factors. Exception filters are designed for exactly this purpose. They let you control the exact flow of control and the content of the response sent back to the client."
Title,"Let's create an exception filter that is responsible for catching exceptions which are an instance of the HttpException class, and implementing custom response logic for them. To do this, we'll need to access the underlying platform Request and Response objects. We'll access the Request object so we can pull out the original url and include that in the logging information. We'll use the Response object to take direct control of the response that is sent, using the response.json() method."
Title,```typescript
Title,@@filename(http-exception.filter)
Title,"import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';"
Title,"import { Request, Response } from 'express';"
Title,@Catch(HttpException)
Title,export class HttpExceptionFilter implements ExceptionFilter {
Title,"catch(exception: HttpException, host: ArgumentsHost) {"
Title,const ctx = host.switchToHttp();
Title,const response = ctx.getResponse();
Title,const request = ctx.getRequest();
Title,const status = exception.getStatus();
Title,response
Title,.status(status)
Title,.json({
Title,"statusCode: status,"
Title,"timestamp: new Date().toISOString(),"
Title,"path: request.url,"
Title,});
Title,
Title,}
Title,}
Title,@@switch
Title,"import { Catch, HttpException } from '@nestjs/common';"
Title,@Catch(HttpException)
Title,export class HttpExceptionFilter {
Title,"catch(exception, host) {"
Title,const ctx = host.switchToHttp();
Title,const response = ctx.getResponse();
Title,const request = ctx.getRequest();
Title,const status = exception.getStatus();
Title,response
Title,.status(status)
Title,.json({
Title,"statusCode: status,"
Title,"timestamp: new Date().toISOString(),"
Title,"path: request.url,"
Title,});
Title,
Title,}
Title,}
Title,```
Title,
Title,"info Hint All exception filters should implement the generic ExceptionFilter<T> interface. This requires you to provide the catch(exception: T, host: ArgumentsHost) method with its indicated signature. T indicates the type of the exception."
Title,warning Warning If you are using @nestjs/platform-fastify you can use response.send() instead of response.json(). Don't forget to import the correct types from fastify.
Title,
Title,"The @Catch(HttpException) decorator binds the required metadata to the exception filter, telling Nest that this particular filter is looking for exceptions of type HttpException and nothing else. The @Catch() decorator may take a single parameter, or a comma-separated list. This lets you set up the filter for several types of exceptions at once."
Title,Arguments host
Title,"Let's look at the parameters of the catch() method. The exception parameter is the exception object currently being processed. The host parameter is an ArgumentsHost object. ArgumentsHost is a powerful utility object that we'll examine further in the execution context chapter*. In this code sample, we use it to obtain a reference to the Request and Response objects that are being passed to the original request handler (in the controller where the exception originates). In this code sample, we've used some helper methods on ArgumentsHost to get the desired Request and Response objects. Learn more about ArgumentsHost here."
Title,"*The reason for this level of abstraction is that ArgumentsHost functions in all contexts (e.g., the HTTP server context we're working with now, but also Microservices and WebSockets). In the execution context chapter we'll see how we can access the appropriate underlying arguments for any execution context with the power of ArgumentsHost and its helper functions. This will allow us to write generic exception filters that operate across all contexts."
Title,
Title,Binding filters
Title,Let's tie our new HttpExceptionFilter to the CatsController's create() method.
Title,typescript
Title,@@filename(cats.controller)
Title,@Post()
Title,@UseFilters(new HttpExceptionFilter())
Title,async create(@Body() createCatDto: CreateCatDto) {
Title,throw new ForbiddenException();
Title,}
Title,@@switch
Title,@Post()
Title,@UseFilters(new HttpExceptionFilter())
Title,@Bind(Body())
Title,async create(createCatDto) {
Title,throw new ForbiddenException();
Title,}
Title,
Title,info Hint The @UseFilters() decorator is imported from the @nestjs/common package.
Title,
Title,"We have used the @UseFilters() decorator here. Similar to the @Catch() decorator, it can take a single filter instance, or a comma-separated list of filter instances. Here, we created the instance of HttpExceptionFilter in place. Alternatively, you may pass the class (instead of an instance), leaving responsibility for instantiation to the framework, and enabling dependency injection."
Title,typescript
Title,@@filename(cats.controller)
Title,@Post()
Title,@UseFilters(HttpExceptionFilter)
Title,async create(@Body() createCatDto: CreateCatDto) {
Title,throw new ForbiddenException();
Title,}
Title,@@switch
Title,@Post()
Title,@UseFilters(HttpExceptionFilter)
Title,@Bind(Body())
Title,async create(createCatDto) {
Title,throw new ForbiddenException();
Title,}
Title,
Title,info Hint Prefer applying filters by using classes instead of instances when possible. It reduces memory usage since Nest can easily reuse instances of the same class across your entire module.
Title,
Title,"In the example above, the HttpExceptionFilter is applied only to the single create() route handler, making it method-scoped. Exception filters can be scoped at different levels: method-scoped of the controller/resolver/gateway, controller-scoped, or global-scoped."
Title,"For example, to set up a filter as controller-scoped, you would do the following:"
Title,typescript
Title,@@filename(cats.controller)
Title,@UseFilters(new HttpExceptionFilter())
Title,export class CatsController {}
Title,This construction sets up the HttpExceptionFilter for every route handler defined inside the CatsController.
Title,"To create a global-scoped filter, you would do the following:"
Title,typescript
Title,@@filename(main)
Title,async function bootstrap() {
Title,const app = await NestFactory.create(AppModule);
Title,app.useGlobalFilters(new HttpExceptionFilter());
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,bootstrap();
Title,
Title,warning Warning The useGlobalFilters() method does not set up filters for gateways or hybrid applications.
Title,
Title,"Global-scoped filters are used across the whole application, for every controller and every route handler. In terms of dependency injection, global filters registered from outside of any module (with useGlobalFilters() as in the example above) cannot inject dependencies since this is done outside the context of any module. In order to solve this issue, you can register a global-scoped filter directly from any module using the following construction:"
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { APP_FILTER } from '@nestjs/core';
Title,@Module({
Title,providers: [
Title,{
Title,"provide: APP_FILTER,"
Title,"useClass: HttpExceptionFilter,"
Title,"},"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,
Title,"info Hint When using this approach to perform dependency injection for the filter, note that regardless of the module where this construction is employed, the filter is, in fact, global. Where should this be done? Choose the module where the filter (HttpExceptionFilter in the example above) is defined. Also, useClass is not the only way of dealing with custom provider registration. Learn more here."
Title,
Title,You can add as many filters with this technique as needed; simply add each to the providers array.
Title,Catch everything
Title,"In order to catch every unhandled exception (regardless of the exception type), leave the @Catch() decorator's parameter list empty, e.g., @Catch()."
Title,"In the example below we have a code that is platform-agnostic because it uses the HTTP adapter to deliver the response, and doesn't use any of the platform-specific objects (Request and Response) directly:"
Title,```typescript
Title,import {
Title,"ExceptionFilter,"
Title,"Catch,"
Title,"ArgumentsHost,"
Title,"HttpException,"
Title,"HttpStatus,"
Title,} from '@nestjs/common';
Title,import { HttpAdapterHost } from '@nestjs/core';
Title,@Catch()
Title,export class CatchEverythingFilter implements ExceptionFilter {
Title,constructor(private readonly httpAdapterHost: HttpAdapterHost) {}
Title,"catch(exception: unknown, host: ArgumentsHost): void {"
Title,// In certain situations httpAdapter might not be available in the
Title,"// constructor method, thus we should resolve it here."
Title,const { httpAdapter } = this.httpAdapterHost;
Title,const ctx = host.switchToHttp();
Title,
Title,const httpStatus =
Title,exception instanceof HttpException
Title,? exception.getStatus()
Title,: HttpStatus.INTERNAL_SERVER_ERROR;
Title,
Title,const responseBody = {
Title,"statusCode: httpStatus,"
Title,"timestamp: new Date().toISOString(),"
Title,"path: httpAdapter.getRequestUrl(ctx.getRequest()),"
Title,};
Title,
Title,"httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus);"
Title,
Title,}
Title,}
Title,```
Title,
Title,"warning Warning When combining an exception filter that catches everything with a filter that is bound to a specific type, the ""Catch anything"" filter should be declared first to allow the specific filter to correctly handle the bound type."
Title,
Title,Inheritance
Title,"Typically, you'll create fully customized exception filters crafted to fulfill your application requirements. However, there might be use-cases when you would like to simply extend the built-in default global exception filter, and override the behavior based on certain factors."
Title,"In order to delegate exception processing to the base filter, you need to extend BaseExceptionFilter and call the inherited catch() method."
Title,```typescript
Title,@@filename(all-exceptions.filter)
Title,"import { Catch, ArgumentsHost } from '@nestjs/common';"
Title,import { BaseExceptionFilter } from '@nestjs/core';
Title,@Catch()
Title,export class AllExceptionsFilter extends BaseExceptionFilter {
Title,"catch(exception: unknown, host: ArgumentsHost) {"
Title,"super.catch(exception, host);"
Title,}
Title,}
Title,@@switch
Title,import { Catch } from '@nestjs/common';
Title,import { BaseExceptionFilter } from '@nestjs/core';
Title,@Catch()
Title,export class AllExceptionsFilter extends BaseExceptionFilter {
Title,"catch(exception, host) {"
Title,"super.catch(exception, host);"
Title,}
Title,}
Title,```
Title,
Title,"warning Warning Method-scoped and Controller-scoped filters that extend the BaseExceptionFilter should not be instantiated with new. Instead, let the framework instantiate them automatically."
Title,
Title,Global filters can extend the base filter. This can be done in either of two ways.
Title,The first method is to inject the HttpAdapter reference when instantiating the custom global filter:
Title,```typescript
Title,async function bootstrap() {
Title,const app = await NestFactory.create(AppModule);
Title,const { httpAdapter } = app.get(HttpAdapterHost);
Title,app.useGlobalFilters(new AllExceptionsFilter(httpAdapter));
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,bootstrap();
Title,```
Title,The second method is to use the APP_FILTER token as shown here.
Title,
Title,Common errors
Title,"During your development with NestJS, you may encounter various errors as you learn the framework."
Title,"""Cannot resolve dependency"" error"
Title,
Title,"info Hint Check out the NestJS Devtools which can help you resolve the ""Cannot resolve dependency"" error effortlessly."
Title,
Title,Probably the most common error message is about Nest not being able to resolve dependencies of a provider. The error message usually looks something like this:
Title,```bash
Title,Nest can't resolve dependencies of the  (?). Please make sure that the argument  at index [] is available in the  context.
Title,Potential solutions:
Title,- Is  a valid NestJS module?
Title,"- If  is a provider, is it part of the current ?"
Title,"- If  is exported from a separate @Module, is that module imported within ?"
Title,@Module({
Title,imports: [ / the Module containing  / ]
Title,})
Title,```
Title,"The most common culprit of the error, is not having the <provider> in the module's providers array. Please make sure that the provider is indeed in the providers array and following standard NestJS provider practices."
Title,"There are a few gotchas, that are common. One is putting a provider in an imports array. If this is the case, the error will have the provider's name where <module> should be."
Title,"If you run across this error while developing, take a look at the module mentioned in the error message and look at its providers. For each provider in the providers array, make sure the module has access to all of the dependencies. Often times, providers are duplicated in a ""Feature Module"" and a ""Root Module"" which means Nest will try to instantiate the provider twice. More than likely, the module containing the <provider> being duplicated should be added in the ""Root Module""'s imports array instead."
Title,"If the <unknown_token> above is dependency, you might have a circular file import. This is different from the circular dependency below because instead of having providers depend on each other in their constructors, it just means that two files end up importing each other. A common case would be a module file declaring a token and importing a provider, and the provider import the token constant from the module file. If you are using barrel files, ensure that your barrel imports do not end up creating these circular imports as well."
Title,"If the <unknown_token> above is Object, it means that you're injecting using an type/interface without a proper provider's token. To fix that, make sure that:"
Title,
Title,"you're importing the class reference or use a custom token with @Inject() decorator. Read the custom providers page, and"
Title,"for class-based providers, you're importing the concrete classes instead of only the type via import type ... syntax."
Title,
Title,"Also, make sure you didn't end up injecting the provider on itself because self-injections are not allowed in NestJS. When this happens, <unknown_token> will likely be equal to <provider>."
Title,
Title,"If you are in a monorepo setup, you may face the same error as above but for core provider called ModuleRef as a <unknown_token>:"
Title,bash
Title,Nest can't resolve dependencies of the <provider> (?).
Title,Please make sure that the argument ModuleRef at index [<index>] is available in the <module> context.
Title,...
Title,"This likely happens when your project end up loading two Node modules of the package @nestjs/core, like this:"
Title,text
Title,.
Title,├── package.json
Title,├── apps
Title,│   └── api
Title,│       └── node_modules
Title,│           └── @nestjs/bull
Title,│               └── node_modules
Title,│                   └── @nestjs/core
Title,└── node_modules
Title,├── (other packages)
Title,└── @nestjs/core
Title,Solutions:
Title,
Title,"For Yarn Workspaces, use the nohoist feature to prevent hoisting the package @nestjs/core."
Title,"For pnpm Workspaces, set @nestjs/core as a peerDependencies in your other module and ""dependenciesMeta"": {{ '{' }}""other-module-name"": {{ '{' }}""injected"": true &#125;&#125; in the app package.json where the module is imported. see: dependenciesmetainjected"
Title,
Title,"""Circular dependency"" error"
Title,Occasionally you'll find it difficult to avoid circular dependencies in your application. You'll need to take some steps to help Nest resolve these. Errors that arise from circular dependencies look like this:
Title,```bash
Title,Nest cannot create the  instance.
Title,"The module at index [] of the  ""imports"" array is undefined."
Title,Potential causes:
Title,- A circular dependency between modules. Use forwardRef() to avoid it. Read more: https://docs.nestjs.com/fundamentals/circular-dependency
Title,"- The module at index [] is of type ""undefined"". Check your import statements and the type of the module."
Title,Scope []
Title,example chain AppModule -> FooModule
Title,```
Title,"Circular dependencies can arise from both providers depending on each other, or typescript files depending on each other for constants, such as exporting constants from a module file and importing them in a service file. In the latter case, it is advised to create a separate file for your constants. In the former case, please follow the guide on circular dependencies and make sure that both the modules and the providers are marked with forwardRef."
Title,Debugging dependency errors
Title,"Along with just manually verifying your dependencies are correct, as of Nest 8.1.0 you can set the NEST_DEBUG environment variable to a string that resolves as truthy, and get extra logging information while Nest is resolving all of the dependencies for the application."
Title,
Title,"In the above image, the string in yellow is the host class of the dependency being injected, the string in blue is the name of the injected dependency, or its injection token, and the string in purple is the module in which the dependency is being searched for. Using this, you can usually trace back the dependency resolution for what's happening and why you're getting dependency injection problems."
Title,"""File change detected"" loops endlessly"
Title,Windows users who are using TypeScript version 4.9 and up may encounter this problem.
Title,"This happens when you're trying to run your application in watch mode, e.g npm run start:dev and see an endless loop of the log messages:"
Title,bash
Title,XX:XX:XX AM - File change detected. Starting incremental compilation...
Title,XX:XX:XX AM - Found 0 errors. Watching for file changes.
Title,"When you're using the NestJS CLI to start your application in watch mode it is done by calling tsc --watch, and as of version 4.9 of TypeScript, a new strategy for detecting file changes is used which is likely to be the cause of this problem."
Title,"In order to fix this problem, you need to add a setting to your tsconfig.json file after the ""compilerOptions"" option as follows:"
Title,bash
Title,"""watchOptions"": {"
Title,"""watchFile"": ""fixedPollingInterval"""
Title,}
Title,"This tells TypeScript to use the polling method for checking for file changes instead of file system events (the new default method), which can cause issues on some machines."
Title,"You can read more about the ""watchFile"" option in TypeScript documentation."
Title,
Title,Global prefix
Title,"To set a prefix for every route registered in an HTTP application, use the setGlobalPrefix() method of the INestApplication instance."
Title,typescript
Title,const app = await NestFactory.create(AppModule);
Title,app.setGlobalPrefix('v1');
Title,You can exclude routes from the global prefix using the following construction:
Title,typescript
Title,"app.setGlobalPrefix('v1', {"
Title,"exclude: [{ path: 'health', method: RequestMethod.GET }],"
Title,});
Title,"Alternatively, you can specify route as a string (it will apply to every request method):"
Title,typescript
Title,"app.setGlobalPrefix('v1', { exclude: ['cats'] });"
Title,
Title,"info Hint The path property supports wildcard parameters using the path-to-regexp package. Note: this does not accept wildcard asterisks *. Instead, you must use parameters (e.g., (.*), :splat*)."
Title,
Title,
Title,HTTP adapter
Title,"Occasionally, you may want to access the underlying HTTP server, either within the Nest application context or from the outside."
Title,"Every native (platform-specific) HTTP server/library (e.g., Express and Fastify) instance is wrapped in an adapter. The adapter is registered as a globally available provider that can be retrieved from the application context, as well as injected into other providers."
Title,Outside application context strategy
Title,"To get a reference to the HttpAdapter from outside of the application context, call the getHttpAdapter() method."
Title,typescript
Title,@@filename()
Title,const app = await NestFactory.create(AppModule);
Title,const httpAdapter = app.getHttpAdapter();
Title,As injectable
Title,"To get a reference to the HttpAdapterHost from within the application context, inject it using the same technique as any other existing provider (e.g., using constructor injection)."
Title,typescript
Title,@@filename()
Title,export class CatsService {
Title,constructor(private adapterHost: HttpAdapterHost) {}
Title,}
Title,@@switch
Title,@Dependencies(HttpAdapterHost)
Title,export class CatsService {
Title,constructor(adapterHost) {
Title,this.adapterHost = adapterHost;
Title,}
Title,}
Title,
Title,info Hint The HttpAdapterHost is imported from the @nestjs/core package.
Title,
Title,"The HttpAdapterHost is not an actual HttpAdapter. To get the actual HttpAdapter instance, simply access the httpAdapter property."
Title,typescript
Title,const adapterHost = app.get(HttpAdapterHost);
Title,const httpAdapter = adapterHost.httpAdapter;
Title,The httpAdapter is the actual instance of the HTTP adapter used by the underlying framework. It is an instance of either ExpressAdapter or FastifyAdapter (both classes extend AbstractHttpAdapter).
Title,"The adapter object exposes several useful methods to interact with the HTTP server. However, if you want to access the library instance (e.g., the Express instance) directly, call the getInstance() method."
Title,typescript
Title,const instance = httpAdapter.getInstance();
Title,Listening event
Title,"To execute an action when the server begins listening for incoming requests, you can subscribe to the listen$ stream, as demonstrated below:"
Title,typescript
Title,this.httpAdapterHost.listen$.subscribe(() =>
Title,"console.log('HTTP server is listening'),"
Title,);
Title,"Additionally, the HttpAdapterHost provides a listening boolean property that indicates whether the server is currently active and listening:"
Title,typescript
Title,if (this.httpAdapterHost.listening) {
Title,console.log('HTTP server is listening');
Title,}
Title,
Title,Hybrid application
Title,"A hybrid application is one that listens for requests from two or more different sources. This can combine an HTTP server with a microservice listener or even just multiple different microservice listeners. The default createMicroservice method does not allow for multiple servers so in this case each microservice must be created and started manually. In order to do this, the INestApplication instance can be connected with INestMicroservice instances through the connectMicroservice() method."
Title,```typescript
Title,const app = await NestFactory.create(AppModule);
Title,const microservice = app.connectMicroservice({
Title,"transport: Transport.TCP,"
Title,});
Title,await app.startAllMicroservices();
Title,await app.listen(3001);
Title,```
Title,
Title,info Hint the app.listen(port) method starts an HTTP server on the specified address. If your application does not handle HTTP requests then you should use the app.init() method instead.
Title,
Title,"To connect multiple microservice instances, issue the call to connectMicroservice() for each microservice:"
Title,```typescript
Title,const app = await NestFactory.create(AppModule);
Title,// microservice #1
Title,const microserviceTcp = app.connectMicroservice({
Title,"transport: Transport.TCP,"
Title,options: {
Title,"port: 3001,"
Title,"},"
Title,});
Title,// microservice #2
Title,const microserviceRedis = app.connectMicroservice({
Title,"transport: Transport.REDIS,"
Title,options: {
Title,"host: 'localhost',"
Title,"port: 6379,"
Title,"},"
Title,});
Title,await app.startAllMicroservices();
Title,await app.listen(3001);
Title,```
Title,"To bind @MessagePattern() to only one transport strategy (for example, MQTT) in a hybrid application with multiple microservices, we can pass the second argument of type Transport which is an enum with all the built-in transport strategies defined."
Title,typescript
Title,@@filename()
Title,"@MessagePattern('time.us.*', Transport.NATS)"
Title,"getDate(@Payload() data: number[], @Ctx() context: NatsContext) {"
Title,"console.log(`Subject: ${context.getSubject()}`); // e.g. ""time.us.east"""
Title,return new Date().toLocaleTimeString(...);
Title,}
Title,"@MessagePattern({ cmd: 'time.us' }, Transport.TCP)"
Title,getTCPDate(@Payload() data: number[]) {
Title,return new Date().toLocaleTimeString(...);
Title,}
Title,@@switch
Title,"@Bind(Payload(), Ctx())"
Title,"@MessagePattern('time.us.*', Transport.NATS)"
Title,"getDate(data, context) {"
Title,"console.log(`Subject: ${context.getSubject()}`); // e.g. ""time.us.east"""
Title,return new Date().toLocaleTimeString(...);
Title,}
Title,"@Bind(Payload(), Ctx())"
Title,"@MessagePattern({ cmd: 'time.us' }, Transport.TCP)"
Title,"getTCPDate(data, context) {"
Title,return new Date().toLocaleTimeString(...);
Title,}
Title,
Title,"info Hint @Payload(), @Ctx(), Transport and NatsContext are imported from @nestjs/microservices."
Title,
Title,Sharing configuration
Title,"By default a hybrid application will not inherit global pipes, interceptors, guards and filters configured for the main (HTTP-based) application."
Title,"To inherit these configuration properties from the main application, set the inheritAppConfig property in the second argument (an optional options object) of the connectMicroservice() call, as follow:"
Title,typescript
Title,const microservice = app.connectMicroservice<MicroserviceOptions>(
Title,{
Title,"transport: Transport.TCP,"
Title,"},"
Title,"{ inheritAppConfig: true },"
Title,);
Title,
Title,Keep alive connections
Title,"By default, the HTTP adapters of NestJS will wait until the response is finished before closing the application. But sometimes, this behavior is not desired, or unexpected. There might be some requests that use Connection: Keep-Alive headers that live for a long time."
Title,"For these scenarios where you always want your application to exit without waiting for requests to end, you can enable the forceCloseConnections option when creating your NestJS application."
Title,
Title,warning Tip Most users will not need to enable this option. But the symptom of needing this option is that your application will not exit when you expect it to. Usually when app.enableShutdownHooks() is enabled and you notice that the application is not restarting/exiting. Most likely while running the NestJS application during development with --watch.
Title,
Title,Usage
Title,"In your main.ts file, enable the option when creating your NestJS application:"
Title,```typescript
Title,import { NestFactory } from '@nestjs/core';
Title,import { AppModule } from './app.module';
Title,async function bootstrap() {
Title,"const app = await NestFactory.create(AppModule, {"
Title,"forceCloseConnections: true,"
Title,});
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,bootstrap();
Title,```
Title,
Title,HTTPS
Title,"To create an application that uses the HTTPS protocol, set the httpsOptions property in the options object passed to the create() method of the NestFactory class:"
Title,typescript
Title,const httpsOptions = {
Title,"key: fs.readFileSync('./secrets/private-key.pem'),"
Title,"cert: fs.readFileSync('./secrets/public-certificate.pem'),"
Title,};
Title,"const app = await NestFactory.create(AppModule, {"
Title,"httpsOptions,"
Title,});
Title,await app.listen(process.env.PORT ?? 3000);
Title,"If you use the FastifyAdapter, create the application as follows:"
Title,typescript
Title,const app = await NestFactory.create<NestFastifyApplication>(
Title,"AppModule,"
Title,"new FastifyAdapter({ https: httpsOptions }),"
Title,);
Title,Multiple simultaneous servers
Title,"The following recipe shows how to instantiate a Nest application that listens on multiple ports (for example, on a non-HTTPS port and an HTTPS port) simultaneously."
Title,```typescript
Title,const httpsOptions = {
Title,"key: fs.readFileSync('./secrets/private-key.pem'),"
Title,"cert: fs.readFileSync('./secrets/public-certificate.pem'),"
Title,};
Title,const server = express();
Title,"const app = await NestFactory.create(AppModule, new ExpressAdapter(server));"
Title,await app.init();
Title,const httpServer = http.createServer(server).listen(3000);
Title,"const httpsServer = https.createServer(httpsOptions, server).listen(443);"
Title,```
Title,"Because we called http.createServer / https.createServer ourselves, NestJS doesn't close them when calling app.close / on termination signal. We need to do this ourselves:"
Title,```typescript
Title,@Injectable()
Title,export class ShutdownObserver implements OnApplicationShutdown {
Title,private httpServers: http.Server[] = [];
Title,public addHttpServer(server: http.Server): void {
Title,this.httpServers.push(server);
Title,}
Title,public async onApplicationShutdown(): Promise {
Title,await Promise.all(
Title,this.httpServers.map(
Title,(server) =>
Title,"new Promise((resolve, reject) => {"
Title,server.close((error) => {
Title,if (error) {
Title,reject(error);
Title,} else {
Title,resolve(null);
Title,}
Title,});
Title,"}),"
Title,"),"
Title,);
Title,}
Title,}
Title,const shutdownObserver = app.get(ShutdownObserver);
Title,shutdownObserver.addHttpServer(httpServer);
Title,shutdownObserver.addHttpServer(httpsServer);
Title,```
Title,
Title,info Hint The ExpressAdapter is imported from the @nestjs/platform-express package. The http and https packages are native Node.js packages.
Title,Warning This recipe does not work with GraphQL Subscriptions.
Title,
Title,
Title,Raw body
Title,One of the most common use-case for having access to the raw request body is performing webhook signature verifications. Usually to perform webhook signature validations the unserialized request body is required to calculate an HMAC hash.
Title,
Title,"warning Warning This feature can be used only if the built-in global body parser middleware is enabled, ie., you must not pass bodyParser: false when creating the app."
Title,
Title,Use with Express
Title,First enable the option when creating your Nest Express application:
Title,```typescript
Title,import { NestFactory } from '@nestjs/core';
Title,import type { NestExpressApplication } from '@nestjs/platform-express';
Title,import { AppModule } from './app.module';
Title,"// in the ""bootstrap"" function"
Title,"const app = await NestFactory.create(AppModule, {"
Title,"rawBody: true,"
Title,});
Title,await app.listen(process.env.PORT ?? 3000);
Title,```
Title,"To access the raw request body in a controller, a convenience interface RawBodyRequest is provided to expose a rawBody field on the request: use the interface RawBodyRequest type:"
Title,```typescript
Title,"import { Controller, Post, RawBodyRequest, Req } from '@nestjs/common';"
Title,import { Request } from 'express';
Title,@Controller('cats')
Title,class CatsController {
Title,@Post()
Title,create(@Req() req: RawBodyRequest) {
Title,const raw = req.rawBody; // returns a Buffer.
Title,}
Title,}
Title,```
Title,Registering a different parser
Title,"By default, only json and urlencoded parsers are registered. If you want to register a different parser on the fly, you will need to do so explicitly."
Title,"For example, to register a text parser, you can use the following code:"
Title,typescript
Title,app.useBodyParser('text');
Title,
Title,"warning Warning Ensure that you are providing the correct application type to the NestFactory.create call. For Express applications, the correct type is NestExpressApplication. Otherwise the .useBodyParser method will not be found."
Title,
Title,Body parser size limit
Title,"If your application needs to parse a body larger than the default 100kb of Express, use the following:"
Title,typescript
Title,"app.useBodyParser('json', { limit: '10mb' });"
Title,The .useBodyParser method will respect the rawBody option that is passed in the application options.
Title,Use with Fastify
Title,First enable the option when creating your Nest Fastify application:
Title,```typescript
Title,import { NestFactory } from '@nestjs/core';
Title,import {
Title,"FastifyAdapter,"
Title,"NestFastifyApplication,"
Title,} from '@nestjs/platform-fastify';
Title,import { AppModule } from './app.module';
Title,"// in the ""bootstrap"" function"
Title,const app = await NestFactory.create(
Title,"AppModule,"
Title,"new FastifyAdapter(),"
Title,{
Title,"rawBody: true,"
Title,"},"
Title,);
Title,await app.listen(process.env.PORT ?? 3000);
Title,```
Title,"To access the raw request body in a controller, a convenience interface RawBodyRequest is provided to expose a rawBody field on the request: use the interface RawBodyRequest type:"
Title,```typescript
Title,"import { Controller, Post, RawBodyRequest, Req } from '@nestjs/common';"
Title,import { FastifyRequest } from 'fastify';
Title,@Controller('cats')
Title,class CatsController {
Title,@Post()
Title,create(@Req() req: RawBodyRequest) {
Title,const raw = req.rawBody; // returns a Buffer.
Title,}
Title,}
Title,```
Title,Registering a different parser
Title,"By default, only application/json and application/x-www-form-urlencoded parsers are registered. If you want to register a different parser on the fly, you will need to do so explicitly."
Title,"For example, to register a text/plain parser, you can use the following code:"
Title,typescript
Title,app.useBodyParser('text/plain');
Title,
Title,"warning Warning Ensure that you are providing the correct application type to the NestFactory.create call. For Fastify applications, the correct type is NestFastifyApplication. Otherwise the .useBodyParser method will not be found."
Title,
Title,Body parser size limit
Title,"If your application needs to parse a body larger than the default 1MiB of Fastify, use the following:"
Title,typescript
Title,const bodyLimit = 10_485_760; // 10MiB
Title,"app.useBodyParser('application/json', { bodyLimit });"
Title,The .useBodyParser method will respect the rawBody option that is passed in the application options.
Title,
Title,Request lifecycle
Title,"Nest applications handle requests and produce responses in a sequence we refer to as the request lifecycle. With the use of middleware, pipes, guards, and interceptors, it can be challenging to track down where a particular piece of code executes during the request lifecycle, especially as global, controller level, and route level components come into play. In general, a request flows through middleware to guards, then to interceptors, then to pipes and finally back to interceptors on the return path (as the response is generated)."
Title,Middleware
Title,"Middleware is executed in a particular sequence. First, Nest runs globally bound middleware (such as middleware bound with app.use) and then it runs module bound middleware, which are determined on paths. Middleware are run sequentially in the order they are bound, similar to the way middleware in Express works. In the case of middleware bound across different modules, the middleware bound to the root module will run first, and then middleware will run in the order that the modules are added to the imports array."
Title,Guards
Title,"Guard execution starts with global guards, then proceeds to controller guards, and finally to route guards. As with middleware, guards run in the order in which they are bound. For example:"
Title,```typescript
Title,"@UseGuards(Guard1, Guard2)"
Title,@Controller('cats')
Title,export class CatsController {
Title,constructor(private catsService: CatsService) {}
Title,@UseGuards(Guard3)
Title,@Get()
Title,getCats(): Cats[] {
Title,return this.catsService.getCats();
Title,}
Title,}
Title,```
Title,Guard1 will execute before Guard2 and both will execute before Guard3.
Title,
Title,"info Hint When speaking about globally bound vs controller or locally bound, the difference is where the guard (or other component is bound). If you are using app.useGlobalGuard() or providing the component via a module, it is globally bound. Otherwise, it is bound to a controller if the decorator precedes a controller class, or to a route if the decorator precedes a route declaration."
Title,
Title,Interceptors
Title,"Interceptors, for the most part, follow the same pattern as guards, with one catch: as interceptors return RxJS Observables, the observables will be resolved in a first in last out manner. So inbound requests will go through the standard global, controller, route level resolution, but the response side of the request (i.e., after returning from the controller method handler) will be resolved from route to controller to global. Also, any errors thrown by pipes, controllers, or services can be read in the catchError operator of an interceptor."
Title,Pipes
Title,"Pipes follow the standard global to controller to route bound sequence, with the same first in first out in regards to the @UsePipes() parameters. However, at a route parameter level, if you have multiple pipes running, they will run in the order of the last parameter with a pipe to the first. This also applies to the route level and controller level pipes. For example, if we have the following controller:"
Title,```typescript
Title,@UsePipes(GeneralValidationPipe)
Title,@Controller('cats')
Title,export class CatsController {
Title,constructor(private catsService: CatsService) {}
Title,@UsePipes(RouteSpecificPipe)
Title,@Patch(':id')
Title,updateCat(
Title,"@Body() body: UpdateCatDTO,"
Title,"@Param() params: UpdateCatParams,"
Title,"@Query() query: UpdateCatQuery,"
Title,) {
Title,"return this.catsService.updateCat(body, params, query);"
Title,}
Title,}
Title,```
Title,"then the GeneralValidationPipe will run for the query, then the params, and then the body objects before moving on to the RouteSpecificPipe, which follows the same order. If any parameter-specific pipes were in place, they would run (again, from the last to first parameter) after the controller and route level pipes."
Title,Filters
Title,"Filters are the only component that do not resolve global first. Instead, filters resolve from the lowest level possible, meaning execution starts with any route bound filters and proceeding next to controller level, and finally to global filters. Note that exceptions cannot be passed from filter to filter; if a route level filter catches the exception, a controller or global level filter cannot catch the same exception. The only way to achieve an effect like this is to use inheritance between the filters."
Title,
Title,"info Hint Filters are only executed if any uncaught exception occurs during the request process. Caught exceptions, such as those caught with a try/catch will not trigger Exception Filters to fire. As soon as an uncaught exception is encountered, the rest of the lifecycle is ignored and the request skips straight to the filter."
Title,
Title,Summary
Title,"In general, the request lifecycle looks like the following:"
Title,
Title,Incoming request
Title,Middleware
Title,2.1. Globally bound middleware
Title,2.2. Module bound middleware
Title,Guards
Title,3.1 Global guards
Title,3.2 Controller guards
Title,3.3 Route guards
Title,Interceptors (pre-controller)
Title,4.1 Global interceptors
Title,4.2 Controller interceptors
Title,4.3 Route interceptors
Title,Pipes
Title,5.1 Global pipes
Title,5.2 Controller pipes
Title,5.3 Route pipes
Title,5.4 Route parameter pipes
Title,Controller (method handler)
Title,Service (if exists)
Title,Interceptors (post-request)
Title,8.1 Route interceptor
Title,8.2 Controller interceptor
Title,8.3 Global interceptor
Title,Exception filters
Title,9.1 route
Title,9.2 controller
Title,9.3 global
Title,Server response
Title,
Title,
Title,Serverless
Title,"Serverless computing is a cloud computing execution model in which the cloud provider allocates machine resources on-demand, taking care of the servers on behalf of their customers. When an app is not in use, there are no computing resources allocated to the app. Pricing is based on the actual amount of resources consumed by an application (source)."
Title,"With a serverless architecture, you focus purely on the individual functions in your application code. Services such as AWS Lambda, Google Cloud Functions, and Microsoft Azure Functions take care of all the physical hardware, virtual machine operating system, and web server software management."
Title,
Title,info Hint This chapter does not cover the pros and cons of serverless functions nor dives into the specifics of any cloud providers.
Title,
Title,Cold start
Title,"A cold start is the first time your code has been executed in a while. Depending on a cloud provider you use, it may span several different operations, from downloading the code and bootstrapping the runtime to eventually running your code."
Title,"This process adds significant latency depending on several factors, the language, the number of packages your application require, etc."
Title,"The cold start is important and although there are things which are beyond our control, there's still a lot of things we can do on our side to make it as short as possible."
Title,"While you can think of Nest as a fully-fledged framework designed to be used in complex, enterprise applications,"
Title,"it is also suitable for much ""simpler"" applications (or scripts). For example, with the use of Standalone applications feature, you can take advantage of Nest's DI system in simple workers, CRON jobs, CLIs, or serverless functions."
Title,Benchmarks
Title,"To better understand what's the cost of using Nest or other, well-known libraries (like express) in the context of serverless functions, let's compare how much time Node runtime needs to run the following scripts:"
Title,```typescript
Title,// #1 Express
Title,import * as express from 'express';
Title,async function bootstrap() {
Title,const app = express();
Title,"app.get('/', (req, res) => res.send('Hello world!'));"
Title,"await new Promise((resolve) => app.listen(3000, resolve));"
Title,}
Title,bootstrap();
Title,// #2 Nest (with @nestjs/platform-express)
Title,import { NestFactory } from '@nestjs/core';
Title,import { AppModule } from './app.module';
Title,async function bootstrap() {
Title,"const app = await NestFactory.create(AppModule, { logger: ['error'] });"
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,bootstrap();
Title,// #3 Nest as a Standalone application (no HTTP server)
Title,import { NestFactory } from '@nestjs/core';
Title,import { AppModule } from './app.module';
Title,import { AppService } from './app.service';
Title,async function bootstrap() {
Title,"const app = await NestFactory.createApplicationContext(AppModule, {"
Title,"logger: ['error'],"
Title,});
Title,console.log(app.get(AppService).getHello());
Title,}
Title,bootstrap();
Title,// #4 Raw Node.js script
Title,async function bootstrap() {
Title,console.log('Hello world!');
Title,}
Title,bootstrap();
Title,```
Title,"For all these scripts, we used the tsc (TypeScript) compiler and so the code remains unbundled (webpack isn't used)."
Title,|                                      |                   |
Title,| ------------------------------------ | ----------------- |
Title,| Express                              | 0.0079s (7.9ms)   |
Title,| Nest with @nestjs/platform-express | 0.1974s (197.4ms) |
Title,| Nest (standalone application)        | 0.1117s (111.7ms) |
Title,| Raw Node.js script                   | 0.0071s (7.1ms)   |
Title,
Title,"info Note Machine: MacBook Pro Mid 2014, 2.5 GHz Quad-Core Intel Core i7, 16 GB 1600 MHz DDR3, SSD."
Title,
Title,"Now, let's repeat all benchmarks but this time, using webpack (if you have Nest CLI installed, you can run nest build --webpack) to bundle our application into a single executable JavaScript file."
Title,"However, instead of using the default webpack configuration that Nest CLI ships with, we'll make sure to bundle all dependencies (node_modules) together, as follows:"
Title,```javascript
Title,"module.exports = (options, webpack) => {"
Title,const lazyImports = [
Title,"'@nestjs/microservices/microservices-module',"
Title,"'@nestjs/websockets/socket-module',"
Title,];
Title,return {
Title,"...options,"
Title,"externals: [],"
Title,plugins: [
Title,"...options.plugins,"
Title,new webpack.IgnorePlugin({
Title,checkResource(resource) {
Title,if (lazyImports.includes(resource)) {
Title,try {
Title,require.resolve(resource);
Title,} catch (err) {
Title,return true;
Title,}
Title,}
Title,return false;
Title,"},"
Title,"}),"
Title,"],"
Title,};
Title,};
Title,```
Title,
Title,"info Hint To instruct Nest CLI to use this configuration, create a new webpack.config.js file in the root directory of your project."
Title,
Title,"With this configuration, we received the following results:"
Title,|                                      |                  |
Title,| ------------------------------------ | ---------------- |
Title,| Express                              | 0.0068s (6.8ms)  |
Title,| Nest with @nestjs/platform-express | 0.0815s (81.5ms) |
Title,| Nest (standalone application)        | 0.0319s (31.9ms) |
Title,| Raw Node.js script                   | 0.0066s (6.6ms)  |
Title,
Title,"info Note Machine: MacBook Pro Mid 2014, 2.5 GHz Quad-Core Intel Core i7, 16 GB 1600 MHz DDR3, SSD."
Title,"info Hint You could optimize it even further by applying additional code minification & optimization techniques (using webpack plugins, etc.)."
Title,
Title,"As you can see, the way you compile (and whether you bundle your code) is crucial and has a significant impact on the overall startup time. With webpack, you can get the bootstrap time of a standalone Nest application (starter project with one module, controller, and service) down to ~32ms on average, and down to ~81.5ms for a regular HTTP, express-based NestJS app."
Title,"For more complicated Nest applications, for example, with 10 resources (generated through $ nest g resource schematic = 10 modules, 10 controllers, 10 services, 20 DTO classes, 50 HTTP endpoints + AppModule), the overall startup on MacBook Pro Mid 2014, 2.5 GHz Quad-Core Intel Core i7, 16 GB 1600 MHz DDR3, SSD is approximately 0.1298s (129.8ms). Running a monolithic application as a serverless function typically doesn't make too much sense anyway, so think of this benchmark more as an example of how the bootstrap time may potentially increase as your application grows."
Title,Runtime optimizations
Title,"Thus far we covered compile-time optimizations. These are unrelated to the way you define providers and load Nest modules in your application, and that plays an essential role as your application gets bigger."
Title,"For example, imagine having a database connection defined as an asynchronous provider. Async providers are designed to delay the application start until one or more asynchronous tasks are completed."
Title,"That means, if your serverless function on average requires 2s to connect to the database (on bootstrap), your endpoint will need at least two extra seconds (because it must wait till the connection is established) to send a response back (when it's a cold start and your application wasn't running already)."
Title,"As you can see, the way you structure your providers is somewhat different in a serverless environment where bootstrap time is important."
Title,"Another good example is if you use Redis for caching, but only in certain scenarios. Perhaps, in this case, you should not define a Redis connection as an async provider, as it would slow down the bootstrap time, even if it's not required for this specific function invocation."
Title,"Also, sometimes you could lazy load entire modules, using the LazyModuleLoader class, as described in this chapter. Caching is a great example here too."
Title,"Imagine that your application has, let's say, CacheModule which internally connects to Redis and also, exports the CacheService to interact with the Redis storage. If you don't need it for all potential function invocations,"
Title,"you can just load it on-demand, lazily. This way you'll get a faster startup time (when a cold start occurs) for all invocations that don't require caching."
Title,```typescript
Title,if (request.method === RequestMethod[RequestMethod.GET]) {
Title,const { CacheModule } = await import('./cache.module');
Title,const moduleRef = await this.lazyModuleLoader.load(() => CacheModule);
Title,const { CacheService } = await import('./cache.service');
Title,const cacheService = moduleRef.get(CacheService);
Title,return cacheService.get(ENDPOINT_KEY);
Title,}
Title,```
Title,"Another great example is a webhook or worker, which depending on some specific conditions (e.g., input arguments), may perform different operations."
Title,"In such a case, you could specify a condition inside your route handler that lazily loads an appropriate module for the specific function invocation, and just load every other module lazily."
Title,typescript
Title,if (workerType === WorkerType.A) {
Title,const { WorkerAModule } = await import('./worker-a.module');
Title,const moduleRef = await this.lazyModuleLoader.load(() => WorkerAModule);
Title,// ...
Title,} else if (workerType === WorkerType.B) {
Title,const { WorkerBModule } = await import('./worker-b.module');
Title,const moduleRef = await this.lazyModuleLoader.load(() => WorkerBModule);
Title,// ...
Title,}
Title,Example integration
Title,The way your application's entry file (typically main.ts file) is supposed to look like depends on several factors and so there's no single template that just works for every scenario.
Title,"For example, the initialization file required to spin up your serverless function varies by cloud providers (AWS, Azure, GCP, etc.)."
Title,"Also, depending on whether you want to run a typical HTTP application with multiple routes/endpoints or just provide a single route (or execute a specific portion of code),"
Title,"your application's code will look different (for example, for the endpoint-per-function approach you could use the NestFactory.createApplicationContext instead of booting the HTTP server, setting up middleware, etc.)."
Title,"Just for illustration purposes, we'll integrate Nest (using @nestjs/platform-express and so spinning up the whole, fully functional HTTP router)"
Title,"with the Serverless framework (in this case, targeting AWS Lambda). As we've mentioned earlier, your code will differ depending on the cloud provider you choose, and many other factors."
Title,"First, let's install the required packages:"
Title,bash
Title,$ npm i @codegenie/serverless-express aws-lambda
Title,$ npm i -D @types/aws-lambda serverless-offline
Title,
Title,"info Hint To speed up development cycles, we install the serverless-offline plugin which emulates AWS λ and API Gateway."
Title,
Title,"Once the installation process is complete, let's create the serverless.yml file to configure the Serverless framework:"
Title,```yaml
Title,service: serverless-example
Title,plugins:
Title,- serverless-offline
Title,provider:
Title,name: aws
Title,runtime: nodejs14.x
Title,functions:
Title,main:
Title,handler: dist/main.handler
Title,events:
Title,- http:
Title,method: ANY
Title,path: /
Title,- http:
Title,method: ANY
Title,path: '{proxy+}'
Title,```
Title,
Title,"info Hint To learn more about the Serverless framework, visit the official documentation."
Title,
Title,"With this in place, we can now navigate to the main.ts file and update our bootstrap code with the required boilerplate:"
Title,```typescript
Title,import { NestFactory } from '@nestjs/core';
Title,import serverlessExpress from '@codegenie/serverless-express';
Title,"import { Callback, Context, Handler } from 'aws-lambda';"
Title,import { AppModule } from './app.module';
Title,let server: Handler;
Title,async function bootstrap(): Promise {
Title,const app = await NestFactory.create(AppModule);
Title,await app.init();
Title,const expressApp = app.getHttpAdapter().getInstance();
Title,return serverlessExpress({ app: expressApp });
Title,}
Title,export const handler: Handler = async (
Title,"event: any,"
Title,"context: Context,"
Title,"callback: Callback,"
Title,) => {
Title,server = server ?? (await bootstrap());
Title,"return server(event, context, callback);"
Title,};
Title,```
Title,
Title,"info Hint For creating multiple serverless functions and sharing common modules between them, we recommend using the CLI Monorepo mode."
Title,"warning Warning If you use @nestjs/swagger package, there are a few additional steps required to make it work properly in the context of serverless function. Check out this thread for more information."
Title,
Title,"Next, open up the tsconfig.json file and make sure to enable the esModuleInterop option to make the @codegenie/serverless-express package load properly."
Title,json
Title,{
Title,"""compilerOptions"": {"
Title,...
Title,"""esModuleInterop"": true"
Title,}
Title,}
Title,Now we can build our application (with nest build or tsc) and use the serverless CLI to start our lambda function locally:
Title,bash
Title,$ npm run build
Title,$ npx serverless offline
Title,"Once the application is running, open your browser and navigate to http://localhost:3000/dev/[ANY_ROUTE] (where [ANY_ROUTE] is any endpoint registered in your application)."
Title,"In the sections above, we've shown that using webpack and bundling your app can have significant impact on the overall bootstrap time."
Title,"However, to make it work with our example, there are a few additional configurations you must add in your webpack.config.js file. Generally,"
Title,"to make sure our handler function will be picked up, we must change the output.libraryTarget property to commonjs2."
Title,javascript
Title,return {
Title,"...options,"
Title,"externals: [],"
Title,output: {
Title,"...options.output,"
Title,"libraryTarget: 'commonjs2',"
Title,"},"
Title,// ... the rest of the configuration
Title,};
Title,"With this in place, you can now use $ nest build --webpack to compile your function's code (and then $ npx serverless offline to test it)."
Title,It's also recommended (but not required as it will slow down your build process) to install the terser-webpack-plugin package and override its configuration to keep classnames intact when minifying your production build. Not doing so can result in incorrect behavior when using class-validator within your application.
Title,```javascript
Title,const TerserPlugin = require('terser-webpack-plugin');
Title,return {
Title,"...options,"
Title,"externals: [],"
Title,optimization: {
Title,minimizer: [
Title,new TerserPlugin({
Title,terserOptions: {
Title,"keep_classnames: true,"
Title,"},"
Title,"}),"
Title,"],"
Title,"},"
Title,output: {
Title,"...options.output,"
Title,"libraryTarget: 'commonjs2',"
Title,"},"
Title,// ... the rest of the configuration
Title,};
Title,```
Title,Using standalone application feature
Title,"Alternatively, if you want to keep your function very lightweight and you don't need any HTTP-related features (routing, but also guards, interceptors, pipes, etc.),"
Title,"you can just use NestFactory.createApplicationContext (as mentioned earlier) instead of running the entire HTTP server (and express under the hood), as follows:"
Title,```typescript
Title,@@filename(main)
Title,import { HttpStatus } from '@nestjs/common';
Title,import { NestFactory } from '@nestjs/core';
Title,"import { Callback, Context, Handler } from 'aws-lambda';"
Title,import { AppModule } from './app.module';
Title,import { AppService } from './app.service';
Title,export const handler: Handler = async (
Title,"event: any,"
Title,"context: Context,"
Title,"callback: Callback,"
Title,) => {
Title,const appContext = await NestFactory.createApplicationContext(AppModule);
Title,const appService = appContext.get(AppService);
Title,return {
Title,"body: appService.getHello(),"
Title,"statusCode: HttpStatus.OK,"
Title,};
Title,};
Title,```
Title,
Title,"info Hint Be aware that NestFactory.createApplicationContext does not wrap controller methods with enhancers (guard, interceptors, etc.). For this, you must use the NestFactory.create method."
Title,
Title,"You could also pass the event object down to, let's say, EventsService provider that could process it and return a corresponding value (depending on the input value and your business logic)."
Title,typescript
Title,export const handler: Handler = async (
Title,"event: any,"
Title,"context: Context,"
Title,"callback: Callback,"
Title,) => {
Title,const appContext = await NestFactory.createApplicationContext(AppModule);
Title,const eventsService = appContext.get(EventsService);
Title,return eventsService.process(event);
Title,};
Title,
Title,First steps
Title,"In this set of articles, you'll learn the core fundamentals of Nest. To get familiar with the essential building blocks of Nest applications, we'll build a basic CRUD application with features that cover a lot of ground at an introductory level."
Title,Language
Title,"We're in love with TypeScript, but above all - we love Node.js. That's why Nest is compatible with both TypeScript and pure JavaScript. Nest takes advantage of the latest language features, so to use it with vanilla JavaScript we need a Babel compiler."
Title,"We'll mostly use TypeScript in the examples we provide, but you can always switch the code snippets to vanilla JavaScript syntax (simply click to toggle the language button in the upper right hand corner of each snippet)."
Title,Prerequisites
Title,Please make sure that Node.js (version >= 16) is installed on your operating system.
Title,Setup
Title,"Setting up a new project is quite simple with the Nest CLI. With npm installed, you can create a new Nest project with the following commands in your OS terminal:"
Title,bash
Title,$ npm i -g @nestjs/cli
Title,$ nest new project-name
Title,
Title,"info Hint To create a new project with TypeScript's stricter feature set, pass the --strict flag to the nest new command."
Title,
Title,"The project-name directory will be created, node modules and a few other boilerplate files will be installed, and a src/ directory will be created and populated with several core files."
Title,
Title,src
Title,
Title,app.controller.spec.ts
Title,app.controller.ts
Title,app.module.ts
Title,app.service.ts
Title,main.ts
Title,
Title,
Title,Here's a brief overview of those core files:
Title,|                          |                                                                                                                     |
Title,| ------------------------ | ------------------------------------------------------------------------------------------------------------------- |
Title,| app.controller.ts      | A basic controller with a single route.                                                                             |
Title,| app.controller.spec.ts | The unit tests for the controller.                                                                                  |
Title,| app.module.ts          | The root module of the application.                                                                                 |
Title,| app.service.ts         | A basic service with a single method.                                                                               |
Title,| main.ts                | The entry file of the application which uses the core function NestFactory to create a Nest application instance. |
Title,"The main.ts includes an async function, which will bootstrap our application:"
Title,```typescript
Title,@@filename(main)
Title,import { NestFactory } from '@nestjs/core';
Title,import { AppModule } from './app.module';
Title,async function bootstrap() {
Title,const app = await NestFactory.create(AppModule);
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,bootstrap();
Title,@@switch
Title,import { NestFactory } from '@nestjs/core';
Title,import { AppModule } from './app.module';
Title,async function bootstrap() {
Title,const app = await NestFactory.create(AppModule);
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,bootstrap();
Title,```
Title,"To create a Nest application instance, we use the core NestFactory class. NestFactory exposes a few static methods that allow creating an application instance. The create() method returns an application object, which fulfills the INestApplication interface. This object provides a set of methods which are described in the coming chapters. In the main.ts example above, we simply start up our HTTP listener, which lets the application await inbound HTTP requests."
Title,Note that a project scaffolded with the Nest CLI creates an initial project structure that encourages developers to follow the convention of keeping each module in its own dedicated directory.
Title,
Title,"info Hint By default, if any error happens while creating the application your app will exit with the code 1. If you want to make it throw an error instead disable the option abortOnError (e.g., NestFactory.create(AppModule, {{ '{' }} abortOnError: false {{ '}' }}))."
Title,
Title,
Title,Platform
Title,"Nest aims to be a platform-agnostic framework. Platform independence makes it possible to create reusable logical parts that developers can take advantage of across several different types of applications. Technically, Nest is able to work with any Node HTTP framework once an adapter is created. There are two HTTP platforms supported out-of-the-box: express and fastify. You can choose the one that best suits your needs."
Title,|                    |                                                                                                                                                                                                                                                                                                                                    |
Title,| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
Title,"| platform-express | Express is a well-known minimalist web framework for node. It's a battle tested, production-ready library with lots of resources implemented by the community. The @nestjs/platform-express package is used by default. Many users are well served with Express, and need take no action to enable it. |"
Title,| platform-fastify | Fastify is a high performance and low overhead framework highly focused on providing maximum efficiency and speed. Read how to use it here.                                                                                                                                  |
Title,"Whichever platform is used, it exposes its own application interface. These are seen respectively as NestExpressApplication and NestFastifyApplication."
Title,"When you pass a type to the NestFactory.create() method, as in the example below, the app object will have methods available exclusively for that specific platform. Note, however, you don't need to specify a type unless you actually want to access the underlying platform API."
Title,typescript
Title,const app = await NestFactory.create<NestExpressApplication>(AppModule);
Title,Running the application
Title,"Once the installation process is complete, you can run the following command at your OS command prompt to start the application listening for inbound HTTP requests:"
Title,bash
Title,$ npm run start
Title,
Title,"info Hint To speed up the development process (x20 times faster builds), you can use the SWC builder by passing the -b swc flag to the start script, as follows npm run start -- -b swc."
Title,
Title,"This command starts the app with the HTTP server listening on the port defined in the src/main.ts file. Once the application is running, open your browser and navigate to http://localhost:3000/. You should see the Hello World! message."
Title,"To watch for changes in your files, you can run the following command to start the application:"
Title,bash
Title,$ npm run start:dev
Title,"This command will watch your files, automatically recompiling and reloading the server."
Title,Linting and formatting
Title,"CLI provides best effort to scaffold a reliable development workflow at scale. Thus, a generated Nest project comes with both a code linter and formatter preinstalled (respectively eslint and prettier)."
Title,
Title,info Hint Not sure about the role of formatters vs linters? Learn the difference here.
Title,
Title,"To ensure maximum stability and extensibility, we use the base eslint and prettier cli packages. This setup allows neat IDE integration with official extensions by design."
Title,"For headless environments where an IDE is not relevant (Continuous Integration, Git hooks, etc.) a Nest project comes with ready-to-use npm scripts."
Title,```bash
Title,Lint and autofix with eslint
Title,$ npm run lint
Title,Format with prettier
Title,$ npm run format
Title,```
Title,
Title,Asynchronous providers
Title,"At times, the application start should be delayed until one or more asynchronous tasks are completed. For example, you may not want to start accepting requests until the connection with the database has been established. You can achieve this using asynchronous providers."
Title,"The syntax for this is to use async/await with the useFactory syntax. The factory returns a Promise, and the factory function can await asynchronous tasks. Nest will await resolution of the promise before instantiating any class that depends on (injects) such a provider."
Title,typescript
Title,{
Title,"provide: 'ASYNC_CONNECTION',"
Title,useFactory: async () => {
Title,const connection = await createConnection(options);
Title,return connection;
Title,"},"
Title,}
Title,
Title,info Hint Learn more about custom provider syntax here.
Title,
Title,Injection
Title,"Asynchronous providers are injected to other components by their tokens, like any other provider. In the example above, you would use the construct @Inject('ASYNC_CONNECTION')."
Title,Example
Title,The TypeORM recipe has a more substantial example of an asynchronous provider.
Title,
Title,Circular dependency
Title,"A circular dependency occurs when two classes depend on each other. For example, class A needs class B, and class B also needs class A. Circular dependencies can arise in Nest between modules and between providers."
Title,"While circular dependencies should be avoided where possible, you can't always do so. In such cases, Nest enables resolving circular dependencies between providers in two ways. In this chapter, we describe using forward referencing as one technique, and using the ModuleRef class to retrieve a provider instance from the DI container as another."
Title,We also describe resolving circular dependencies between modules.
Title,
Title,"warning Warning A circular dependency might also be caused when using ""barrel files""/index.ts files to group imports. Barrel files should be omitted when it comes to module/provider classes. For example, barrel files should not be used when importing files within the same directory as the barrel file, i.e. cats/cats.controller should not import cats to import the cats/cats.service file. For more details please also see this github issue."
Title,
Title,Forward reference
Title,"A forward reference allows Nest to reference classes which aren't yet defined using the forwardRef() utility function. For example, if CatsService and CommonService depend on each other, both sides of the relationship can use @Inject() and the forwardRef() utility to resolve the circular dependency. Otherwise Nest won't instantiate them because all of the essential metadata won't be available. Here's an example:"
Title,typescript
Title,@@filename(cats.service)
Title,@Injectable()
Title,export class CatsService {
Title,constructor(
Title,@Inject(forwardRef(() => CommonService))
Title,"private commonService: CommonService,"
Title,) {}
Title,}
Title,@@switch
Title,@Injectable()
Title,@Dependencies(forwardRef(() => CommonService))
Title,export class CatsService {
Title,constructor(commonService) {
Title,this.commonService = commonService;
Title,}
Title,}
Title,
Title,info Hint The forwardRef() function is imported from the @nestjs/common package.
Title,
Title,That covers one side of the relationship. Now let's do the same with CommonService:
Title,typescript
Title,@@filename(common.service)
Title,@Injectable()
Title,export class CommonService {
Title,constructor(
Title,@Inject(forwardRef(() => CatsService))
Title,"private catsService: CatsService,"
Title,) {}
Title,}
Title,@@switch
Title,@Injectable()
Title,@Dependencies(forwardRef(() => CatsService))
Title,export class CommonService {
Title,constructor(catsService) {
Title,this.catsService = catsService;
Title,}
Title,}
Title,
Title,warning Warning The order of instantiation is indeterminate. Make sure your code does not depend on which constructor is called first. Having circular dependencies depend on providers with Scope.REQUEST can lead to undefined dependencies. More information available here
Title,
Title,ModuleRef class alternative
Title,An alternative to using forwardRef() is to refactor your code and use the ModuleRef class to retrieve a provider on one side of the (otherwise) circular relationship. Learn more about the ModuleRef utility class here.
Title,Module forward reference
Title,"In order to resolve circular dependencies between modules, use the same forwardRef() utility function on both sides of the modules association. For example:"
Title,typescript
Title,@@filename(common.module)
Title,@Module({
Title,"imports: [forwardRef(() => CatsModule)],"
Title,})
Title,export class CommonModule {}
Title,That covers one side of the relationship. Now let's do the same with CatsModule:
Title,typescript
Title,@@filename(cats.module)
Title,@Module({
Title,"imports: [forwardRef(() => CommonModule)],"
Title,})
Title,export class CatsModule {}
Title,
Title,Custom providers
Title,"In earlier chapters, we touched on various aspects of Dependency Injection (DI) and how it is used in Nest. One example of this is the constructor based dependency injection used to inject instances (often service providers) into classes. You won't be surprised to learn that Dependency Injection is built into the Nest core in a fundamental way. So far, we've only explored one main pattern. As your application grows more complex, you may need to take advantage of the full features of the DI system, so let's explore them in more detail."
Title,DI fundamentals
Title,"Dependency injection is an inversion of control (IoC) technique wherein you delegate instantiation of dependencies to the IoC container (in our case, the NestJS runtime system), instead of doing it in your own code imperatively. Let's examine what's happening in this example from the Providers chapter."
Title,"First, we define a provider. The @Injectable() decorator marks the CatsService class as a provider."
Title,```typescript
Title,@@filename(cats.service)
Title,import { Injectable } from '@nestjs/common';
Title,import { Cat } from './interfaces/cat.interface';
Title,@Injectable()
Title,export class CatsService {
Title,private readonly cats: Cat[] = [];
Title,findAll(): Cat[] {
Title,return this.cats;
Title,}
Title,}
Title,@@switch
Title,import { Injectable } from '@nestjs/common';
Title,@Injectable()
Title,export class CatsService {
Title,constructor() {
Title,this.cats = [];
Title,}
Title,findAll() {
Title,return this.cats;
Title,}
Title,}
Title,```
Title,Then we request that Nest inject the provider into our controller class:
Title,```typescript
Title,@@filename(cats.controller)
Title,"import { Controller, Get } from '@nestjs/common';"
Title,import { CatsService } from './cats.service';
Title,import { Cat } from './interfaces/cat.interface';
Title,@Controller('cats')
Title,export class CatsController {
Title,constructor(private catsService: CatsService) {}
Title,@Get()
Title,async findAll(): Promise {
Title,return this.catsService.findAll();
Title,}
Title,}
Title,@@switch
Title,"import { Controller, Get, Bind, Dependencies } from '@nestjs/common';"
Title,import { CatsService } from './cats.service';
Title,@Controller('cats')
Title,@Dependencies(CatsService)
Title,export class CatsController {
Title,constructor(catsService) {
Title,this.catsService = catsService;
Title,}
Title,@Get()
Title,async findAll() {
Title,return this.catsService.findAll();
Title,}
Title,}
Title,```
Title,"Finally, we register the provider with the Nest IoC container:"
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { CatsController } from './cats/cats.controller';
Title,import { CatsService } from './cats/cats.service';
Title,@Module({
Title,"controllers: [CatsController],"
Title,"providers: [CatsService],"
Title,})
Title,export class AppModule {}
Title,```
Title,What exactly is happening under the covers to make this work? There are three key steps in the process:
Title,
Title,"In cats.service.ts, the @Injectable() decorator declares the CatsService class as a class that can be managed by the Nest IoC container."
Title,"In cats.controller.ts, CatsController declares a dependency on the CatsService token with constructor injection:"
Title,
Title,typescript
Title,constructor(private catsService: CatsService)
Title,
Title,"In app.module.ts, we associate the token CatsService with the class CatsService from the cats.service.ts file. We'll see below exactly how this association (also called registration) occurs."
Title,
Title,"When the Nest IoC container instantiates a CatsController, it first looks for any dependencies*. When it finds the CatsService dependency, it performs a lookup on the CatsService token, which returns the CatsService class, per the registration step (#3 above). Assuming SINGLETON scope (the default behavior), Nest will then either create an instance of CatsService, cache it, and return it, or if one is already cached, return the existing instance."
Title,"*This explanation is a bit simplified to illustrate the point. One important area we glossed over is that the process of analyzing the code for dependencies is very sophisticated, and happens during application bootstrapping. One key feature is that dependency analysis (or ""creating the dependency graph""), is transitive. In the above example, if the CatsService itself had dependencies, those too would be resolved. The dependency graph ensures that dependencies are resolved in the correct order - essentially ""bottom up"". This mechanism relieves the developer from having to manage such complex dependency graphs."
Title,
Title,Standard providers
Title,"Let's take a closer look at the @Module() decorator. In app.module, we declare:"
Title,typescript
Title,@Module({
Title,"controllers: [CatsController],"
Title,"providers: [CatsService],"
Title,})
Title,"The providers property takes an array of providers. So far, we've supplied those providers via a list of class names. In fact, the syntax providers: [CatsService] is short-hand for the more complete syntax:"
Title,typescript
Title,providers: [
Title,{
Title,"provide: CatsService,"
Title,"useClass: CatsService,"
Title,"},"
Title,];
Title,"Now that we see this explicit construction, we can understand the registration process. Here, we are clearly associating the token CatsService with the class CatsService. The short-hand notation is merely a convenience to simplify the most common use-case, where the token is used to request an instance of a class by the same name."
Title,Custom providers
Title,What happens when your requirements go beyond those offered by Standard providers? Here are a few examples:
Title,
Title,You want to create a custom instance instead of having Nest instantiate (or return a cached instance of) a class
Title,You want to re-use an existing class in a second dependency
Title,You want to override a class with a mock version for testing
Title,
Title,Nest allows you to define Custom providers to handle these cases. It provides several ways to define custom providers. Let's walk through them.
Title,
Title,info Hint If you are having problems with dependency resolution you can set the NEST_DEBUG environment variable and get extra dependency resolution logs during startup.
Title,
Title,Value providers: useValue
Title,"The useValue syntax is useful for injecting a constant value, putting an external library into the Nest container, or replacing a real implementation with a mock object. Let's say you'd like to force Nest to use a mock CatsService for testing purposes."
Title,```typescript
Title,import { CatsService } from './cats.service';
Title,const mockCatsService = {
Title,/ mock implementation
Title,...
Title,/
Title,};
Title,@Module({
Title,"imports: [CatsModule],"
Title,providers: [
Title,{
Title,"provide: CatsService,"
Title,"useValue: mockCatsService,"
Title,"},"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,"In this example, the CatsService token will resolve to the mockCatsService mock object. useValue requires a value - in this case a literal object that has the same interface as the CatsService class it is replacing. Because of TypeScript's structural typing, you can use any object that has a compatible interface, including a literal object or a class instance instantiated with new."
Title,Non-class-based provider tokens
Title,"So far, we've used class names as our provider tokens (the value of the provide property in a provider listed in the providers array). This is matched by the standard pattern used with constructor based injection, where the token is also a class name. (Refer back to DI Fundamentals for a refresher on tokens if this concept isn't entirely clear). Sometimes, we may want the flexibility to use strings or symbols as the DI token. For example:"
Title,```typescript
Title,import { connection } from './connection';
Title,@Module({
Title,providers: [
Title,{
Title,"provide: 'CONNECTION',"
Title,"useValue: connection,"
Title,"},"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,"In this example, we are associating a string-valued token ('CONNECTION') with a pre-existing connection object we've imported from an external file."
Title,
Title,"warning Notice In addition to using strings as token values, you can also use JavaScript symbols or TypeScript enums."
Title,
Title,"We've previously seen how to inject a provider using the standard constructor based injection pattern. This pattern requires that the dependency be declared with a class name. The 'CONNECTION' custom provider uses a string-valued token. Let's see how to inject such a provider. To do so, we use the @Inject() decorator. This decorator takes a single argument - the token."
Title,typescript
Title,@@filename()
Title,@Injectable()
Title,export class CatsRepository {
Title,constructor(@Inject('CONNECTION') connection: Connection) {}
Title,}
Title,@@switch
Title,@Injectable()
Title,@Dependencies('CONNECTION')
Title,export class CatsRepository {
Title,constructor(connection) {}
Title,}
Title,
Title,info Hint The @Inject() decorator is imported from @nestjs/common package.
Title,
Title,"While we directly use the string 'CONNECTION' in the above examples for illustration purposes, for clean code organization, it's best practice to define tokens in a separate file, such as constants.ts. Treat them much as you would symbols or enums that are defined in their own file and imported where needed."
Title,Class providers: useClass
Title,"The useClass syntax allows you to dynamically determine a class that a token should resolve to. For example, suppose we have an abstract (or default) ConfigService class. Depending on the current environment, we want Nest to provide a different implementation of the configuration service. The following code implements such a strategy."
Title,```typescript
Title,const configServiceProvider = {
Title,"provide: ConfigService,"
Title,useClass:
Title,process.env.NODE_ENV === 'development'
Title,? DevelopmentConfigService
Title,": ProductionConfigService,"
Title,};
Title,@Module({
Title,"providers: [configServiceProvider],"
Title,})
Title,export class AppModule {}
Title,```
Title,"Let's look at a couple of details in this code sample. You'll notice that we define configServiceProvider with a literal object first, then pass it in the module decorator's providers property. This is just a bit of code organization, but is functionally equivalent to the examples we've used thus far in this chapter."
Title,"Also, we have used the ConfigService class name as our token. For any class that depends on ConfigService, Nest will inject an instance of the provided class (DevelopmentConfigService or ProductionConfigService) overriding any default implementation that may have been declared elsewhere (e.g., a ConfigService declared with an @Injectable() decorator)."
Title,Factory providers: useFactory
Title,"The useFactory syntax allows for creating providers dynamically. The actual provider will be supplied by the value returned from a factory function. The factory function can be as simple or complex as needed. A simple factory may not depend on any other providers. A more complex factory can itself inject other providers it needs to compute its result. For the latter case, the factory provider syntax has a pair of related mechanisms:"
Title,
Title,The factory function can accept (optional) arguments.
Title,"The (optional) inject property accepts an array of providers that Nest will resolve and pass as arguments to the factory function during the instantiation process. Also, these providers can be marked as optional. The two lists should be correlated: Nest will pass instances from the inject list as arguments to the factory function in the same order. The example below demonstrates this."
Title,
Title,``typescript
Title,@@filename()
Title,const connectionProvider = {
Title,"provide: 'CONNECTION',"
Title,"useFactory: (optionsProvider: MyOptionsProvider, optionalProvider?: string) => {"
Title,const options = optionsProvider.get();
Title,return new DatabaseConnection(options);
Title,"},"
Title,"inject: [MyOptionsProvider, { token: 'SomeOptionalProvider', optional: true }],"
Title,//       \______________/             \__________________/
Title,//        This provider                The provider with this token
Title,//        is mandatory.                can resolve toundefined`.
Title,};
Title,@Module({
Title,providers: [
Title,"connectionProvider,"
Title,"MyOptionsProvider, // class-based provider"
Title,"// { provide: 'SomeOptionalProvider', useValue: 'anything' },"
Title,"],"
Title,})
Title,export class AppModule {}
Title,@@switch
Title,const connectionProvider = {
Title,"provide: 'CONNECTION',"
Title,"useFactory: (optionsProvider, optionalProvider) => {"
Title,const options = optionsProvider.get();
Title,return new DatabaseConnection(options);
Title,"},"
Title,"inject: [MyOptionsProvider, { token: 'SomeOptionalProvider', optional: true }],"
Title,//       ____/            ____/
Title,//        This provider               The provider with this token
Title,//        is mandatory.               can resolve to undefined.
Title,};
Title,@Module({
Title,providers: [
Title,"connectionProvider,"
Title,"MyOptionsProvider, // class-base provider"
Title,"// { provide: 'SomeOptionalProvider', useValue: 'anything' },"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,Alias providers: useExisting
Title,"The useExisting syntax allows you to create aliases for existing providers. This creates two ways to access the same provider. In the example below, the (string-based) token 'AliasedLoggerService' is an alias for the (class-based) token LoggerService. Assume we have two different dependencies, one for 'AliasedLoggerService' and one for LoggerService. If both dependencies are specified with SINGLETON scope, they'll both resolve to the same instance."
Title,```typescript
Title,@Injectable()
Title,class LoggerService {
Title,/ implementation details /
Title,}
Title,const loggerAliasProvider = {
Title,"provide: 'AliasedLoggerService',"
Title,"useExisting: LoggerService,"
Title,};
Title,@Module({
Title,"providers: [LoggerService, loggerAliasProvider],"
Title,})
Title,export class AppModule {}
Title,```
Title,Non-service based providers
Title,"While providers often supply services, they are not limited to that usage. A provider can supply any value. For example, a provider may supply an array of configuration objects based on the current environment, as shown below:"
Title,```typescript
Title,const configFactory = {
Title,"provide: 'CONFIG',"
Title,useFactory: () => {
Title,return process.env.NODE_ENV === 'development' ? devConfig : prodConfig;
Title,"},"
Title,};
Title,@Module({
Title,"providers: [configFactory],"
Title,})
Title,export class AppModule {}
Title,```
Title,Export custom provider
Title,"Like any provider, a custom provider is scoped to its declaring module. To make it visible to other modules, it must be exported. To export a custom provider, we can either use its token or the full provider object."
Title,The following example shows exporting using the token:
Title,```typescript
Title,@@filename()
Title,const connectionFactory = {
Title,"provide: 'CONNECTION',"
Title,useFactory: (optionsProvider: OptionsProvider) => {
Title,const options = optionsProvider.get();
Title,return new DatabaseConnection(options);
Title,"},"
Title,"inject: [OptionsProvider],"
Title,};
Title,@Module({
Title,"providers: [connectionFactory],"
Title,"exports: ['CONNECTION'],"
Title,})
Title,export class AppModule {}
Title,@@switch
Title,const connectionFactory = {
Title,"provide: 'CONNECTION',"
Title,useFactory: (optionsProvider) => {
Title,const options = optionsProvider.get();
Title,return new DatabaseConnection(options);
Title,"},"
Title,"inject: [OptionsProvider],"
Title,};
Title,@Module({
Title,"providers: [connectionFactory],"
Title,"exports: ['CONNECTION'],"
Title,})
Title,export class AppModule {}
Title,```
Title,"Alternatively, export with the full provider object:"
Title,```typescript
Title,@@filename()
Title,const connectionFactory = {
Title,"provide: 'CONNECTION',"
Title,useFactory: (optionsProvider: OptionsProvider) => {
Title,const options = optionsProvider.get();
Title,return new DatabaseConnection(options);
Title,"},"
Title,"inject: [OptionsProvider],"
Title,};
Title,@Module({
Title,"providers: [connectionFactory],"
Title,"exports: [connectionFactory],"
Title,})
Title,export class AppModule {}
Title,@@switch
Title,const connectionFactory = {
Title,"provide: 'CONNECTION',"
Title,useFactory: (optionsProvider) => {
Title,const options = optionsProvider.get();
Title,return new DatabaseConnection(options);
Title,"},"
Title,"inject: [OptionsProvider],"
Title,};
Title,@Module({
Title,"providers: [connectionFactory],"
Title,"exports: [connectionFactory],"
Title,})
Title,export class AppModule {}
Title,```
Title,
Title,Dynamic modules
Title,"The Modules chapter covers the basics of Nest modules, and includes a brief introduction to dynamic modules. This chapter expands on the subject of dynamic modules. Upon completion, you should have a good grasp of what they are and how and when to use them."
Title,Introduction
Title,"Most application code examples in the Overview section of the documentation make use of regular, or static, modules. Modules define groups of components like providers and controllers that fit together as a modular part of an overall application. They provide an execution context, or scope, for these components. For example, providers defined in a module are visible to other members of the module without the need to export them. When a provider needs to be visible outside of a module, it is first exported from its host module, and then imported into its consuming module."
Title,Let's walk through a familiar example.
Title,"First, we'll define a UsersModule to provide and export a UsersService. UsersModule is the host module for UsersService."
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { UsersService } from './users.service';
Title,@Module({
Title,"providers: [UsersService],"
Title,"exports: [UsersService],"
Title,})
Title,export class UsersModule {}
Title,```
Title,"Next, we'll define an AuthModule, which imports UsersModule, making UsersModule's exported providers available inside AuthModule:"
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { AuthService } from './auth.service';
Title,import { UsersModule } from '../users/users.module';
Title,@Module({
Title,"imports: [UsersModule],"
Title,"providers: [AuthService],"
Title,"exports: [AuthService],"
Title,})
Title,export class AuthModule {}
Title,```
Title,"These constructs allow us to inject UsersService in, for example, the AuthService that is hosted in AuthModule:"
Title,```typescript
Title,import { Injectable } from '@nestjs/common';
Title,import { UsersService } from '../users/users.service';
Title,@Injectable()
Title,export class AuthService {
Title,constructor(private usersService: UsersService) {}
Title,/
Title,Implementation that makes use of this.usersService
Title,/
Title,}
Title,```
Title,We'll refer to this as static module binding. All the information Nest needs to wire together the modules has already been declared in the host and consuming modules. Let's unpack what's happening during this process. Nest makes UsersService available inside AuthModule by:
Title,
Title,"Instantiating UsersModule, including transitively importing other modules that UsersModule itself consumes, and transitively resolving any dependencies (see Custom providers)."
Title,"Instantiating AuthModule, and making UsersModule's exported providers available to components in AuthModule (just as if they had been declared in AuthModule)."
Title,Injecting an instance of UsersService in AuthService.
Title,
Title,Dynamic module use case
Title,"With static module binding, there's no opportunity for the consuming module to influence how providers from the host module are configured. Why does this matter? Consider the case where we have a general purpose module that needs to behave differently in different use cases. This is analogous to the concept of a ""plugin"" in many systems, where a generic facility requires some configuration before it can be used by a consumer."
Title,"A good example with Nest is a configuration module. Many applications find it useful to externalize configuration details by using a configuration module. This makes it easy to dynamically change the application settings in different deployments: e.g., a development database for developers, a staging database for the staging/testing environment, etc. By delegating the management of configuration parameters to a configuration module, the application source code remains independent of configuration parameters."
Title,"The challenge is that the configuration module itself, since it's generic (similar to a ""plugin""), needs to be customized by its consuming module. This is where dynamic modules come into play. Using dynamic module features, we can make our configuration module dynamic so that the consuming module can use an API to control how the configuration module is customized at the time it is imported."
Title,"In other words, dynamic modules provide an API for importing one module into another, and customizing the properties and behavior of that module when it is imported, as opposed to using the static bindings we've seen so far."
Title,
Title,Config module example
Title,We'll be using the basic version of the example code from the configuration chapter for this section. The completed version as of the end of this chapter is available as a working example here.
Title,"Our requirement is to make ConfigModule accept an options object to customize it. Here's the feature we want to support. The basic sample hard-codes the location of the .env file to be in the project root folder. Let's suppose we want to make that configurable, such that you can manage your .env files in any folder of your choosing. For example, imagine you want to store your various .env files in a folder under the project root called config (i.e., a sibling folder to src). You'd like to be able to choose different folders when using the ConfigModule in different projects."
Title,"Dynamic modules give us the ability to pass parameters into the module being imported so we can change its behavior. Let's see how this works. It's helpful if we start from the end-goal of how this might look from the consuming module's perspective, and then work backwards. First, let's quickly review the example of statically importing the ConfigModule (i.e., an approach which has no ability to influence the behavior of the imported module). Pay close attention to the imports array in the @Module() decorator:"
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { AppController } from './app.controller';
Title,import { AppService } from './app.service';
Title,import { ConfigModule } from './config/config.module';
Title,@Module({
Title,"imports: [ConfigModule],"
Title,"controllers: [AppController],"
Title,"providers: [AppService],"
Title,})
Title,export class AppModule {}
Title,```
Title,"Let's consider what a dynamic module import, where we're passing in a configuration object, might look like. Compare the difference in the imports array between these two examples:"
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { AppController } from './app.controller';
Title,import { AppService } from './app.service';
Title,import { ConfigModule } from './config/config.module';
Title,@Module({
Title,"imports: [ConfigModule.register({ folder: './config' })],"
Title,"controllers: [AppController],"
Title,"providers: [AppService],"
Title,})
Title,export class AppModule {}
Title,```
Title,Let's see what's happening in the dynamic example above. What are the moving parts?
Title,
Title,"ConfigModule is a normal class, so we can infer that it must have a static method called register(). We know it's static because we're calling it on the ConfigModule class, not on an instance of the class. Note: this method, which we will create soon, can have any arbitrary name, but by convention we should call it either forRoot() or register()."
Title,"The register() method is defined by us, so we can accept any input arguments we like. In this case, we're going to accept a simple options object with suitable properties, which is the typical case."
Title,"We can infer that the register() method must return something like a module since its return value appears in the familiar imports list, which we've seen so far includes a list of modules."
Title,
Title,"In fact, what our register() method will return is a DynamicModule. A dynamic module is nothing more than a module created at run-time, with the same exact properties as a static module, plus one additional property called module. Let's quickly review a sample static module declaration, paying close attention to the module options passed in to the decorator:"
Title,typescript
Title,@Module({
Title,"imports: [DogsModule],"
Title,"controllers: [CatsController],"
Title,"providers: [CatsService],"
Title,exports: [CatsService]
Title,})
Title,"Dynamic modules must return an object with the exact same interface, plus one additional property called module. The module property serves as the name of the module, and should be the same as the class name of the module, as shown in the example below."
Title,
Title,"info Hint For a dynamic module, all properties of the module options object are optional except module."
Title,
Title,"What about the static register() method? We can now see that its job is to return an object that has the DynamicModule interface. When we call it, we are effectively providing a module to the imports list, similar to the way we would do so in the static case by listing a module class name. In other words, the dynamic module API simply returns a module, but rather than fix the properties in the @Module decorator, we specify them programmatically."
Title,There are still a couple of details to cover to help make the picture complete:
Title,
Title,"We can now state that the @Module() decorator's imports property can take not only a module class name (e.g., imports: [UsersModule]), but also a function returning a dynamic module (e.g., imports: [ConfigModule.register(...)])."
Title,"A dynamic module can itself import other modules. We won't do so in this example, but if the dynamic module depends on providers from other modules, you would import them using the optional imports property. Again, this is exactly analogous to the way you'd declare metadata for a static module using the @Module() decorator."
Title,
Title,"Armed with this understanding, we can now look at what our dynamic ConfigModule declaration must look like. Let's take a crack at it."
Title,```typescript
Title,"import { DynamicModule, Module } from '@nestjs/common';"
Title,import { ConfigService } from './config.service';
Title,@Module({})
Title,export class ConfigModule {
Title,static register(): DynamicModule {
Title,return {
Title,"module: ConfigModule,"
Title,"providers: [ConfigService],"
Title,"exports: [ConfigService],"
Title,};
Title,}
Title,}
Title,```
Title,"It should now be clear how the pieces tie together. Calling ConfigModule.register(...) returns a DynamicModule object with properties which are essentially the same as those that, until now, we've provided as metadata via the @Module() decorator."
Title,
Title,info Hint Import DynamicModule from @nestjs/common.
Title,
Title,"Our dynamic module isn't very interesting yet, however, as we haven't introduced any capability to configure it as we said we would like to do. Let's address that next."
Title,Module configuration
Title,"The obvious solution for customizing the behavior of the ConfigModule is to pass it an options object in the static register() method, as we guessed above. Let's look once again at our consuming module's imports property:"
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { AppController } from './app.controller';
Title,import { AppService } from './app.service';
Title,import { ConfigModule } from './config/config.module';
Title,@Module({
Title,"imports: [ConfigModule.register({ folder: './config' })],"
Title,"controllers: [AppController],"
Title,"providers: [AppService],"
Title,})
Title,export class AppModule {}
Title,```
Title,"That nicely handles passing an options object to our dynamic module. How do we then use that options object in the ConfigModule? Let's consider that for a minute. We know that our ConfigModule is basically a host for providing and exporting an injectable service - the ConfigService - for use by other providers. It's actually our ConfigService that needs to read the options object to customize its behavior. Let's assume for the moment that we know how to somehow get the options from the register() method into the ConfigService. With that assumption, we can make a few changes to the service to customize its behavior based on the properties from the options object. (Note: for the time being, since we haven't actually determined how to pass it in, we'll just hard-code options. We'll fix this in a minute)."
Title,```typescript
Title,import { Injectable } from '@nestjs/common';
Title,import * as dotenv from 'dotenv';
Title,import * as fs from 'fs';
Title,import * as path from 'path';
Title,import { EnvConfig } from './interfaces';
Title,@Injectable()
Title,export class ConfigService {
Title,private readonly envConfig: EnvConfig;
Title,constructor() {
Title,const options = { folder: './config' };
Title,const filePath = `${process.env.NODE_ENV || 'development'}.env`;
Title,"const envFile = path.resolve(__dirname, '../../', options.folder, filePath);"
Title,this.envConfig = dotenv.parse(fs.readFileSync(envFile));
Title,
Title,}
Title,get(key: string): string {
Title,return this.envConfig[key];
Title,}
Title,}
Title,```
Title,Now our ConfigService knows how to find the .env file in the folder we've specified in options.
Title,"Our remaining task is to somehow inject the options object from the register() step into our ConfigService. And of course, we'll use dependency injection to do it. This is a key point, so make sure you understand it. Our ConfigModule is providing ConfigService. ConfigService in turn depends on the options object that is only supplied at run-time. So, at run-time, we'll need to first bind the options object to the Nest IoC container, and then have Nest inject it into our ConfigService. Remember from the Custom providers chapter that providers can include any value not just services, so we're fine using dependency injection to handle a simple options object."
Title,"Let's tackle binding the options object to the IoC container first. We do this in our static register() method. Remember that we are dynamically constructing a module, and one of the properties of a module is its list of providers. So what we need to do is define our options object as a provider. This will make it injectable into the ConfigService, which we'll take advantage of in the next step. In the code below, pay attention to the providers array:"
Title,```typescript
Title,"import { DynamicModule, Module } from '@nestjs/common';"
Title,import { ConfigService } from './config.service';
Title,@Module({})
Title,export class ConfigModule {
Title,static register(options: Record): DynamicModule {
Title,return {
Title,"module: ConfigModule,"
Title,providers: [
Title,{
Title,"provide: 'CONFIG_OPTIONS',"
Title,"useValue: options,"
Title,"},"
Title,"ConfigService,"
Title,"],"
Title,"exports: [ConfigService],"
Title,};
Title,}
Title,}
Title,```
Title,Now we can complete the process by injecting the 'CONFIG_OPTIONS' provider into the ConfigService. Recall that when we define a provider using a non-class token we need to use the @Inject() decorator as described here.
Title,```typescript
Title,import * as dotenv from 'dotenv';
Title,import * as fs from 'fs';
Title,import * as path from 'path';
Title,"import { Injectable, Inject } from '@nestjs/common';"
Title,import { EnvConfig } from './interfaces';
Title,@Injectable()
Title,export class ConfigService {
Title,private readonly envConfig: EnvConfig;
Title,constructor(@Inject('CONFIG_OPTIONS') private options: Record) {
Title,const filePath = ${process.env.NODE_ENV || 'development'}.env;
Title,"const envFile = path.resolve(__dirname, '../../', options.folder, filePath);"
Title,this.envConfig = dotenv.parse(fs.readFileSync(envFile));
Title,}
Title,get(key: string): string {
Title,return this.envConfig[key];
Title,}
Title,}
Title,```
Title,"One final note: for simplicity we used a string-based injection token ('CONFIG_OPTIONS') above, but best practice is to define it as a constant (or Symbol) in a separate file, and import that file. For example:"
Title,typescript
Title,export const CONFIG_OPTIONS = 'CONFIG_OPTIONS';
Title,Example
Title,A full example of the code in this chapter can be found here.
Title,Community guidelines
Title,"You may have seen the use for methods like forRoot, register, and forFeature around some of the @nestjs/ packages and may be wondering what the difference for all of these methods are. There is no hard rule about this, but the @nestjs/ packages try to follow these guidelines:"
Title,When creating a module with:
Title,
Title,
Title,"register, you are expecting to configure a dynamic module with a specific configuration for use only by the calling module. For example, with Nest's @nestjs/axios: HttpModule.register({{ '{' }} baseUrl: 'someUrl' {{ '}' }}). If, in another module you use HttpModule.register({{ '{' }} baseUrl: 'somewhere else' {{ '}' }}), it will have the different configuration. You can do this for as many modules as you want."
Title,
Title,
Title,"forRoot, you are expecting to configure a dynamic module once and reuse that configuration in multiple places (though possibly unknowingly as it's abstracted away). This is why you have one GraphQLModule.forRoot(), one TypeOrmModule.forRoot(), etc."
Title,
Title,
Title,"forFeature, you are expecting to use the configuration of a dynamic module's forRoot but need to modify some configuration specific to the calling module's needs (i.e. which repository this module should have access to, or the context that a logger should use.)"
Title,
Title,
Title,"All of these, usually, have their async counterparts as well, registerAsync, forRootAsync, and forFeatureAsync, that mean the same thing, but use Nest's Dependency Injection for the configuration as well."
Title,Configurable module builder
Title,"As manually creating highly configurable, dynamic modules that expose async methods (registerAsync, forRootAsync, etc.) is quite complicated, especially for newcomers, Nest exposes the ConfigurableModuleBuilder class that facilitates this process and lets you construct a module ""blueprint"" in just a few lines of code."
Title,"For example, let's take the example we used above (ConfigModule) and convert it to use the ConfigurableModuleBuilder. Before we start, let's make sure we create a dedicated interface that represents what options our ConfigModule takes in."
Title,typescript
Title,export interface ConfigModuleOptions {
Title,folder: string;
Title,}
Title,"With this in place, create a new dedicated file (alongside the existing config.module.ts file) and name it config.module-definition.ts. In this file, let's utilize the ConfigurableModuleBuilder to construct ConfigModule definition."
Title,```typescript
Title,@@filename(config.module-definition)
Title,import { ConfigurableModuleBuilder } from '@nestjs/common';
Title,import { ConfigModuleOptions } from './interfaces/config-module-options.interface';
Title,"export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } ="
Title,new ConfigurableModuleBuilder().build();
Title,@@switch
Title,import { ConfigurableModuleBuilder } from '@nestjs/common';
Title,"export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } ="
Title,new ConfigurableModuleBuilder().build();
Title,```
Title,Now let's open up the config.module.ts file and modify its implementation to leverage the auto-generated ConfigurableModuleClass:
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { ConfigService } from './config.service';
Title,import { ConfigurableModuleClass } from './config.module-definition';
Title,@Module({
Title,"providers: [ConfigService],"
Title,"exports: [ConfigService],"
Title,})
Title,export class ConfigModule extends ConfigurableModuleClass {}
Title,```
Title,"Extending the ConfigurableModuleClass means that ConfigModule provides now not only the register method (as previously with the custom implementation), but also the registerAsync method which allows consumers asynchronously configure that module, for example, by supplying async factories:"
Title,typescript
Title,@Module({
Title,imports: [
Title,"ConfigModule.register({ folder: './config' }),"
Title,// or alternatively:
Title,// ConfigModule.registerAsync({
Title,//   useFactory: () => {
Title,//     return {
Title,"//       folder: './config',"
Title,//     }
Title,"//   },"
Title,//   inject: [...any extra dependencies...]
Title,"// }),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,"Lastly, let's update the ConfigService class to inject the generated module options' provider instead of the 'CONFIG_OPTIONS' that we used so far."
Title,typescript
Title,@Injectable()
Title,export class ConfigService {
Title,constructor(@Inject(MODULE_OPTIONS_TOKEN) private options: ConfigModuleOptions) { ... }
Title,}
Title,Custom method key
Title,"ConfigurableModuleClass by default provides the register and its counterpart registerAsync methods. To use a different method name, use the ConfigurableModuleBuilder#setClassMethodName method, as follows:"
Title,typescript
Title,@@filename(config.module-definition)
Title,"export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } ="
Title,new ConfigurableModuleBuilder<ConfigModuleOptions>().setClassMethodName('forRoot').build();
Title,@@switch
Title,"export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } ="
Title,new ConfigurableModuleBuilder().setClassMethodName('forRoot').build();
Title,This construction will instruct ConfigurableModuleBuilder to generate a class that exposes forRoot and forRootAsync instead. Example:
Title,typescript
Title,@Module({
Title,imports: [
Title,"ConfigModule.forRoot({ folder: './config' }), // <-- note the use of ""forRoot"" instead of ""register"""
Title,// or alternatively:
Title,// ConfigModule.forRootAsync({
Title,//   useFactory: () => {
Title,//     return {
Title,"//       folder: './config',"
Title,//     }
Title,"//   },"
Title,//   inject: [...any extra dependencies...]
Title,"// }),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,Custom options factory class
Title,"Since the registerAsync method (or forRootAsync or any other name, depending on the configuration) lets consumer pass a provider definition that resolves to the module configuration, a library consumer could potentially supply a class to be used to construct the configuration object."
Title,typescript
Title,@Module({
Title,imports: [
Title,ConfigModule.registerAsync({
Title,"useClass: ConfigModuleOptionsFactory,"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,"This class, by default, must provide the create() method that returns a module configuration object. However, if your library follows a different naming convention, you can change that behavior and instruct ConfigurableModuleBuilder to expect a different method, for example, createConfigOptions, using the ConfigurableModuleBuilder#setFactoryMethodName method:"
Title,typescript
Title,@@filename(config.module-definition)
Title,"export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } ="
Title,new ConfigurableModuleBuilder<ConfigModuleOptions>().setFactoryMethodName('createConfigOptions').build();
Title,@@switch
Title,"export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } ="
Title,new ConfigurableModuleBuilder().setFactoryMethodName('createConfigOptions').build();
Title,"Now, ConfigModuleOptionsFactory class must expose the createConfigOptions method (instead of create):"
Title,typescript
Title,@Module({
Title,imports: [
Title,ConfigModule.registerAsync({
Title,"useClass: ConfigModuleOptionsFactory, // <-- this class must provide the ""createConfigOptions"" method"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,Extra options
Title,"There are edge-cases when your module may need to take extra options that determine how it is supposed to behave (a nice example of such an option is the isGlobal flag - or just global) that at the same time, shouldn't be included in the MODULE_OPTIONS_TOKEN provider (as they are irrelevant to services/providers registered within that module, for example, ConfigService does not need to know whether its host module is registered as a global module)."
Title,"In such cases, the ConfigurableModuleBuilder#setExtras method can be used. See the following example:"
Title,typescript
Title,"export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } = new ConfigurableModuleBuilder<ConfigModuleOptions>()"
Title,.setExtras(
Title,{
Title,"isGlobal: true,"
Title,"},"
Title,"(definition, extras) => ({"
Title,"...definition,"
Title,"global: extras.isGlobal,"
Title,"}),"
Title,)
Title,.build();
Title,"In the example above, the first argument passed into the setExtras method is an object containing default values for the ""extra"" properties. The second argument is a function that takes an auto-generated module definitions (with provider, exports, etc.) and extras object which represents extra properties (either specified by the consumer or defaults). The returned value of this function is a modified module definition. In this specific example, we're taking the extras.isGlobal property and assigning it to the global property of the module definition (which in turn determines whether a module is global or not, read more here)."
Title,"Now when consuming this module, the additional isGlobal flag can be passed in, as follows:"
Title,typescript
Title,@Module({
Title,imports: [
Title,ConfigModule.register({
Title,"isGlobal: true,"
Title,"folder: './config',"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,"However, since isGlobal is declared as an ""extra"" property, it won't be available in the MODULE_OPTIONS_TOKEN provider:"
Title,typescript
Title,@Injectable()
Title,export class ConfigService {
Title,constructor(@Inject(MODULE_OPTIONS_TOKEN) private options: ConfigModuleOptions) {
Title,"// ""options"" object will not have the ""isGlobal"" property"
Title,// ...
Title,}
Title,}
Title,Extending auto-generated methods
Title,"The auto-generated static methods (register, registerAsync, etc.) can be extended if needed, as follows:"
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { ConfigService } from './config.service';
Title,"import { ConfigurableModuleClass, ASYNC_OPTIONS_TYPE, OPTIONS_TYPE } from './config.module-definition';"
Title,@Module({
Title,"providers: [ConfigService],"
Title,"exports: [ConfigService],"
Title,})
Title,export class ConfigModule extends ConfigurableModuleClass {
Title,static register(options: typeof OPTIONS_TYPE): DynamicModule {
Title,return {
Title,// your custom logic here
Title,"...super.register(options),"
Title,};
Title,}
Title,static registerAsync(options: typeof ASYNC_OPTIONS_TYPE): DynamicModule {
Title,return {
Title,// your custom logic here
Title,"...super.registerAsync(options),"
Title,};
Title,}
Title,}
Title,```
Title,Note the use of OPTIONS_TYPE and ASYNC_OPTIONS_TYPE types that must be exported from the module definition file:
Title,typescript
Title,"export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN, OPTIONS_TYPE, ASYNC_OPTIONS_TYPE } = new ConfigurableModuleBuilder<ConfigModuleOptions>().build();"
Title,
Title,Execution context
Title,"Nest provides several utility classes that help make it easy to write applications that function across multiple application contexts (e.g., Nest HTTP server-based, microservices and WebSockets application contexts). These utilities provide information about the current execution context which can be used to build generic guards, filters, and interceptors that can work across a broad set of controllers, methods, and execution contexts."
Title,We cover two such classes in this chapter: ArgumentsHost and ExecutionContext.
Title,ArgumentsHost class
Title,"The ArgumentsHost class provides methods for retrieving the arguments being passed to a handler. It allows choosing the appropriate context (e.g., HTTP, RPC (microservice), or WebSockets) to retrieve the arguments from. The framework provides an instance of ArgumentsHost, typically referenced as a host parameter, in places where you may want to access it. For example, the catch() method of an exception filter is called with an ArgumentsHostinstance."
Title,"ArgumentsHost simply acts as an abstraction over a handler's arguments. For example, for HTTP server applications (when @nestjs/platform-express is being used), the host object encapsulates Express's [request, response, next] array, where request is the request object, response is the response object, and next is a function that controls the application's request-response cycle. On the other hand, for GraphQL applications, the host object contains the [root, args, context, info] array."
Title,Current application context
Title,"When building generic guards, filters, and interceptors which are meant to run across multiple application contexts, we need a way to determine the type of application that our method is currently running in. Do this with the getType() method of ArgumentsHost:"
Title,typescript
Title,if (host.getType() === 'http') {
Title,// do something that is only important in the context of regular HTTP requests (REST)
Title,} else if (host.getType() === 'rpc') {
Title,// do something that is only important in the context of Microservice requests
Title,} else if (host.getType<GqlContextType>() === 'graphql') {
Title,// do something that is only important in the context of GraphQL requests
Title,}
Title,
Title,info Hint The GqlContextType is imported from the @nestjs/graphql package.
Title,
Title,"With the application type available, we can write more generic components, as shown below."
Title,Host handler arguments
Title,"To retrieve the array of arguments being passed to the handler, one approach is to use the host object's getArgs() method."
Title,typescript
Title,"const [req, res, next] = host.getArgs();"
Title,You can pluck a particular argument by index using the getArgByIndex() method:
Title,typescript
Title,const request = host.getArgByIndex(0);
Title,const response = host.getArgByIndex(1);
Title,"In these examples we retrieved the request and response objects by index, which is not typically recommended as it couples the application to a particular execution context. Instead, you can make your code more robust and reusable by using one of the host object's utility methods to switch to the appropriate application context for your application. The context switch utility methods are shown below."
Title,typescript
Title,/**
Title,* Switch context to RPC.
Title,*/
Title,switchToRpc(): RpcArgumentsHost;
Title,/**
Title,* Switch context to HTTP.
Title,*/
Title,switchToHttp(): HttpArgumentsHost;
Title,/**
Title,* Switch context to WebSockets.
Title,*/
Title,switchToWs(): WsArgumentsHost;
Title,Let's rewrite the previous example using the switchToHttp() method. The host.switchToHttp() helper call returns an HttpArgumentsHost object that is appropriate for the HTTP application context. The HttpArgumentsHost object has two useful methods we can use to extract the desired objects. We also use the Express type assertions in this case to return native Express typed objects:
Title,typescript
Title,const ctx = host.switchToHttp();
Title,const request = ctx.getRequest<Request>();
Title,const response = ctx.getResponse<Response>();
Title,Similarly WsArgumentsHost and RpcArgumentsHost have methods to return appropriate objects in the microservices and WebSockets contexts. Here are the methods for WsArgumentsHost:
Title,typescript
Title,export interface WsArgumentsHost {
Title,/**
Title,* Returns the data object.
Title,*/
Title,getData<T>(): T;
Title,/**
Title,* Returns the client object.
Title,*/
Title,getClient<T>(): T;
Title,}
Title,Following are the methods for RpcArgumentsHost:
Title,```typescript
Title,export interface RpcArgumentsHost {
Title,/*
Title,* Returns the data object.
Title,/
Title,getData(): T;
Title,/*
Title,* Returns the context object.
Title,/
Title,getContext(): T;
Title,}
Title,```
Title,ExecutionContext class
Title,"ExecutionContext extends ArgumentsHost, providing additional details about the current execution process. Like ArgumentsHost, Nest provides an instance of ExecutionContext in places you may need it, such as in the canActivate() method of a guard and the intercept() method of an interceptor. It provides the following methods:"
Title,typescript
Title,export interface ExecutionContext extends ArgumentsHost {
Title,/**
Title,* Returns the type of the controller class which the current handler belongs to.
Title,*/
Title,getClass<T>(): Type<T>;
Title,/**
Title,* Returns a reference to the handler (method) that will be invoked next in the
Title,* request pipeline.
Title,*/
Title,getHandler(): Function;
Title,}
Title,"The getHandler() method returns a reference to the handler about to be invoked. The getClass() method returns the type of the Controller class which this particular handler belongs to. For example, in an HTTP context, if the currently processed request is a POST request, bound to the create() method on the CatsController, getHandler() returns a reference to the create() method and getClass() returns the CatsController class (not instance)."
Title,typescript
Title,"const methodKey = ctx.getHandler().name; // ""create"""
Title,"const className = ctx.getClass().name; // ""CatsController"""
Title,"The ability to access references to both the current class and handler method provides great flexibility. Most importantly, it gives us the opportunity to access the metadata set through either decorators created via Reflector#createDecorator or the built-in @SetMetadata() decorator from within guards or interceptors. We cover this use case below."
Title,
Title,Reflection and metadata
Title,"Nest provides the ability to attach custom metadata to route handlers through decorators created via Reflector#createDecorator method, and the built-in @SetMetadata() decorator. In this section, let's compare the two approaches and see how to access the metadata from within a guard or interceptor."
Title,"To create strongly-typed decorators using Reflector#createDecorator, we need to specify the type argument. For example, let's create a Roles decorator that takes an array of strings as an argument."
Title,```ts
Title,@@filename(roles.decorator)
Title,import { Reflector } from '@nestjs/core';
Title,export const Roles = Reflector.createDecorator();
Title,```
Title,The Roles decorator here is a function that takes a single argument of type string[].
Title,"Now, to use this decorator, we simply annotate the handler with it:"
Title,typescript
Title,@@filename(cats.controller)
Title,@Post()
Title,@Roles(['admin'])
Title,async create(@Body() createCatDto: CreateCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,@@switch
Title,@Post()
Title,@Roles(['admin'])
Title,@Bind(Body())
Title,async create(createCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,"Here we've attached the Roles decorator metadata to the create() method, indicating that only users with the admin role should be allowed to access this route."
Title,"To access the route's role(s) (custom metadata), we'll use the Reflector helper class again. Reflector can be injected into a class in the normal way:"
Title,typescript
Title,@@filename(roles.guard)
Title,@Injectable()
Title,export class RolesGuard {
Title,constructor(private reflector: Reflector) {}
Title,}
Title,@@switch
Title,@Injectable()
Title,@Dependencies(Reflector)
Title,export class CatsService {
Title,constructor(reflector) {
Title,this.reflector = reflector;
Title,}
Title,}
Title,
Title,info Hint The Reflector class is imported from the @nestjs/core package.
Title,
Title,"Now, to read the handler metadata, use the get() method:"
Title,typescript
Title,"const roles = this.reflector.get(Roles, context.getHandler());"
Title,"The Reflector#get method allows us to easily access the metadata by passing in two arguments: a decorator reference and a context (decorator target) to retrieve the metadata from. In this example, the specified decorator is Roles (refer back to the roles.decorator.ts file above). The context is provided by the call to context.getHandler(), which results in extracting the metadata for the currently processed route handler. Remember, getHandler() gives us a reference to the route handler function."
Title,"Alternatively, we may organize our controller by applying metadata at the controller level, applying to all routes in the controller class."
Title,typescript
Title,@@filename(cats.controller)
Title,@Roles(['admin'])
Title,@Controller('cats')
Title,export class CatsController {}
Title,@@switch
Title,@Roles(['admin'])
Title,@Controller('cats')
Title,export class CatsController {}
Title,"In this case, to extract controller metadata, we pass context.getClass() as the second argument (to provide the controller class as the context for metadata extraction) instead of context.getHandler():"
Title,typescript
Title,@@filename(roles.guard)
Title,"const roles = this.reflector.get(Roles, context.getClass());"
Title,"Given the ability to provide metadata at multiple levels, you may need to extract and merge metadata from several contexts. The Reflector class provides two utility methods used to help with this. These methods extract both controller and method metadata at once, and combine them in different ways."
Title,"Consider the following scenario, where you've supplied Roles metadata at both levels."
Title,typescript
Title,@@filename(cats.controller)
Title,@Roles(['user'])
Title,@Controller('cats')
Title,export class CatsController {
Title,@Post()
Title,@Roles(['admin'])
Title,async create(@Body() createCatDto: CreateCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,}
Title,@@switch
Title,@Roles(['user'])
Title,@Controller('cats')
Title,export class CatsController {}
Title,@Post()
Title,@Roles(['admin'])
Title,@Bind(Body())
Title,async create(createCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,}
Title,"If your intent is to specify 'user' as the default role, and override it selectively for certain methods, you would probably use the getAllAndOverride() method."
Title,typescript
Title,"const roles = this.reflector.getAllAndOverride(Roles, [context.getHandler(), context.getClass()]);"
Title,"A guard with this code, running in the context of the create() method, with the above metadata, would result in roles containing ['admin']."
Title,"To get metadata for both and merge it (this method merges both arrays and objects), use the getAllAndMerge() method:"
Title,typescript
Title,"const roles = this.reflector.getAllAndMerge(Roles, [context.getHandler(), context.getClass()]);"
Title,"This would result in roles containing ['user', 'admin']."
Title,"For both of these merge methods, you pass the metadata key as the first argument, and an array of metadata target contexts (i.e., calls to the getHandler() and/or getClass() methods) as the second argument."
Title,Low-level approach
Title,"As mentioned earlier, instead of using Reflector#createDecorator, you can also use the built-in @SetMetadata() decorator to attach metadata to a handler."
Title,typescript
Title,@@filename(cats.controller)
Title,@Post()
Title,"@SetMetadata('roles', ['admin'])"
Title,async create(@Body() createCatDto: CreateCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,@@switch
Title,@Post()
Title,"@SetMetadata('roles', ['admin'])"
Title,@Bind(Body())
Title,async create(createCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,
Title,info Hint The @SetMetadata() decorator is imported from the @nestjs/common package.
Title,
Title,"With the construction above, we attached the roles metadata (roles is a metadata key and ['admin'] is the associated value) to the create() method. While this works, it's not good practice to use @SetMetadata() directly in your routes. Instead, you can create your own decorators, as shown below:"
Title,```typescript
Title,@@filename(roles.decorator)
Title,import { SetMetadata } from '@nestjs/common';
Title,"export const Roles = (...roles: string[]) => SetMetadata('roles', roles);"
Title,@@switch
Title,import { SetMetadata } from '@nestjs/common';
Title,"export const Roles = (...roles) => SetMetadata('roles', roles);"
Title,```
Title,"This approach is much cleaner and more readable, and somewhat resembles the Reflector#createDecorator approach. The difference is that with @SetMetadata you have more control over the metadata key and value, and also can create decorators that take more than one argument."
Title,"Now that we have a custom @Roles() decorator, we can use it to decorate the create() method."
Title,typescript
Title,@@filename(cats.controller)
Title,@Post()
Title,@Roles('admin')
Title,async create(@Body() createCatDto: CreateCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,@@switch
Title,@Post()
Title,@Roles('admin')
Title,@Bind(Body())
Title,async create(createCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,"To access the route's role(s) (custom metadata), we'll use the Reflector helper class again:"
Title,typescript
Title,@@filename(roles.guard)
Title,@Injectable()
Title,export class RolesGuard {
Title,constructor(private reflector: Reflector) {}
Title,}
Title,@@switch
Title,@Injectable()
Title,@Dependencies(Reflector)
Title,export class CatsService {
Title,constructor(reflector) {
Title,this.reflector = reflector;
Title,}
Title,}
Title,
Title,info Hint The Reflector class is imported from the @nestjs/core package.
Title,
Title,"Now, to read the handler metadata, use the get() method."
Title,typescript
Title,"const roles = this.reflector.get<string[]>('roles', context.getHandler());"
Title,"Here instead of passing a decorator reference, we pass the metadata key as the first argument (which in our case is 'roles'). Everything else remains the same as in the Reflector#createDecorator example."
Title,
Title,Lazy loading modules
Title,"By default, modules are eagerly loaded, which means that as soon as the application loads, so do all the modules, whether or not they are immediately necessary. While this is fine for most applications, it may become a bottleneck for apps/workers running in the serverless environment, where the startup latency (""cold start"") is crucial."
Title,"Lazy loading can help decrease bootstrap time by loading only modules required by the specific serverless function invocation. In addition, you could also load other modules asynchronously once the serverless function is ""warm"" to speed-up the bootstrap time for subsequent calls even further (deferred modules registration)."
Title,
Title,"info Hint If you're familiar with the Angular framework, you might have seen the ""lazy-loading modules"" term before. Be aware that this technique is functionally different in Nest and so think about this as an entirely different feature that shares similar naming conventions."
Title,warning Warning Do note that lifecycle hooks methods are not invoked in lazy loaded modules and services.
Title,
Title,Getting started
Title,"To load modules on-demand, Nest provides the LazyModuleLoader class that can be injected into a class in the normal way:"
Title,typescript
Title,@@filename(cats.service)
Title,@Injectable()
Title,export class CatsService {
Title,constructor(private lazyModuleLoader: LazyModuleLoader) {}
Title,}
Title,@@switch
Title,@Injectable()
Title,@Dependencies(LazyModuleLoader)
Title,export class CatsService {
Title,constructor(lazyModuleLoader) {
Title,this.lazyModuleLoader = lazyModuleLoader;
Title,}
Title,}
Title,
Title,info Hint The LazyModuleLoader class is imported from the @nestjs/core package.
Title,
Title,"Alternatively, you can obtain a reference to the LazyModuleLoader provider from within your application bootstrap file (main.ts), as follows:"
Title,typescript
Title,"// ""app"" represents a Nest application instance"
Title,const lazyModuleLoader = app.get(LazyModuleLoader);
Title,"With this in place, you can now load any module using the following construction:"
Title,typescript
Title,const { LazyModule } = await import('./lazy.module');
Title,const moduleRef = await this.lazyModuleLoader.load(() => LazyModule);
Title,
Title,"info Hint ""Lazy loaded"" modules are cached upon the first LazyModuleLoader#load method invocation. That means, each consecutive attempt to load LazyModule will be very fast and will return a cached instance, instead of loading the module again."
Title,bash
Title,"Load ""LazyModule"" attempt: 1"
Title,time: 2.379ms
Title,"Load ""LazyModule"" attempt: 2"
Title,time: 0.294ms
Title,"Load ""LazyModule"" attempt: 3"
Title,time: 0.303ms
Title,"Also, ""lazy loaded"" modules share the same modules graph as those eagerly loaded on the application bootstrap as well as any other lazy modules registered later in your app."
Title,
Title,Where lazy.module.ts is a TypeScript file that exports a regular Nest module (no extra changes are required).
Title,The LazyModuleLoader#load method returns the module reference (of LazyModule) that lets you navigate the internal list of providers and obtain a reference to any provider using its injection token as a lookup key.
Title,"For example, let's say we have a LazyModule with the following definition:"
Title,typescript
Title,@Module({
Title,"providers: [LazyService],"
Title,"exports: [LazyService],"
Title,})
Title,export class LazyModule {}
Title,
Title,"info Hint Lazy loaded modules cannot be registered as global modules as it simply makes no sense (since they are registered lazily, on-demand when all the statically registered modules have been already instantiated). Likewise, registered global enhancers (guards/interceptors/etc.) will not work properly either."
Title,
Title,"With this, we could obtain a reference to the LazyService provider, as follows:"
Title,```typescript
Title,const { LazyModule } = await import('./lazy.module');
Title,const moduleRef = await this.lazyModuleLoader.load(() => LazyModule);
Title,const { LazyService } = await import('./lazy.service');
Title,const lazyService = moduleRef.get(LazyService);
Title,```
Title,
Title,"warning Warning If you use Webpack, make sure to update your tsconfig.json file - setting compilerOptions.module to ""esnext"" and adding compilerOptions.moduleResolution property with ""node"" as a value:"
Title,json
Title,{
Title,"""compilerOptions"": {"
Title,"""module"": ""esnext"","
Title,"""moduleResolution"": ""node"","
Title,...
Title,}
Title,}
Title,"With these options set up, you'll be able to leverage the code splitting feature."
Title,
Title,"Lazy loading controllers, gateways, and resolvers"
Title,"Since controllers (or resolvers in GraphQL applications) in Nest represent sets of routes/paths/topics (or queries/mutations), you cannot lazy load them using the LazyModuleLoader class."
Title,
Title,"error Warning Controllers, resolvers, and gateways registered inside lazy loaded modules will not behave as expected. Similarly, you cannot register middleware functions (by implementing the MiddlewareConsumer interface) on-demand."
Title,
Title,"For example, let's say you're building a REST API (HTTP application) with a Fastify driver under the hood (using the @nestjs/platform-fastify package). Fastify does not let you register routes after the application is ready/successfully listening to messages. That means even if we analyzed route mappings registered in the module's controllers, all lazy loaded routes wouldn't be accessible since there is no way to register them at runtime."
Title,"Likewise, some transport strategies we provide as part of the @nestjs/microservices package (including Kafka, gRPC, or RabbitMQ) require to subscribe/listen to specific topics/channels before the connection is established. Once your application starts listening to messages, the framework would not be able to subscribe/listen to new topics."
Title,"Lastly, the @nestjs/graphql package with the code first approach enabled automatically generates the GraphQL schema on-the-fly based on the metadata. That means, it requires all classes to be loaded beforehand. Otherwise, it would not be doable to create the appropriate, valid schema."
Title,Common use-cases
Title,"Most commonly, you will see lazy loaded modules in situations when your worker/cron job/lambda & serverless function/webhook must trigger different services (different logic) based on the input arguments (route path/date/query parameters, etc.). On the other hand, lazy loading modules may not make too much sense for monolithic applications, where the startup time is rather irrelevant."
Title,
Title,Lifecycle Events
Title,"A Nest application, as well as every application element, has a lifecycle managed by Nest. Nest provides lifecycle hooks that give visibility into key lifecycle events, and the ability to act (run registered code on your modules, providers or controllers) when they occur."
Title,Lifecycle sequence
Title,"The following diagram depicts the sequence of key application lifecycle events, from the time the application is bootstrapped until the node process exits. We can divide the overall lifecycle into three phases: initializing, running and terminating. Using this lifecycle, you can plan for appropriate initialization of modules and services, manage active connections, and gracefully shutdown your application when it receives a termination signal."
Title,
Title,Lifecycle events
Title,"Lifecycle events happen during application bootstrapping and shutdown. Nest calls registered lifecycle hook methods on modules, providers and controllers at each of the following lifecycle events (shutdown hooks need to be enabled first, as described below). As shown in the diagram above, Nest also calls the appropriate underlying methods to begin listening for connections, and to stop listening for connections."
Title,"In the following table, onModuleInit and onApplicationBootstrap are only triggered if you explicitly call app.init() or app.listen()."
Title,"In the following table, onModuleDestroy, beforeApplicationShutdown and onApplicationShutdown are only triggered if you explicitly call app.close() or if the process receives a special system signal (such as SIGTERM) and you have correctly called enableShutdownHooks at application bootstrap (see below Application shutdown part)."
Title,| Lifecycle hook method           | Lifecycle event triggering the hook method call                                                                                                                                                                   |
Title,| ------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
Title,| onModuleInit()                | Called once the host module's dependencies have been resolved.                                                                                                                                                    |
Title,"| onApplicationBootstrap()      | Called once all modules have been initialized, but before listening for connections.                                                                                                                              |"
Title,"| onModuleDestroy()*           | Called after a termination signal (e.g., SIGTERM) has been received.                                                                                                                                            |"
Title,"| beforeApplicationShutdown()* | Called after all onModuleDestroy() handlers have completed (Promises resolved or rejected);once complete (Promises resolved or rejected), all existing connections will be closed (app.close() called). |"
Title,| onApplicationShutdown()*     | Called after connections close (app.close() resolves).                                                                                                                                                          |
Title,"* For these events, if you're not calling app.close() explicitly, you must opt-in to make them work with system signals such as SIGTERM. See Application shutdown below."
Title,
Title,warning Warning The lifecycle hooks listed above are not triggered for request-scoped classes. Request-scoped classes are not tied to the application lifecycle and their lifespan is unpredictable. They are exclusively created for each request and automatically garbage-collected after the response is sent.
Title,"info Hint Execution order of onModuleInit() and onApplicationBootstrap() directly depends on the order of module imports, awaiting the previous hook."
Title,
Title,Usage
Title,"Each lifecycle hook is represented by an interface. Interfaces are technically optional because they do not exist after TypeScript compilation. Nonetheless, it's good practice to use them in order to benefit from strong typing and editor tooling. To register a lifecycle hook, implement the appropriate interface. For example, to register a method to be called during module initialization on a particular class (e.g., Controller, Provider or Module), implement the OnModuleInit interface by supplying an onModuleInit() method, as shown below:"
Title,```typescript
Title,@@filename()
Title,"import { Injectable, OnModuleInit } from '@nestjs/common';"
Title,@Injectable()
Title,export class UsersService implements OnModuleInit {
Title,onModuleInit() {
Title,console.log(The module has been initialized.);
Title,}
Title,}
Title,@@switch
Title,import { Injectable } from '@nestjs/common';
Title,@Injectable()
Title,export class UsersService {
Title,onModuleInit() {
Title,console.log(The module has been initialized.);
Title,}
Title,}
Title,```
Title,Asynchronous initialization
Title,Both the OnModuleInit and OnApplicationBootstrap hooks allow you to defer the application initialization process (return a Promise or mark the method as async and await an asynchronous method completion in the method body).
Title,typescript
Title,@@filename()
Title,async onModuleInit(): Promise<void> {
Title,await this.fetch();
Title,}
Title,@@switch
Title,async onModuleInit() {
Title,await this.fetch();
Title,}
Title,Application shutdown
Title,"The onModuleDestroy(), beforeApplicationShutdown() and onApplicationShutdown() hooks are called in the terminating phase (in response to an explicit call to app.close() or upon receipt of system signals such as SIGTERM if opted-in). This feature is often used with Kubernetes to manage containers' lifecycles, by Heroku for dynos or similar services."
Title,"Shutdown hook listeners consume system resources, so they are disabled by default. To use shutdown hooks, you must enable listeners by calling enableShutdownHooks():"
Title,```typescript
Title,import { NestFactory } from '@nestjs/core';
Title,import { AppModule } from './app.module';
Title,async function bootstrap() {
Title,const app = await NestFactory.create(AppModule);
Title,// Starts listening for shutdown hooks
Title,app.enableShutdownHooks();
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,bootstrap();
Title,```
Title,
Title,"warning warning Due to inherent platform limitations, NestJS has limited support for application shutdown hooks on Windows. You can expect SIGINT to work, as well as SIGBREAK and to some extent SIGHUP - read more. However SIGTERM will never work on Windows because killing a process in the task manager is unconditional, ""i.e., there's no way for an application to detect or prevent it"". Here's some relevant documentation from libuv to learn more about how SIGINT, SIGBREAK and others are handled on Windows. Also, see Node.js documentation of Process Signal Events"
Title,"info Info enableShutdownHooks consumes memory by starting listeners. In cases where you are running multiple Nest apps in a single Node process (e.g., when running parallel tests with Jest), Node may complain about excessive listener processes. For this reason, enableShutdownHooks is not enabled by default. Be aware of this condition when you are running multiple instances in a single Node process."
Title,
Title,"When the application receives a termination signal it will call any registered onModuleDestroy(), beforeApplicationShutdown(), then onApplicationShutdown() methods (in the sequence described above) with the corresponding signal as the first parameter. If a registered function awaits an asynchronous call (returns a promise), Nest will not continue in the sequence until the promise is resolved or rejected."
Title,typescript
Title,@@filename()
Title,@Injectable()
Title,class UsersService implements OnApplicationShutdown {
Title,onApplicationShutdown(signal: string) {
Title,"console.log(signal); // e.g. ""SIGINT"""
Title,}
Title,}
Title,@@switch
Title,@Injectable()
Title,class UsersService implements OnApplicationShutdown {
Title,onApplicationShutdown(signal) {
Title,"console.log(signal); // e.g. ""SIGINT"""
Title,}
Title,}
Title,
Title,"info Info Calling app.close() doesn't terminate the Node process but only triggers the onModuleDestroy() and onApplicationShutdown() hooks, so if there are some intervals, long-running background tasks, etc. the process won't be automatically terminated."
Title,
Title,
Title,Module reference
Title,Nest provides the ModuleRef class to navigate the internal list of providers and obtain a reference to any provider using its injection token as a lookup key. The ModuleRef class also provides a way to dynamically instantiate both static and scoped providers. ModuleRef can be injected into a class in the normal way:
Title,typescript
Title,@@filename(cats.service)
Title,@Injectable()
Title,export class CatsService {
Title,constructor(private moduleRef: ModuleRef) {}
Title,}
Title,@@switch
Title,@Injectable()
Title,@Dependencies(ModuleRef)
Title,export class CatsService {
Title,constructor(moduleRef) {
Title,this.moduleRef = moduleRef;
Title,}
Title,}
Title,
Title,info Hint The ModuleRef class is imported from the @nestjs/core package.
Title,
Title,Retrieving instances
Title,"The ModuleRef instance (hereafter we'll refer to it as the module reference) has a get() method. By default, this method returns a provider, controller, or injectable (e.g., guard, interceptor, etc.) that was registered and has been instantiated in the current module using its injection token/class name. If the instance is not found, an exception will be raised."
Title,```typescript
Title,@@filename(cats.service)
Title,@Injectable()
Title,export class CatsService implements OnModuleInit {
Title,private service: Service;
Title,constructor(private moduleRef: ModuleRef) {}
Title,onModuleInit() {
Title,this.service = this.moduleRef.get(Service);
Title,}
Title,}
Title,@@switch
Title,@Injectable()
Title,@Dependencies(ModuleRef)
Title,export class CatsService {
Title,constructor(moduleRef) {
Title,this.moduleRef = moduleRef;
Title,}
Title,onModuleInit() {
Title,this.service = this.moduleRef.get(Service);
Title,}
Title,}
Title,```
Title,
Title,"warning Warning You can't retrieve scoped providers (transient or request-scoped) with the get() method. Instead, use the technique described below. Learn how to control scopes here."
Title,
Title,"To retrieve a provider from the global context (for example, if the provider has been injected in a different module), pass the {{ '{' }} strict: false {{ '}' }} option as a second argument to get()."
Title,typescript
Title,"this.moduleRef.get(Service, { strict: false });"
Title,Resolving scoped providers
Title,"To dynamically resolve a scoped provider (transient or request-scoped), use the resolve() method, passing the provider's injection token as an argument."
Title,```typescript
Title,@@filename(cats.service)
Title,@Injectable()
Title,export class CatsService implements OnModuleInit {
Title,private transientService: TransientService;
Title,constructor(private moduleRef: ModuleRef) {}
Title,async onModuleInit() {
Title,this.transientService = await this.moduleRef.resolve(TransientService);
Title,}
Title,}
Title,@@switch
Title,@Injectable()
Title,@Dependencies(ModuleRef)
Title,export class CatsService {
Title,constructor(moduleRef) {
Title,this.moduleRef = moduleRef;
Title,}
Title,async onModuleInit() {
Title,this.transientService = await this.moduleRef.resolve(TransientService);
Title,}
Title,}
Title,```
Title,"The resolve() method returns a unique instance of the provider, from its own DI container sub-tree. Each sub-tree has a unique context identifier. Thus, if you call this method more than once and compare instance references, you will see that they are not equal."
Title,```typescript
Title,@@filename(cats.service)
Title,@Injectable()
Title,export class CatsService implements OnModuleInit {
Title,constructor(private moduleRef: ModuleRef) {}
Title,async onModuleInit() {
Title,const transientServices = await Promise.all([
Title,"this.moduleRef.resolve(TransientService),"
Title,"this.moduleRef.resolve(TransientService),"
Title,]);
Title,console.log(transientServices[0] === transientServices[1]); // false
Title,}
Title,}
Title,@@switch
Title,@Injectable()
Title,@Dependencies(ModuleRef)
Title,export class CatsService {
Title,constructor(moduleRef) {
Title,this.moduleRef = moduleRef;
Title,}
Title,async onModuleInit() {
Title,const transientServices = await Promise.all([
Title,"this.moduleRef.resolve(TransientService),"
Title,"this.moduleRef.resolve(TransientService),"
Title,]);
Title,console.log(transientServices[0] === transientServices[1]); // false
Title,}
Title,}
Title,```
Title,"To generate a single instance across multiple resolve() calls, and ensure they share the same generated DI container sub-tree, you can pass a context identifier to the resolve() method. Use the ContextIdFactory class to generate a context identifier. This class provides a create() method that returns an appropriate unique identifier."
Title,```typescript
Title,@@filename(cats.service)
Title,@Injectable()
Title,export class CatsService implements OnModuleInit {
Title,constructor(private moduleRef: ModuleRef) {}
Title,async onModuleInit() {
Title,const contextId = ContextIdFactory.create();
Title,const transientServices = await Promise.all([
Title,"this.moduleRef.resolve(TransientService, contextId),"
Title,"this.moduleRef.resolve(TransientService, contextId),"
Title,]);
Title,console.log(transientServices[0] === transientServices[1]); // true
Title,}
Title,}
Title,@@switch
Title,@Injectable()
Title,@Dependencies(ModuleRef)
Title,export class CatsService {
Title,constructor(moduleRef) {
Title,this.moduleRef = moduleRef;
Title,}
Title,async onModuleInit() {
Title,const contextId = ContextIdFactory.create();
Title,const transientServices = await Promise.all([
Title,"this.moduleRef.resolve(TransientService, contextId),"
Title,"this.moduleRef.resolve(TransientService, contextId),"
Title,]);
Title,console.log(transientServices[0] === transientServices[1]); // true
Title,}
Title,}
Title,```
Title,
Title,info Hint The ContextIdFactory class is imported from the @nestjs/core package.
Title,
Title,Registering REQUEST provider
Title,Manually generated context identifiers (with ContextIdFactory.create()) represent DI sub-trees in which REQUEST provider is undefined as they are not instantiated and managed by the Nest dependency injection system.
Title,"To register a custom REQUEST object for a manually created DI sub-tree, use the ModuleRef#registerRequestByContextId() method, as follows:"
Title,typescript
Title,const contextId = ContextIdFactory.create();
Title,"this.moduleRef.registerRequestByContextId(/* YOUR_REQUEST_OBJECT */, contextId);"
Title,Getting current sub-tree
Title,"Occasionally, you may want to resolve an instance of a request-scoped provider within a request context. Let's say that CatsService is request-scoped and you want to resolve the CatsRepository instance which is also marked as a request-scoped provider. In order to share the same DI container sub-tree, you must obtain the current context identifier instead of generating a new one (e.g., with the ContextIdFactory.create() function, as shown above). To obtain the current context identifier, start by injecting the request object using @Inject() decorator."
Title,typescript
Title,@@filename(cats.service)
Title,@Injectable()
Title,export class CatsService {
Title,constructor(
Title,"@Inject(REQUEST) private request: Record<string, unknown>,"
Title,) {}
Title,}
Title,@@switch
Title,@Injectable()
Title,@Dependencies(REQUEST)
Title,export class CatsService {
Title,constructor(request) {
Title,this.request = request;
Title,}
Title,}
Title,
Title,info Hint Learn more about the request provider here.
Title,
Title,"Now, use the getByRequest() method of the ContextIdFactory class to create a context id based on the request object, and pass this to the resolve() call:"
Title,typescript
Title,const contextId = ContextIdFactory.getByRequest(this.request);
Title,"const catsRepository = await this.moduleRef.resolve(CatsRepository, contextId);"
Title,Instantiating custom classes dynamically
Title,"To dynamically instantiate a class that wasn't previously registered as a provider, use the module reference's create() method."
Title,```typescript
Title,@@filename(cats.service)
Title,@Injectable()
Title,export class CatsService implements OnModuleInit {
Title,private catsFactory: CatsFactory;
Title,constructor(private moduleRef: ModuleRef) {}
Title,async onModuleInit() {
Title,this.catsFactory = await this.moduleRef.create(CatsFactory);
Title,}
Title,}
Title,@@switch
Title,@Injectable()
Title,@Dependencies(ModuleRef)
Title,export class CatsService {
Title,constructor(moduleRef) {
Title,this.moduleRef = moduleRef;
Title,}
Title,async onModuleInit() {
Title,this.catsFactory = await this.moduleRef.create(CatsFactory);
Title,}
Title,}
Title,```
Title,This technique enables you to conditionally instantiate different classes outside of the framework container.
Title,
Title,
Title,Platform agnosticism
Title,"Nest is a platform-agnostic framework. This means you can develop reusable logical parts that can be used across different types of applications. For example, most components can be re-used without change across different underlying HTTP server frameworks (e.g., Express and Fastify), and even across different types of applications (e.g., HTTP server frameworks, Microservices with different transport layers, and Web Sockets)."
Title,"Build once, use everywhere"
Title,"The Overview section of the documentation primarily shows coding techniques using HTTP server frameworks (e.g., apps providing a REST API or providing an MVC-style server-side rendered app). However, all those building blocks can be used on top of different transport layers (microservices or websockets)."
Title,"Furthermore, Nest comes with a dedicated GraphQL module. You can use GraphQL as your API layer interchangeably with providing a REST API."
Title,"In addition, the application context feature helps to create any kind of Node.js application - including things like CRON jobs and CLI apps - on top of Nest."
Title,"Nest aspires to be a full-fledged platform for Node.js apps that brings a higher-level of modularity and reusability to your applications. Build once, use everywhere!"
Title,
Title,Injection scopes
Title,"For people coming from different programming language backgrounds, it might be unexpected to learn that in Nest, almost everything is shared across incoming requests. We have a connection pool to the database, singleton services with global state, etc. Remember that Node.js doesn't follow the request/response Multi-Threaded Stateless Model in which every request is processed by a separate thread. Hence, using singleton instances is fully safe for our applications."
Title,"However, there are edge cases when request-based lifetime may be the desired behavior, for instance, per-request caching in GraphQL applications, request tracking, and multi-tenancy. Injection scopes provide a mechanism to obtain the desired provider lifetime behavior."
Title,Provider scope
Title,A provider can have any of the following scopes:
Title,
Title,
Title,DEFAULT
Title,"A single instance of the provider is shared across the entire application. The instance lifetime is tied directly to the application lifecycle. Once the application has bootstrapped, all singleton providers have been instantiated. Singleton scope is used by default."
Title,
Title,
Title,REQUEST
Title,A new instance of the provider is created exclusively for each incoming request.  The instance is garbage-collected after the request has completed processing.
Title,
Title,
Title,TRANSIENT
Title,"Transient providers are not shared across consumers. Each consumer that injects a transient provider will receive a new, dedicated instance."
Title,
Title,
Title,
Title,"info Hint Using singleton scope is recommended for most use cases. Sharing providers across consumers and across requests means that an instance can be cached and its initialization occurs only once, during application startup."
Title,
Title,Usage
Title,Specify injection scope by passing the scope property to the @Injectable() decorator options object:
Title,```typescript
Title,"import { Injectable, Scope } from '@nestjs/common';"
Title,@Injectable({ scope: Scope.REQUEST })
Title,export class CatsService {}
Title,```
Title,"Similarly, for custom providers, set the scope property in the long-hand form for a provider registration:"
Title,typescript
Title,{
Title,"provide: 'CACHE_MANAGER',"
Title,"useClass: CacheManager,"
Title,"scope: Scope.TRANSIENT,"
Title,}
Title,
Title,info Hint Import the Scope enum from @nestjs/common
Title,
Title,"Singleton scope is used by default and does not need be declared. If you do want to declare a provider as singleton scoped, use the Scope.DEFAULT value for the scope property."
Title,
Title,"warning Notice Websocket Gateways should not use request-scoped providers because they must act as singletons. Each gateway encapsulates a real socket and cannot be instantiated multiple times. The limitation also applies to some other providers, like Passport strategies or Cron controllers."
Title,
Title,Controller scope
Title,"Controllers can also have scope, which applies to all request method handlers declared in that controller. Like provider scope, the scope of a controller declares its lifetime. For a request-scoped controller, a new instance is created for each inbound request, and garbage-collected when the request has completed processing."
Title,Declare controller scope with the scope property of the ControllerOptions object:
Title,typescript
Title,@Controller({
Title,"path: 'cats',"
Title,"scope: Scope.REQUEST,"
Title,})
Title,export class CatsController {}
Title,Scope hierarchy
Title,"The REQUEST scope bubbles up the injection chain. A controller that depends on a request-scoped provider will, itself, be request-scoped."
Title,"Imagine the following dependency graph: CatsController <- CatsService <- CatsRepository. If CatsService is request-scoped (and the others are default singletons), the CatsController will become request-scoped as it is dependent on the injected service. The CatsRepository, which is not dependent, would remain singleton-scoped."
Title,"Transient-scoped dependencies don't follow that pattern. If a singleton-scoped DogsService injects a transient LoggerService provider, it will receive a fresh instance of it. However, DogsService will stay singleton-scoped, so injecting it anywhere would not resolve to a new instance of DogsService. In case it's desired behavior, DogsService must be explicitly marked as TRANSIENT as well."
Title,
Title,Request provider
Title,"In an HTTP server-based application (e.g., using @nestjs/platform-express or @nestjs/platform-fastify), you may want to access a reference to the original request object when using request-scoped providers. You can do this by injecting the REQUEST object."
Title,"The REQUEST provider is inherently request-scoped, meaning you don't need to specify the REQUEST scope explicitly when using it. Additionally, even if you attempt to do so, it will be disregarded. Any provider that relies on a request-scoped provider automatically adopts a request scope, and this behavior cannot be altered."
Title,```typescript
Title,"import { Injectable, Scope, Inject } from '@nestjs/common';"
Title,import { REQUEST } from '@nestjs/core';
Title,import { Request } from 'express';
Title,@Injectable({ scope: Scope.REQUEST })
Title,export class CatsService {
Title,constructor(@Inject(REQUEST) private request: Request) {}
Title,}
Title,```
Title,"Because of underlying platform/protocol differences, you access the inbound request slightly differently for Microservice or GraphQL applications. In GraphQL applications, you inject CONTEXT instead of REQUEST:"
Title,```typescript
Title,"import { Injectable, Scope, Inject } from '@nestjs/common';"
Title,import { CONTEXT } from '@nestjs/graphql';
Title,@Injectable({ scope: Scope.REQUEST })
Title,export class CatsService {
Title,constructor(@Inject(CONTEXT) private context) {}
Title,}
Title,```
Title,You then configure your context value (in the GraphQLModule) to contain request as its property.
Title,Inquirer provider
Title,"If you want to get the class where a provider was constructed, for instance in logging or metrics providers, you can inject the INQUIRER token."
Title,```typescript
Title,"import { Inject, Injectable, Scope } from '@nestjs/common';"
Title,import { INQUIRER } from '@nestjs/core';
Title,@Injectable({ scope: Scope.TRANSIENT })
Title,export class HelloService {
Title,constructor(@Inject(INQUIRER) private parentClass: object) {}
Title,sayHello(message: string) {
Title,console.log(${this.parentClass?.constructor?.name}: ${message});
Title,}
Title,}
Title,```
Title,And then use it as follows:
Title,```typescript
Title,import { Injectable } from '@nestjs/common';
Title,import { HelloService } from './hello.service';
Title,@Injectable()
Title,export class AppService {
Title,constructor(private helloService: HelloService) {}
Title,getRoot(): string {
Title,this.helloService.sayHello('My name is getRoot');
Title,return 'Hello world!';
Title,
Title,}
Title,}
Title,```
Title,"In the example above when AppService#getRoot is called, ""AppService: My name is getRoot"" will be logged to the console."
Title,Performance
Title,"Using request-scoped providers will have an impact on application performance. While Nest tries to cache as much metadata as possible, it will still have to create an instance of your class on each request. Hence, it will slow down your average response time and overall benchmarking result. Unless a provider must be request-scoped, it is strongly recommended that you use the default singleton scope."
Title,
Title,"info Hint Although it all sounds quite intimidating, a properly designed application that leverages request-scoped providers should not slow down by more than ~5% latency-wise."
Title,
Title,Durable providers
Title,"Request-scoped providers, as mentioned in the section above, may lead to increased latency since having at least 1 request-scoped provider (injected into the controller instance, or deeper - injected into one of its providers) makes the controller request-scoped as well. That means it must be recreated (instantiated) per each individual request (and garbage collected afterward). Now, that also means, that for let's say 30k requests in parallel, there will be 30k ephemeral instances of the controller (and its request-scoped providers)."
Title,"Having a common provider that most providers depend on (think of a database connection, or a logger service), automatically converts all those providers to request-scoped providers as well. This can pose a challenge in multi-tenant applications, especially for those that have a central request-scoped ""data source"" provider that grabs headers/token from the request object and based on its values, retrieves the corresponding database connection/schema (specific to that tenant)."
Title,"For instance, let's say you have an application alternately used by 10 different customers. Each customer has its own dedicated data source, and you want to make sure customer A will never be able to reach customer B's database. One way to achieve this could be to declare a request-scoped ""data source"" provider that - based on the request object - determines what's the ""current customer"" and retrieves its corresponding database. With this approach, you can turn your application into a multi-tenant application in just a few minutes. But, a major downside to this approach is that since most likely a large chunk of your application' components rely on the ""data source"" provider, they will implicitly become ""request-scoped"", and therefore you will undoubtedly see an impact in your apps performance."
Title,"But what if we had a better solution? Since we only have 10 customers, couldn't we have 10 individual DI sub-trees per customer (instead of recreating each tree per request)? If your providers don't rely on any property that's truly unique for each consecutive request (e.g., request UUID) but instead there're some specific attributes that let us aggregate (classify) them, there's no reason to recreate DI sub-tree on every incoming request."
Title,And that's exactly when the durable providers come in handy.
Title,"Before we start flagging providers as durable, we must first register a strategy that instructs Nest what are those ""common request attributes"", provide logic that groups requests - associates them with their corresponding DI sub-trees."
Title,```typescript
Title,import {
Title,"HostComponentInfo,"
Title,"ContextId,"
Title,"ContextIdFactory,"
Title,"ContextIdStrategy,"
Title,} from '@nestjs/core';
Title,import { Request } from 'express';
Title,const tenants = new Map();
Title,export class AggregateByTenantContextIdStrategy implements ContextIdStrategy {
Title,"attach(contextId: ContextId, request: Request) {"
Title,const tenantId = request.headers['x-tenant-id'] as string;
Title,let tenantSubTreeId: ContextId;
Title,if (tenants.has(tenantId)) {
Title,tenantSubTreeId = tenants.get(tenantId);
Title,} else {
Title,tenantSubTreeId = ContextIdFactory.create();
Title,"tenants.set(tenantId, tenantSubTreeId);"
Title,}
Title,
Title,"// If tree is not durable, return the original ""contextId"" object"
Title,return (info: HostComponentInfo) =>
Title,info.isTreeDurable ? tenantSubTreeId : contextId;
Title,
Title,}
Title,}
Title,```
Title,
Title,"info Hint Similar to the request scope, durability bubbles up the injection chain. That means if A depends on B which is flagged as durable, A implicitly becomes durable too (unless durable is explicitly set to false for A provider)."
Title,warning Warning Note this strategy is not ideal for applications operating with a large number of tenants.
Title,
Title,"The value returned from the attach method instructs Nest what context identifier should be used for a given host. In this case, we specified that the tenantSubTreeId should be used instead of the original, auto-generated contextId object, when the host component (e.g., request-scoped controller) is flagged as durable (you can learn how to mark providers as durable below). Also, in the above example, no payload would be registered (where payload = REQUEST/CONTEXT provider that represents the ""root"" - parent of the sub-tree)."
Title,"If you want to register the payload for a durable tree, use the following construction instead:"
Title,typescript
Title,// The return of `AggregateByTenantContextIdStrategy#attach` method:
Title,return {
Title,resolve: (info: HostComponentInfo) =>
Title,"info.isTreeDurable ? tenantSubTreeId : contextId,"
Title,"payload: { tenantId },"
Title,};
Title,"Now whenever you inject the REQUEST provider (or CONTEXT for GraphQL applications) using the @Inject(REQUEST)/@Inject(CONTEXT), the payload object would be injected (consisting of a single property - tenantId in this case)."
Title,"Alright so with this strategy in place, you can register it somewhere in your code (as it applies globally anyway), so for example, you could place it in the main.ts file:"
Title,typescript
Title,ContextIdFactory.apply(new AggregateByTenantContextIdStrategy());
Title,
Title,info Hint The ContextIdFactory class is imported from the @nestjs/core package.
Title,
Title,"As long as the registration occurs before any request hits your application, everything will work as intended."
Title,"Lastly, to turn a regular provider into a durable provider, simply set the durable flag to true and change its scope to Scope.REQUEST (not needed if the REQUEST scope is in the injection chain already):"
Title,```typescript
Title,"import { Injectable, Scope } from '@nestjs/common';"
Title,"@Injectable({ scope: Scope.REQUEST, durable: true })"
Title,export class CatsService {}
Title,```
Title,"Similarly, for custom providers, set the durable property in the long-hand form for a provider registration:"
Title,typescript
Title,{
Title,"provide: 'foobar',"
Title,"useFactory: () => { ... },"
Title,"scope: Scope.REQUEST,"
Title,"durable: true,"
Title,}
Title,
Title,Testing
Title,"Automated testing is considered an essential part of any serious software development effort. Automation makes it easy to repeat individual tests or test suites quickly and easily during development. This helps ensure that releases meet quality and performance goals. Automation helps increase coverage and provides a faster feedback loop to developers. Automation both increases the productivity of individual developers and ensures that tests are run at critical development lifecycle junctures, such as source code control check-in, feature integration, and version release."
Title,"Such tests often span a variety of types, including unit tests, end-to-end (e2e) tests, integration tests, and so on. While the benefits are unquestionable, it can be tedious to set them up. Nest strives to promote development best practices, including effective testing, so it includes features such as the following to help developers and teams build and automate tests. Nest:"
Title,
Title,automatically scaffolds default unit tests for components and e2e tests for applications
Title,provides default tooling (such as a test runner that builds an isolated module/application loader)
Title,"provides integration with Jest and Supertest out-of-the-box, while remaining agnostic to testing tools"
Title,makes the Nest dependency injection system available in the testing environment for easily mocking components
Title,
Title,"As mentioned, you can use any testing framework that you like, as Nest doesn't force any specific tooling. Simply replace the elements needed (such as the test runner), and you will still enjoy the benefits of Nest's ready-made testing facilities."
Title,Installation
Title,"To get started, first install the required package:"
Title,bash
Title,$ npm i --save-dev @nestjs/testing
Title,Unit testing
Title,"In the following example, we test two classes: CatsController and CatsService. As mentioned, Jest is provided as the default testing framework. It serves as a test-runner and also provides assert functions and test-double utilities that help with mocking, spying, etc. In the following basic test, we manually instantiate these classes, and ensure that the controller and service fulfill their API contract."
Title,```typescript
Title,@@filename(cats.controller.spec)
Title,import { CatsController } from './cats.controller';
Title,import { CatsService } from './cats.service';
Title,"describe('CatsController', () => {"
Title,let catsController: CatsController;
Title,let catsService: CatsService;
Title,beforeEach(() => {
Title,catsService = new CatsService();
Title,catsController = new CatsController(catsService);
Title,});
Title,"describe('findAll', () => {"
Title,"it('should return an array of cats', async () => {"
Title,const result = ['test'];
Title,"jest.spyOn(catsService, 'findAll').mockImplementation(() => result);"
Title,expect(await catsController.findAll()).toBe(result);
Title,});
Title,
Title,});
Title,});
Title,@@switch
Title,import { CatsController } from './cats.controller';
Title,import { CatsService } from './cats.service';
Title,"describe('CatsController', () => {"
Title,let catsController;
Title,let catsService;
Title,beforeEach(() => {
Title,catsService = new CatsService();
Title,catsController = new CatsController(catsService);
Title,});
Title,"describe('findAll', () => {"
Title,"it('should return an array of cats', async () => {"
Title,const result = ['test'];
Title,"jest.spyOn(catsService, 'findAll').mockImplementation(() => result);"
Title,expect(await catsController.findAll()).toBe(result);
Title,});
Title,
Title,});
Title,});
Title,```
Title,
Title,info Hint Keep your test files located near the classes they test. Testing files should have a .spec or .test suffix.
Title,
Title,"Because the above sample is trivial, we aren't really testing anything Nest-specific. Indeed, we aren't even using dependency injection (notice that we pass an instance of CatsService to our catsController). This form of testing - where we manually instantiate the classes being tested - is often called isolated testing as it is independent from the framework. Let's introduce some more advanced capabilities that help you test applications that make more extensive use of Nest features."
Title,Testing utilities
Title,The @nestjs/testing package provides a set of utilities that enable a more robust testing process. Let's rewrite the previous example using the built-in Test class:
Title,```typescript
Title,@@filename(cats.controller.spec)
Title,import { Test } from '@nestjs/testing';
Title,import { CatsController } from './cats.controller';
Title,import { CatsService } from './cats.service';
Title,"describe('CatsController', () => {"
Title,let catsController: CatsController;
Title,let catsService: CatsService;
Title,beforeEach(async () => {
Title,const moduleRef = await Test.createTestingModule({
Title,"controllers: [CatsController],"
Title,"providers: [CatsService],"
Title,}).compile();
Title,catsService = moduleRef.get(CatsService);
Title,catsController = moduleRef.get(CatsController);
Title,
Title,});
Title,"describe('findAll', () => {"
Title,"it('should return an array of cats', async () => {"
Title,const result = ['test'];
Title,"jest.spyOn(catsService, 'findAll').mockImplementation(() => result);"
Title,expect(await catsController.findAll()).toBe(result);
Title,});
Title,
Title,});
Title,});
Title,@@switch
Title,import { Test } from '@nestjs/testing';
Title,import { CatsController } from './cats.controller';
Title,import { CatsService } from './cats.service';
Title,"describe('CatsController', () => {"
Title,let catsController;
Title,let catsService;
Title,beforeEach(async () => {
Title,const moduleRef = await Test.createTestingModule({
Title,"controllers: [CatsController],"
Title,"providers: [CatsService],"
Title,}).compile();
Title,catsService = moduleRef.get(CatsService);
Title,catsController = moduleRef.get(CatsController);
Title,
Title,});
Title,"describe('findAll', () => {"
Title,"it('should return an array of cats', async () => {"
Title,const result = ['test'];
Title,"jest.spyOn(catsService, 'findAll').mockImplementation(() => result);"
Title,expect(await catsController.findAll()).toBe(result);
Title,});
Title,
Title,});
Title,});
Title,```
Title,"The Test class is useful for providing an application execution context that essentially mocks the full Nest runtime, but gives you hooks that make it easy to manage class instances, including mocking and overriding. The Test class has a createTestingModule() method that takes a module metadata object as its argument (the same object you pass to the @Module() decorator). This method returns a TestingModule instance which in turn provides a few methods. For unit tests, the important one is the compile() method. This method bootstraps a module with its dependencies (similar to the way an application is bootstrapped in the conventional main.ts file using NestFactory.create()), and returns a module that is ready for testing."
Title,
Title,info Hint The compile() method is asynchronous and therefore has to be awaited. Once the module is compiled you can retrieve any static instance it declares (controllers and providers) using the get() method.
Title,
Title,"TestingModule inherits from the module reference class, and therefore its ability to dynamically resolve scoped providers (transient or request-scoped). Do this with the resolve() method (the get() method can only retrieve static instances)."
Title,```typescript
Title,const moduleRef = await Test.createTestingModule({
Title,"controllers: [CatsController],"
Title,"providers: [CatsService],"
Title,}).compile();
Title,catsService = await moduleRef.resolve(CatsService);
Title,```
Title,
Title,"warning Warning The resolve() method returns a unique instance of the provider, from its own DI container sub-tree. Each sub-tree has a unique context identifier. Thus, if you call this method more than once and compare instance references, you will see that they are not equal."
Title,info Hint Learn more about the module reference features here.
Title,
Title,"Instead of using the production version of any provider, you can override it with a custom provider for testing purposes. For example, you can mock a database service instead of connecting to a live database. We'll cover overrides in the next section, but they're available for unit tests as well."
Title,
Title,Auto mocking
Title,"Nest also allows you to define a mock factory to apply to all of your missing dependencies. This is useful for cases where you have a large number of dependencies in a class and mocking all of them will take a long time and a lot of setup. To make use of this feature, the createTestingModule() will need to be chained up with the useMocker() method, passing a factory for your dependency mocks. This factory can take in an optional token, which is an instance token, any token which is valid for a Nest provider, and returns a mock implementation. The below is an example of creating a generic mocker using jest-mock and a specific mock for CatsService using jest.fn()."
Title,```typescript
Title,// ...
Title,"import { ModuleMocker, MockFunctionMetadata } from 'jest-mock';"
Title,const moduleMocker = new ModuleMocker(global);
Title,"describe('CatsController', () => {"
Title,let controller: CatsController;
Title,beforeEach(async () => {
Title,const moduleRef = await Test.createTestingModule({
Title,"controllers: [CatsController],"
Title,})
Title,.useMocker((token) => {
Title,"const results = ['test1', 'test2'];"
Title,if (token === CatsService) {
Title,return { findAll: jest.fn().mockResolvedValue(results) };
Title,}
Title,if (typeof token === 'function') {
Title,const mockMetadata = moduleMocker.getMetadata(
Title,"token,"
Title,) as MockFunctionMetadata;
Title,const Mock = moduleMocker.generateFromMetadata(mockMetadata);
Title,return new Mock();
Title,}
Title,})
Title,.compile();
Title,controller = moduleRef.get(CatsController);
Title,
Title,});
Title,});
Title,```
Title,"You can also retrieve these mocks out of the testing container as you normally would custom providers, moduleRef.get(CatsService)."
Title,
Title,"info Hint A general mock factory, like createMock from @golevelup/ts-jest can also be passed directly."
Title,"info Hint REQUEST and INQUIRER providers cannot be auto-mocked because they're already pre-defined in the context. However, they can be overwritten using the custom provider syntax or by utilizing the .overrideProvider method."
Title,
Title,End-to-end testing
Title,"Unlike unit testing, which focuses on individual modules and classes, end-to-end (e2e) testing covers the interaction of classes and modules at a more aggregate level -- closer to the kind of interaction that end-users will have with the production system. As an application grows, it becomes hard to manually test the end-to-end behavior of each API endpoint. Automated end-to-end tests help us ensure that the overall behavior of the system is correct and meets project requirements. To perform e2e tests we use a similar configuration to the one we just covered in unit testing. In addition, Nest makes it easy to use the Supertest library to simulate HTTP requests."
Title,```typescript
Title,@@filename(cats.e2e-spec)
Title,import * as request from 'supertest';
Title,import { Test } from '@nestjs/testing';
Title,import { CatsModule } from '../../src/cats/cats.module';
Title,import { CatsService } from '../../src/cats/cats.service';
Title,import { INestApplication } from '@nestjs/common';
Title,"describe('Cats', () => {"
Title,let app: INestApplication;
Title,let catsService = { findAll: () => ['test'] };
Title,beforeAll(async () => {
Title,const moduleRef = await Test.createTestingModule({
Title,"imports: [CatsModule],"
Title,})
Title,.overrideProvider(CatsService)
Title,.useValue(catsService)
Title,.compile();
Title,app = moduleRef.createNestApplication();
Title,await app.init();
Title,
Title,});
Title,"it(/GET cats, () => {"
Title,return request(app.getHttpServer())
Title,.get('/cats')
Title,.expect(200)
Title,.expect({
Title,"data: catsService.findAll(),"
Title,});
Title,});
Title,afterAll(async () => {
Title,await app.close();
Title,});
Title,});
Title,@@switch
Title,import * as request from 'supertest';
Title,import { Test } from '@nestjs/testing';
Title,import { CatsModule } from '../../src/cats/cats.module';
Title,import { CatsService } from '../../src/cats/cats.service';
Title,import { INestApplication } from '@nestjs/common';
Title,"describe('Cats', () => {"
Title,let app: INestApplication;
Title,let catsService = { findAll: () => ['test'] };
Title,beforeAll(async () => {
Title,const moduleRef = await Test.createTestingModule({
Title,"imports: [CatsModule],"
Title,})
Title,.overrideProvider(CatsService)
Title,.useValue(catsService)
Title,.compile();
Title,app = moduleRef.createNestApplication();
Title,await app.init();
Title,
Title,});
Title,"it(/GET cats, () => {"
Title,return request(app.getHttpServer())
Title,.get('/cats')
Title,.expect(200)
Title,.expect({
Title,"data: catsService.findAll(),"
Title,});
Title,});
Title,afterAll(async () => {
Title,await app.close();
Title,});
Title,});
Title,```
Title,
Title,"info Hint If you're using Fastify as your HTTP adapter, it requires a slightly different configuration, and has built-in testing capabilities:"
Title,```ts
Title,let app: NestFastifyApplication;
Title,beforeAll(async () => {
Title,app = moduleRef.createNestApplication(
Title,"new FastifyAdapter(),"
Title,);
Title,await app.init();
Title,await app.getHttpAdapter().getInstance().ready();
Title,});
Title,"it(/GET cats, () => {"
Title,return app
Title,.inject({
Title,"method: 'GET',"
Title,"url: '/cats',"
Title,})
Title,.then((result) => {
Title,expect(result.statusCode).toEqual(200);
Title,expect(result.payload).toEqual(/ expectedPayload /);
Title,});
Title,});
Title,afterAll(async () => {
Title,await app.close();
Title,});
Title,```
Title,
Title,"In this example, we build on some of the concepts described earlier. In addition to the compile() method we used earlier, we now use the createNestApplication() method to instantiate a full Nest runtime environment."
Title,"One caveat to consider is that when your application is compiled using the compile() method, the HttpAdapterHost#httpAdapter will be undefined at that time. This is because there isn't an HTTP adapter or server created yet during this compilation phase. If your test requires the httpAdapter, you should use the createNestApplication() method to create the application instance, or refactor your project to avoid this dependency when initializing the dependencies graph."
Title,"Alright, let's break down the example:"
Title,We save a reference to the running app in our app variable so we can use it to simulate HTTP requests.
Title,"We simulate HTTP tests using the request() function from Supertest. We want these HTTP requests to route to our running Nest app, so we pass the request() function a reference to the HTTP listener that underlies Nest (which, in turn, may be provided by the Express platform). Hence the construction request(app.getHttpServer()). The call to request() hands us a wrapped HTTP Server, now connected to the Nest app, which exposes methods to simulate an actual HTTP request. For example, using request(...).get('/cats') will initiate a request to the Nest app that is identical to an actual HTTP request like get '/cats' coming in over the network."
Title,"In this example, we also provide an alternate (test-double) implementation of the CatsService which simply returns a hard-coded value that we can test for. Use overrideProvider() to provide such an alternate implementation. Similarly, Nest provides methods to override modules, guards, interceptors, filters and pipes with the overrideModule(), overrideGuard(), overrideInterceptor(), overrideFilter(), and overridePipe() methods respectively."
Title,Each of the override methods (except for overrideModule()) returns an object with 3 different methods that mirror those described for custom providers:
Title,
Title,"useClass: you supply a class that will be instantiated to provide the instance to override the object (provider, guard, etc.)."
Title,useValue: you supply an instance that will override the object.
Title,useFactory: you supply a function that returns an instance that will override the object.
Title,
Title,"On the other hand, overrideModule() returns an object with the useModule() method, which you can use to supply a module that will override the original module, as follows:"
Title,typescript
Title,const moduleRef = await Test.createTestingModule({
Title,"imports: [AppModule],"
Title,})
Title,.overrideModule(CatsModule)
Title,.useModule(AlternateCatsModule)
Title,.compile();
Title,"Each of the override method types, in turn, returns the TestingModule instance, and can thus be chained with other methods in the fluent style. You should use compile() at the end of such a chain to cause Nest to instantiate and initialize the module."
Title,"Also, sometimes you may want to provide a custom logger e.g. when the tests are run (for example, on a CI server). Use the setLogger() method and pass an object that fulfills the LoggerService interface to instruct the TestModuleBuilder how to log during tests (by default, only ""error"" logs will be logged to the console)."
Title,"The compiled module has several useful methods, as described in the following table:"
Title,
Title,
Title,
Title,createNestApplication()
Title,
Title,
Title,Creates and returns a Nest application (INestApplication instance) based on the given module.
Title,Note that you must manually initialize the application using the init() method.
Title,
Title,
Title,
Title,
Title,createNestMicroservice()
Title,
Title,
Title,Creates and returns a Nest microservice (INestMicroservice instance) based on the given module.
Title,
Title,
Title,
Title,
Title,get()
Title,
Title,
Title,"Retrieves a static instance of a controller or provider (including guards, filters, etc.) available in the application context. Inherited from the module reference class."
Title,
Title,
Title,
Title,
Title,resolve()
Title,
Title,
Title,"Retrieves a dynamically created scoped instance (request or transient) of a controller or provider (including guards, filters, etc.) available in the application context. Inherited from the module reference class."
Title,
Title,
Title,
Title,
Title,select()
Title,
Title,
Title,Navigates through the module's dependency graph; can be used to retrieve a specific instance from the selected module (used along with strict mode (strict: true) in get() method).
Title,
Title,
Title,
Title,
Title,info Hint Keep your e2e test files inside the test directory. The testing files should have a .e2e-spec suffix.
Title,
Title,Overriding globally registered enhancers
Title,"If you have a globally registered guard (or pipe, interceptor, or filter), you need to take a few more steps to override that enhancer. To recap the original registration looks like this:"
Title,typescript
Title,providers: [
Title,{
Title,"provide: APP_GUARD,"
Title,"useClass: JwtAuthGuard,"
Title,"},"
Title,"],"
Title,"This is registering the guard as a ""multi""-provider through the APP_* token. To be able to replace the JwtAuthGuard here, the registration needs to use an existing provider in this slot:"
Title,typescript
Title,providers: [
Title,{
Title,"provide: APP_GUARD,"
Title,"useExisting: JwtAuthGuard,"
Title,// ^^^^^^^^ notice the use of 'useExisting' instead of 'useClass'
Title,"},"
Title,"JwtAuthGuard,"
Title,"],"
Title,
Title,info Hint Change the useClass to useExisting to reference a registered provider instead of having Nest instantiate it behind the token.
Title,
Title,Now the JwtAuthGuard is visible to Nest as a regular provider that can be overridden when creating the TestingModule:
Title,typescript
Title,const moduleRef = await Test.createTestingModule({
Title,"imports: [AppModule],"
Title,})
Title,.overrideProvider(JwtAuthGuard)
Title,.useClass(MockAuthGuard)
Title,.compile();
Title,Now all your tests will use the MockAuthGuard on every request.
Title,Testing request-scoped instances
Title,"Request-scoped providers are created uniquely for each incoming request. The instance is garbage-collected after the request has completed processing. This poses a problem, because we can't access a dependency injection sub-tree generated specifically for a tested request."
Title,"We know (based on the sections above) that the resolve() method can be used to retrieve a dynamically instantiated class. Also, as described here, we know we can pass a unique context identifier to control the lifecycle of a DI container sub-tree. How do we leverage this in a testing context?"
Title,The strategy is to generate a context identifier beforehand and force Nest to use this particular ID to create a sub-tree for all incoming requests. In this way we'll be able to retrieve instances created for a tested request.
Title,"To accomplish this, use jest.spyOn() on the ContextIdFactory:"
Title,typescript
Title,const contextId = ContextIdFactory.create();
Title,jest
Title,".spyOn(ContextIdFactory, 'getByRequest')"
Title,.mockImplementation(() => contextId);
Title,Now we can use the contextId to access a single generated DI container sub-tree for any subsequent request.
Title,typescript
Title,"catsService = await moduleRef.resolve(CatsService, contextId);"
Title,
Title,CLI Plugin
Title,
Title,warning Warning This chapter applies only to the code first approach.
Title,
Title,"TypeScript's metadata reflection system has several limitations which make it impossible to, for instance, determine what properties a class consists of or recognize whether a given property is optional or required. However, some of these constraints can be addressed at compilation time. Nest provides a plugin that enhances the TypeScript compilation process to reduce the amount of boilerplate code required."
Title,
Title,"info Hint This plugin is opt-in. If you prefer, you can declare all decorators manually, or only specific decorators where you need them."
Title,
Title,Overview
Title,The GraphQL plugin will automatically:
Title,
Title,"annotate all input object, object type and args classes properties with @Field unless @HideField is used"
Title,set the nullable property depending on the question mark (e.g. name?: string will set nullable: true)
Title,set the type property depending on the type (supports arrays as well)
Title,generate descriptions for properties based on comments (if introspectComments set to true)
Title,
Title,"Please, note that your filenames must have one of the following suffixes in order to be analyzed by the plugin: ['.input.ts', '.args.ts', '.entity.ts', '.model.ts'] (e.g., author.entity.ts). If you are using a different suffix, you can adjust the plugin's behavior by specifying the typeFileNameSuffix option (see below)."
Title,"With what we've learned so far, you have to duplicate a lot of code to let the package know how your type should be declared in GraphQL. For example, you could define a simple Author class as follows:"
Title,```typescript
Title,@@filename(authors/models/author.model)
Title,@ObjectType()
Title,export class Author {
Title,@Field(type => ID)
Title,id: number;
Title,@Field({ nullable: true })
Title,firstName?: string;
Title,@Field({ nullable: true })
Title,lastName?: string;
Title,@Field(type => [Post])
Title,posts: Post[];
Title,}
Title,```
Title,"While not a significant issue with medium-sized projects, it becomes verbose & hard to maintain once you have a large set of classes."
Title,"By enabling the GraphQL plugin, the above class definition can be declared simply:"
Title,typescript
Title,@@filename(authors/models/author.model)
Title,@ObjectType()
Title,export class Author {
Title,@Field(type => ID)
Title,id: number;
Title,firstName?: string;
Title,lastName?: string;
Title,posts: Post[];
Title,}
Title,"The plugin adds appropriate decorators on-the-fly based on the Abstract Syntax Tree. Thus, you won't have to struggle with @Field decorators scattered throughout the code."
Title,
Title,"info Hint The plugin will automatically generate any missing GraphQL properties, but if you need to override them, simply set them explicitly via @Field()."
Title,
Title,Comments introspection
Title,"With the comments introspection feature enabled, CLI plugin will generate descriptions for fields based on comments."
Title,"For example, given an example roles property:"
Title,typescript
Title,/**
Title,* A list of user's roles
Title,*/
Title,"@Field(() => [String], {"
Title,description: `A list of user's roles`
Title,})
Title,roles: string[];
Title,"You must duplicate description values. With introspectComments enabled, the CLI plugin can extract these comments and automatically provide descriptions for properties. Now, the above field can be declared simply as follows:"
Title,typescript
Title,/**
Title,* A list of user's roles
Title,*/
Title,roles: string[];
Title,Using the CLI plugin
Title,"To enable the plugin, open nest-cli.json (if you use Nest CLI) and add the following plugins configuration:"
Title,javascript
Title,{
Title,"""collection"": ""@nestjs/schematics"","
Title,"""sourceRoot"": ""src"","
Title,"""compilerOptions"": {"
Title,"""plugins"": [""@nestjs/graphql""]"
Title,}
Title,}
Title,You can use the options property to customize the behavior of the plugin.
Title,javascript
Title,"""plugins"": ["
Title,{
Title,"""name"": ""@nestjs/graphql"","
Title,"""options"": {"
Title,"""typeFileNameSuffix"": ["".input.ts"", "".args.ts""],"
Title,"""introspectComments"": true"
Title,}
Title,}
Title,]
Title,The options property has to fulfill the following interface:
Title,typescript
Title,export interface PluginOptions {
Title,typeFileNameSuffix?: string[];
Title,introspectComments?: boolean;
Title,}
Title,
Title,
Title,Option
Title,Default
Title,Description
Title,
Title,
Title,typeFileNameSuffix
Title,"['.input.ts', '.args.ts', '.entity.ts', '.model.ts']"
Title,GraphQL types files suffix
Title,
Title,
Title,introspectComments
Title,false
Title,"If set to true, plugin will generate descriptions for properties based on comments"
Title,
Title,
Title,"If you don't use the CLI but instead have a custom webpack configuration, you can use this plugin in combination with ts-loader:"
Title,javascript
Title,getCustomTransformers: (program: any) => ({
Title,"before: [require('@nestjs/graphql/plugin').before({}, program)]"
Title,"}),"
Title,SWC builder
Title,"For standard setups (non-monorepo), to use CLI Plugins with the SWC builder, you need to enable type checking, as described here."
Title,bash
Title,$ nest start -b swc --type-check
Title,"For monorepo setups, follow the instructions here."
Title,```bash
Title,$ npx ts-node src/generate-metadata.ts
Title,OR npx ts-node apps/{YOUR_APP}/src/generate-metadata.ts
Title,```
Title,"Now, the serialized metadata file must be loaded by the GraphQLModule method, as shown below:"
Title,```typescript
Title,"import metadata from './metadata'; // <-- file auto-generated by the ""PluginMetadataGenerator"""
Title,GraphQLModule.forRoot<...>({
Title,"..., // other options"
Title,"metadata,"
Title,"}),"
Title,```
Title,Integration with ts-jest (e2e tests)
Title,"When running e2e tests with this plugin enabled, you may run into issues with compiling schema. For example, one of the most common errors is:"
Title,json
Title,Object type <name> must define one or more fields.
Title,This happens because jest configuration does not import @nestjs/graphql/plugin plugin anywhere.
Title,"To fix this, create the following file in your e2e tests directory:"
Title,```javascript
Title,const transformer = require('@nestjs/graphql/plugin');
Title,module.exports.name = 'nestjs-graphql-transformer';
Title,"// you should change the version number anytime you change the configuration below - otherwise, jest will not detect changes"
Title,module.exports.version = 1;
Title,module.exports.factory = (cs) => {
Title,return transformer.before(
Title,{
Title,// @nestjs/graphql/plugin options (can be empty)
Title,"},"
Title,"cs.program, // ""cs.tsCompiler.program"" for older versions of Jest (<= v27)"
Title,);
Title,};
Title,```
Title,"With this in place, import AST transformer within your jest configuration file. By default (in the starter application), e2e tests configuration file is located under the test folder and is named jest-e2e.json."
Title,json
Title,{
Title,... // other configuration
Title,"""globals"": {"
Title,"""ts-jest"": {"
Title,"""astTransformers"": {"
Title,"""before"": [""<path to the file created above>""]"
Title,}
Title,}
Title,}
Title,}
Title,"If you use jest@^29, then use the snippet below, as the previous approach got deprecated."
Title,json
Title,{
Title,... // other configuration
Title,"""transform"": {"
Title,"""^.+\\.(t|j)s$"": ["
Title,"""ts-jest"","
Title,{
Title,"""astTransformers"": {"
Title,"""before"": [""<path to the file created above>""]"
Title,}
Title,}
Title,]
Title,}
Title,}
Title,
Title,Complexity
Title,
Title,warning Warning This chapter applies only to the code first approach.
Title,
Title,"Query complexity allows you to define how complex certain fields are, and to restrict queries with a maximum complexity. The idea is to define how complex each field is by using a simple number. A common default is to give each field a complexity of 1. In addition, the complexity calculation of a GraphQL query can be customized with so-called complexity estimators. A complexity estimator is a simple function that calculates the complexity for a field. You can add any number of complexity estimators to the rule, which are then executed one after another. The first estimator that returns a numeric complexity value determines the complexity for that field."
Title,"The @nestjs/graphql package integrates very well with tools like graphql-query-complexity that provides a cost analysis-based solution. With this library, you can reject queries to your GraphQL server that are deemed too costly to execute."
Title,Installation
Title,"To begin using it, we first install the required dependency."
Title,bash
Title,$ npm install --save graphql-query-complexity
Title,Getting started
Title,"Once the installation process is complete, we can define the ComplexityPlugin class:"
Title,```typescript
Title,"import { GraphQLSchemaHost } from ""@nestjs/graphql"";"
Title,"import { Plugin } from ""@nestjs/apollo"";"
Title,import {
Title,"ApolloServerPlugin,"
Title,"GraphQLRequestListener,"
Title,} from 'apollo-server-plugin-base';
Title,import { GraphQLError } from 'graphql';
Title,import {
Title,"fieldExtensionsEstimator,"
Title,"getComplexity,"
Title,"simpleEstimator,"
Title,} from 'graphql-query-complexity';
Title,@Plugin()
Title,export class ComplexityPlugin implements ApolloServerPlugin {
Title,constructor(private gqlSchemaHost: GraphQLSchemaHost) {}
Title,async requestDidStart(): Promise {
Title,const maxComplexity = 20;
Title,const { schema } = this.gqlSchemaHost;
Title,return {
Title,"async didResolveOperation({ request, document }) {"
Title,const complexity = getComplexity({
Title,"schema,"
Title,"operationName: request.operationName,"
Title,"query: document,"
Title,"variables: request.variables,"
Title,estimators: [
Title,"fieldExtensionsEstimator(),"
Title,"simpleEstimator({ defaultComplexity: 1 }),"
Title,"],"
Title,});
Title,if (complexity > maxComplexity) {
Title,throw new GraphQLError(
Title,"`Query is too complex: ${complexity}. Maximum allowed complexity: ${maxComplexity}`,"
Title,);
Title,}
Title,"console.log('Query Complexity:', complexity);"
Title,"},"
Title,};
Title,
Title,}
Title,}
Title,```
Title,"For demonstration purposes, we specified the maximum allowed complexity as 20. In the example above, we used 2 estimators, the simpleEstimator and the fieldExtensionsEstimator."
Title,
Title,simpleEstimator: the simple estimator returns a fixed complexity for each field
Title,fieldExtensionsEstimator: the field extensions estimator extracts the complexity value for each field of your schema
Title,
Title,
Title,info Hint Remember to add this class to the providers array in any module.
Title,
Title,Field-level complexity
Title,"With this plugin in place, we can now define the complexity for any field by specifying the complexity property in the options object passed into the @Field() decorator, as follows:"
Title,typescript
Title,@Field({ complexity: 3 })
Title,title: string;
Title,"Alternatively, you can define the estimator function:"
Title,typescript
Title,@Field({ complexity: (options: ComplexityEstimatorArgs) => ... })
Title,title: string;
Title,Query/Mutation-level complexity
Title,"In addition, @Query() and @Mutation() decorators may have a complexity property specified like so:"
Title,typescript
Title,@Query({ complexity: (options: ComplexityEstimatorArgs) => options.args.count * options.childComplexity })
Title,items(@Args('count') count: number) {
Title,return this.itemsService.getItems({ count });
Title,}
Title,
Title,Directives
Title,"A directive can be attached to a field or fragment inclusion, and can affect execution of the query in any way the server desires (read more here). The GraphQL specification provides several default directives:"
Title,
Title,@include(if: Boolean) - only include this field in the result if the argument is true
Title,@skip(if: Boolean) - skip this field if the argument is true
Title,@deprecated(reason: String) - marks field as deprecated with message
Title,
Title,"A directive is an identifier preceded by a @ character, optionally followed by a list of named arguments, which can appear after almost any element in the GraphQL query and schema languages."
Title,Custom directives
Title,"To instruct what should happen when Apollo/Mercurius encounters your directive, you can create a transformer function. This function uses the mapSchema function to iterate through locations in your schema (field definitions, type definitions, etc.) and perform corresponding transformations."
Title,```typescript
Title,"import { getDirective, MapperKind, mapSchema } from '@graphql-tools/utils';"
Title,"import { defaultFieldResolver, GraphQLSchema } from 'graphql';"
Title,export function upperDirectiveTransformer(
Title,"schema: GraphQLSchema,"
Title,"directiveName: string,"
Title,) {
Title,"return mapSchema(schema, {"
Title,[MapperKind.OBJECT_FIELD]: (fieldConfig) => {
Title,const upperDirective = getDirective(
Title,"schema,"
Title,"fieldConfig,"
Title,"directiveName,"
Title,)?.[0];
Title,if (upperDirective) {
Title,const { resolve = defaultFieldResolver } = fieldConfig;
Title,
Title,// Replace the original resolver with a function that *first* calls
Title,"// the original resolver, then converts its result to upper case"
Title,"fieldConfig.resolve = async function (source, args, context, info) {"
Title,"const result = await resolve(source, args, context, info);"
Title,if (typeof result === 'string') {
Title,return result.toUpperCase();
Title,}
Title,return result;
Title,};
Title,return fieldConfig;
Title,}
Title,"},"
Title,
Title,});
Title,}
Title,```
Title,"Now, apply the upperDirectiveTransformer transformation function in the GraphQLModule#forRoot method using the transformSchema function:"
Title,typescript
Title,GraphQLModule.forRoot({
Title,// ...
Title,"transformSchema: (schema) => upperDirectiveTransformer(schema, 'upper'),"
Title,});
Title,"Once registered, the @upper directive can be used in our schema. However, the way you apply the directive will vary depending on the approach you use (code first or schema first)."
Title,Code first
Title,"In the code first approach, use the @Directive() decorator to apply the directive."
Title,typescript
Title,@Directive('@upper')
Title,@Field()
Title,title: string;
Title,
Title,info Hint The @Directive() decorator is exported from the @nestjs/graphql package.
Title,
Title,"Directives can be applied on fields, field resolvers, input and object types, as well as queries, mutations, and subscriptions. Here's an example of the directive applied on the query handler level:"
Title,typescript
Title,"@Directive('@deprecated(reason: ""This query will be removed in the next version"")')"
Title,"@Query(() => Author, { name: 'author' })"
Title,"async getAuthor(@Args({ name: 'id', type: () => Int }) id: number) {"
Title,return this.authorsService.findOneById(id);
Title,}
Title,
Title,warn Warning Directives applied through the @Directive() decorator will not be reflected in the generated schema definition file.
Title,
Title,"Lastly, make sure to declare directives in the GraphQLModule, as follows:"
Title,typescript
Title,GraphQLModule.forRoot({
Title,"// ...,"
Title,"transformSchema: schema => upperDirectiveTransformer(schema, 'upper'),"
Title,buildSchemaOptions: {
Title,directives: [
Title,new GraphQLDirective({
Title,"name: 'upper',"
Title,"locations: [DirectiveLocation.FIELD_DEFINITION],"
Title,"}),"
Title,"],"
Title,"},"
Title,"}),"
Title,
Title,info Hint Both GraphQLDirective and DirectiveLocation are exported from the graphql package.
Title,
Title,Schema first
Title,"In the schema first approach, apply directives directly in SDL."
Title,```graphql
Title,directive @upper on FIELD_DEFINITION
Title,type Post {
Title,id: Int!
Title,title: String! @upper
Title,votes: Int
Title,}
Title,```
Title,
Title,Extensions
Title,
Title,warning Warning This chapter applies only to the code first approach.
Title,
Title,"Extensions is an advanced, low-level feature that lets you define arbitrary data in the types configuration. Attaching custom metadata to certain fields allows you to create more sophisticated, generic solutions. For example, with extensions, you can define field-level roles required to access particular fields. Such roles can be reflected at runtime to determine whether the caller has sufficient permissions to retrieve a specific field."
Title,Adding custom metadata
Title,"To attach custom metadata for a field, use the @Extensions() decorator exported from the @nestjs/graphql package."
Title,typescript
Title,@Field()
Title,@Extensions({ role: Role.ADMIN })
Title,password: string;
Title,"In the example above, we assigned the role metadata property the value of Role.ADMIN. Role is a simple TypeScript enum that groups all the user roles available in our system."
Title,"Note, in addition to setting metadata on fields, you can use the @Extensions() decorator at the class level and method level (e.g., on the query handler)."
Title,Using custom metadata
Title,"Logic that leverages the custom metadata can be as complex as needed. For example, you can create a simple interceptor that stores/logs events per method invocation, or a field middleware that matches roles required to retrieve a field with the caller permissions (field-level permissions system)."
Title,"For illustration purposes, let's define a checkRoleMiddleware that compares a user's role (hardcoded here) with a role required to access a target field:"
Title,```typescript
Title,export const checkRoleMiddleware: FieldMiddleware = async (
Title,"ctx: MiddlewareContext,"
Title,"next: NextFn,"
Title,) => {
Title,const { info } = ctx;
Title,const { extensions } = info.parentType.getFields()[info.fieldName];
Title,/*
Title,"* In a real-world application, the ""userRole"" variable"
Title,"* should represent the caller's (user) role (for example, ""ctx.user.role"")."
Title,/
Title,const userRole = Role.USER;
Title,if (userRole === extensions.role) {
Title,"// or just ""return null"" to ignore"
Title,throw new ForbiddenException(
Title,"User does not have sufficient permissions to access ""${info.fieldName}"" field.,"
Title,);
Title,}
Title,return next();
Title,};
Title,```
Title,"With this in place, we can register a middleware for the password field, as follows:"
Title,typescript
Title,@Field({ middleware: [checkRoleMiddleware] })
Title,@Extensions({ role: Role.ADMIN })
Title,password: string;
Title,
Title,Federation
Title,Federation offers a means of splitting your monolithic GraphQL server into independent microservices. It consists of two components: a gateway and one or more federated microservices. Each microservice holds part of the schema and the gateway merges the schemas into a single schema that can be consumed by the client.
Title,"To quote the Apollo docs, Federation is designed with these core principles:"
Title,
Title,"Building a graph should be declarative. With federation, you compose a graph declaratively from within your schema instead of writing imperative schema stitching code."
Title,"Code should be separated by concern, not by types. Often no single team controls every aspect of an important type like a User or Product, so the definition of these types should be distributed across teams and codebases, rather than centralized."
Title,"The graph should be simple for clients to consume. Together, federated services can form a complete, product-focused graph that accurately reflects how it’s being consumed on the client."
Title,"It’s just GraphQL, using only spec-compliant features of the language. Any language, not just JavaScript, can implement federation."
Title,
Title,
Title,warning Warning Federation currently does not support subscriptions.
Title,
Title,"In the following sections, we'll set up a demo application that consists of a gateway and two federated endpoints: Users service and Posts service."
Title,Federation with Apollo
Title,Start by installing the required dependencies:
Title,bash
Title,$ npm install --save @apollo/subgraph
Title,Schema first
Title,"The ""User service"" provides a simple schema. Note the @key directive: it instructs the Apollo query planner that a particular instance of User can be fetched if you specify its id. Also, note that we extend the Query type."
Title,```graphql
Title,"type User @key(fields: ""id"") {"
Title,id: ID!
Title,name: String!
Title,}
Title,extend type Query {
Title,getUser(id: ID!): User
Title,}
Title,```
Title,Resolver provides one additional method named resolveReference(). This method is triggered by the Apollo Gateway whenever a related resource requires a User instance. We'll see an example of this in the Posts service later. Please note that the method must be annotated with the @ResolveReference() decorator.
Title,```typescript
Title,"import { Args, Query, Resolver, ResolveReference } from '@nestjs/graphql';"
Title,import { UsersService } from './users.service';
Title,@Resolver('User')
Title,export class UsersResolver {
Title,constructor(private usersService: UsersService) {}
Title,@Query()
Title,getUser(@Args('id') id: string) {
Title,return this.usersService.findById(id);
Title,}
Title,@ResolveReference()
Title,resolveReference(reference: { __typename: string; id: string }) {
Title,return this.usersService.findById(reference.id);
Title,}
Title,}
Title,```
Title,"Finally, we hook everything up by registering the GraphQLModule passing the ApolloFederationDriver driver in the configuration object:"
Title,```typescript
Title,import {
Title,"ApolloFederationDriver,"
Title,"ApolloFederationDriverConfig,"
Title,} from '@nestjs/apollo';
Title,import { Module } from '@nestjs/common';
Title,import { GraphQLModule } from '@nestjs/graphql';
Title,import { UsersResolver } from './users.resolver';
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"driver: ApolloFederationDriver,"
Title,"typePaths: ['*/.graphql'],"
Title,"}),"
Title,"],"
Title,"providers: [UsersResolver],"
Title,})
Title,export class AppModule {}
Title,```
Title,Code first
Title,Start by adding some extra decorators to the User entity.
Title,```ts
Title,"import { Directive, Field, ID, ObjectType } from '@nestjs/graphql';"
Title,@ObjectType()
Title,"@Directive('@key(fields: ""id"")')"
Title,export class User {
Title,@Field(() => ID)
Title,id: number;
Title,@Field()
Title,name: string;
Title,}
Title,```
Title,Resolver provides one additional method named resolveReference(). This method is triggered by the Apollo Gateway whenever a related resource requires a User instance. We'll see an example of this in the Posts service later. Please note that the method must be annotated with the @ResolveReference() decorator.
Title,```ts
Title,"import { Args, Query, Resolver, ResolveReference } from '@nestjs/graphql';"
Title,import { User } from './user.entity';
Title,import { UsersService } from './users.service';
Title,@Resolver(() => User)
Title,export class UsersResolver {
Title,constructor(private usersService: UsersService) {}
Title,@Query(() => User)
Title,getUser(@Args('id') id: number): User {
Title,return this.usersService.findById(id);
Title,}
Title,@ResolveReference()
Title,resolveReference(reference: { __typename: string; id: number }): User {
Title,return this.usersService.findById(reference.id);
Title,}
Title,}
Title,```
Title,"Finally, we hook everything up by registering the GraphQLModule passing the ApolloFederationDriver driver in the configuration object:"
Title,```typescript
Title,import {
Title,"ApolloFederationDriver,"
Title,"ApolloFederationDriverConfig,"
Title,} from '@nestjs/apollo';
Title,import { Module } from '@nestjs/common';
Title,import { UsersResolver } from './users.resolver';
Title,import { UsersService } from './users.service'; // Not included in this example
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"driver: ApolloFederationDriver,"
Title,"autoSchemaFile: true,"
Title,"}),"
Title,"],"
Title,"providers: [UsersResolver, UsersService],"
Title,})
Title,export class AppModule {}
Title,```
Title,A working example is available here in code first mode and here in schema first mode.
Title,Federated example: Posts
Title,"Post service is supposed to serve aggregated posts through the getPosts query, but also extend our User type with the user.posts field."
Title,Schema first
Title,"""Posts service"" references the User type in its schema by marking it with the extend keyword. It also declares one additional property on the User type (posts). Note the @key directive used for matching instances of User, and the @external directive indicating that the id field is managed elsewhere."
Title,```graphql
Title,"type Post @key(fields: ""id"") {"
Title,id: ID!
Title,title: String!
Title,body: String!
Title,user: User
Title,}
Title,"extend type User @key(fields: ""id"") {"
Title,id: ID! @external
Title,posts: [Post]
Title,}
Title,extend type Query {
Title,getPosts: [Post]
Title,}
Title,```
Title,"In the following example, the PostsResolver provides the getUser() method that returns a reference containing __typename and some additional properties your application may need to resolve the reference, in this case id. __typename is used by the GraphQL Gateway to pinpoint the microservice responsible for the User type and retrieve the corresponding instance. The ""Users service"" described above will be requested upon execution of the resolveReference() method."
Title,```typescript
Title,"import { Query, Resolver, Parent, ResolveField } from '@nestjs/graphql';"
Title,import { PostsService } from './posts.service';
Title,import { Post } from './posts.interfaces';
Title,@Resolver('Post')
Title,export class PostsResolver {
Title,constructor(private postsService: PostsService) {}
Title,@Query('getPosts')
Title,getPosts() {
Title,return this.postsService.findAll();
Title,}
Title,@ResolveField('user')
Title,getUser(@Parent() post: Post) {
Title,"return { __typename: 'User', id: post.userId };"
Title,}
Title,}
Title,```
Title,"Lastly, we must register the GraphQLModule, similarly to what we did in the ""Users service"" section."
Title,```typescript
Title,import {
Title,"ApolloFederationDriver,"
Title,"ApolloFederationDriverConfig,"
Title,} from '@nestjs/apollo';
Title,import { Module } from '@nestjs/common';
Title,import { GraphQLModule } from '@nestjs/graphql';
Title,import { PostsResolver } from './posts.resolver';
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"driver: ApolloFederationDriver,"
Title,"typePaths: ['*/.graphql'],"
Title,"}),"
Title,"],"
Title,"providers: [PostsResolvers],"
Title,})
Title,export class AppModule {}
Title,```
Title,Code first
Title,"First, we will have to declare a class representing the User entity. Although the entity itself lives in another service, we will be using it (extending its definition) here. Note the @extends and @external directives."
Title,```ts
Title,"import { Directive, ObjectType, Field, ID } from '@nestjs/graphql';"
Title,import { Post } from './post.entity';
Title,@ObjectType()
Title,@Directive('@extends')
Title,"@Directive('@key(fields: ""id"")')"
Title,export class User {
Title,@Field(() => ID)
Title,@Directive('@external')
Title,id: number;
Title,@Field(() => [Post])
Title,posts?: Post[];
Title,}
Title,```
Title,"Now let's create the corresponding resolver for our extension on the User entity, as follows:"
Title,```ts
Title,"import { Parent, ResolveField, Resolver } from '@nestjs/graphql';"
Title,import { PostsService } from './posts.service';
Title,import { Post } from './post.entity';
Title,import { User } from './user.entity';
Title,@Resolver(() => User)
Title,export class UsersResolver {
Title,constructor(private readonly postsService: PostsService) {}
Title,@ResolveField(() => [Post])
Title,public posts(@Parent() user: User): Post[] {
Title,return this.postsService.forAuthor(user.id);
Title,}
Title,}
Title,```
Title,We also have to define the Post entity class:
Title,```ts
Title,"import { Directive, Field, ID, Int, ObjectType } from '@nestjs/graphql';"
Title,import { User } from './user.entity';
Title,@ObjectType()
Title,"@Directive('@key(fields: ""id"")')"
Title,export class Post {
Title,@Field(() => ID)
Title,id: number;
Title,@Field()
Title,title: string;
Title,@Field(() => Int)
Title,authorId: number;
Title,@Field(() => User)
Title,user?: User;
Title,}
Title,```
Title,And its resolver:
Title,```ts
Title,"import { Query, Args, ResolveField, Resolver, Parent } from '@nestjs/graphql';"
Title,import { PostsService } from './posts.service';
Title,import { Post } from './post.entity';
Title,import { User } from './user.entity';
Title,@Resolver(() => Post)
Title,export class PostsResolver {
Title,constructor(private readonly postsService: PostsService) {}
Title,@Query(() => Post)
Title,findPost(@Args('id') id: number): Post {
Title,return this.postsService.findOne(id);
Title,}
Title,@Query(() => [Post])
Title,getPosts(): Post[] {
Title,return this.postsService.all();
Title,}
Title,@ResolveField(() => User)
Title,user(@Parent() post: Post): any {
Title,"return { __typename: 'User', id: post.authorId };"
Title,}
Title,}
Title,```
Title,"And finally, tie it together in a module. Note the schema build options, where we specify that User is an orphaned (external) type."
Title,```ts
Title,import {
Title,"ApolloFederationDriver,"
Title,"ApolloFederationDriverConfig,"
Title,} from '@nestjs/apollo';
Title,import { Module } from '@nestjs/common';
Title,import { User } from './user.entity';
Title,import { PostsResolvers } from './posts.resolvers';
Title,import { UsersResolvers } from './users.resolvers';
Title,import { PostsService } from './posts.service'; // Not included in example
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"driver: ApolloFederationDriver,"
Title,"autoSchemaFile: true,"
Title,buildSchemaOptions: {
Title,"orphanedTypes: [User],"
Title,"},"
Title,"}),"
Title,"],"
Title,"providers: [PostsResolver, UsersResolver, PostsService],"
Title,})
Title,export class AppModule {}
Title,```
Title,A working example is available here for the code first mode and here for the schema first mode.
Title,Federated example: Gateway
Title,Start by installing the required dependency:
Title,bash
Title,$ npm install --save @apollo/gateway
Title,The gateway requires a list of endpoints to be specified and it will auto-discover the corresponding schemas. Therefore the implementation of the gateway service will remain the same for both code and schema first approaches.
Title,```typescript
Title,import { IntrospectAndCompose } from '@apollo/gateway';
Title,"import { ApolloGatewayDriver, ApolloGatewayDriverConfig } from '@nestjs/apollo';"
Title,import { Module } from '@nestjs/common';
Title,import { GraphQLModule } from '@nestjs/graphql';
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"driver: ApolloGatewayDriver,"
Title,server: {
Title,// ... Apollo server options
Title,"cors: true,"
Title,"},"
Title,gateway: {
Title,supergraphSdl: new IntrospectAndCompose({
Title,subgraphs: [
Title,"{ name: 'users', url: 'http://user-service/graphql' },"
Title,"{ name: 'posts', url: 'http://post-service/graphql' },"
Title,"],"
Title,"}),"
Title,"},"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,A working example is available here for the code first mode and here for the schema first mode.
Title,Federation with Mercurius
Title,Start by installing the required dependencies:
Title,bash
Title,$ npm install --save @apollo/subgraph @nestjs/mercurius
Title,
Title,"info Note The @apollo/subgraph package is required to build a subgraph schema (buildSubgraphSchema, printSubgraphSchema functions)."
Title,
Title,Schema first
Title,"The ""User service"" provides a simple schema. Note the @key directive: it instructs the Mercurius query planner that a particular instance of User can be fetched if you specify its id. Also, note that we extend the Query type."
Title,```graphql
Title,"type User @key(fields: ""id"") {"
Title,id: ID!
Title,name: String!
Title,}
Title,extend type Query {
Title,getUser(id: ID!): User
Title,}
Title,```
Title,Resolver provides one additional method named resolveReference(). This method is triggered by the Mercurius Gateway whenever a related resource requires a User instance. We'll see an example of this in the Posts service later. Please note that the method must be annotated with the @ResolveReference() decorator.
Title,```typescript
Title,"import { Args, Query, Resolver, ResolveReference } from '@nestjs/graphql';"
Title,import { UsersService } from './users.service';
Title,@Resolver('User')
Title,export class UsersResolver {
Title,constructor(private usersService: UsersService) {}
Title,@Query()
Title,getUser(@Args('id') id: string) {
Title,return this.usersService.findById(id);
Title,}
Title,@ResolveReference()
Title,resolveReference(reference: { __typename: string; id: string }) {
Title,return this.usersService.findById(reference.id);
Title,}
Title,}
Title,```
Title,"Finally, we hook everything up by registering the GraphQLModule passing the MercuriusFederationDriver driver in the configuration object:"
Title,```typescript
Title,import {
Title,"MercuriusFederationDriver,"
Title,"MercuriusFederationDriverConfig,"
Title,} from '@nestjs/mercurius';
Title,import { Module } from '@nestjs/common';
Title,import { GraphQLModule } from '@nestjs/graphql';
Title,import { UsersResolver } from './users.resolver';
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"driver: MercuriusFederationDriver,"
Title,"typePaths: ['*/.graphql'],"
Title,"federationMetadata: true,"
Title,"}),"
Title,"],"
Title,"providers: [UsersResolver],"
Title,})
Title,export class AppModule {}
Title,```
Title,Code first
Title,Start by adding some extra decorators to the User entity.
Title,```ts
Title,"import { Directive, Field, ID, ObjectType } from '@nestjs/graphql';"
Title,@ObjectType()
Title,"@Directive('@key(fields: ""id"")')"
Title,export class User {
Title,@Field(() => ID)
Title,id: number;
Title,@Field()
Title,name: string;
Title,}
Title,```
Title,Resolver provides one additional method named resolveReference(). This method is triggered by the Mercurius Gateway whenever a related resource requires a User instance. We'll see an example of this in the Posts service later. Please note that the method must be annotated with the @ResolveReference() decorator.
Title,```ts
Title,"import { Args, Query, Resolver, ResolveReference } from '@nestjs/graphql';"
Title,import { User } from './user.entity';
Title,import { UsersService } from './users.service';
Title,@Resolver(() => User)
Title,export class UsersResolver {
Title,constructor(private usersService: UsersService) {}
Title,@Query(() => User)
Title,getUser(@Args('id') id: number): User {
Title,return this.usersService.findById(id);
Title,}
Title,@ResolveReference()
Title,resolveReference(reference: { __typename: string; id: number }): User {
Title,return this.usersService.findById(reference.id);
Title,}
Title,}
Title,```
Title,"Finally, we hook everything up by registering the GraphQLModule passing the MercuriusFederationDriver driver in the configuration object:"
Title,```typescript
Title,import {
Title,"MercuriusFederationDriver,"
Title,"MercuriusFederationDriverConfig,"
Title,} from '@nestjs/mercurius';
Title,import { Module } from '@nestjs/common';
Title,import { UsersResolver } from './users.resolver';
Title,import { UsersService } from './users.service'; // Not included in this example
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"driver: MercuriusFederationDriver,"
Title,"autoSchemaFile: true,"
Title,"federationMetadata: true,"
Title,"}),"
Title,"],"
Title,"providers: [UsersResolver, UsersService],"
Title,})
Title,export class AppModule {}
Title,```
Title,Federated example: Posts
Title,"Post service is supposed to serve aggregated posts through the getPosts query, but also extend our User type with the user.posts field."
Title,Schema first
Title,"""Posts service"" references the User type in its schema by marking it with the extend keyword. It also declares one additional property on the User type (posts). Note the @key directive used for matching instances of User, and the @external directive indicating that the id field is managed elsewhere."
Title,```graphql
Title,"type Post @key(fields: ""id"") {"
Title,id: ID!
Title,title: String!
Title,body: String!
Title,user: User
Title,}
Title,"extend type User @key(fields: ""id"") {"
Title,id: ID! @external
Title,posts: [Post]
Title,}
Title,extend type Query {
Title,getPosts: [Post]
Title,}
Title,```
Title,"In the following example, the PostsResolver provides the getUser() method that returns a reference containing __typename and some additional properties your application may need to resolve the reference, in this case id. __typename is used by the GraphQL Gateway to pinpoint the microservice responsible for the User type and retrieve the corresponding instance. The ""Users service"" described above will be requested upon execution of the resolveReference() method."
Title,```typescript
Title,"import { Query, Resolver, Parent, ResolveField } from '@nestjs/graphql';"
Title,import { PostsService } from './posts.service';
Title,import { Post } from './posts.interfaces';
Title,@Resolver('Post')
Title,export class PostsResolver {
Title,constructor(private postsService: PostsService) {}
Title,@Query('getPosts')
Title,getPosts() {
Title,return this.postsService.findAll();
Title,}
Title,@ResolveField('user')
Title,getUser(@Parent() post: Post) {
Title,"return { __typename: 'User', id: post.userId };"
Title,}
Title,}
Title,```
Title,"Lastly, we must register the GraphQLModule, similarly to what we did in the ""Users service"" section."
Title,```typescript
Title,import {
Title,"MercuriusFederationDriver,"
Title,"MercuriusFederationDriverConfig,"
Title,} from '@nestjs/mercurius';
Title,import { Module } from '@nestjs/common';
Title,import { GraphQLModule } from '@nestjs/graphql';
Title,import { PostsResolver } from './posts.resolver';
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"driver: MercuriusFederationDriver,"
Title,"federationMetadata: true,"
Title,"typePaths: ['*/.graphql'],"
Title,"}),"
Title,"],"
Title,"providers: [PostsResolvers],"
Title,})
Title,export class AppModule {}
Title,```
Title,Code first
Title,"First, we will have to declare a class representing the User entity. Although the entity itself lives in another service, we will be using it (extending its definition) here. Note the @extends and @external directives."
Title,```ts
Title,"import { Directive, ObjectType, Field, ID } from '@nestjs/graphql';"
Title,import { Post } from './post.entity';
Title,@ObjectType()
Title,@Directive('@extends')
Title,"@Directive('@key(fields: ""id"")')"
Title,export class User {
Title,@Field(() => ID)
Title,@Directive('@external')
Title,id: number;
Title,@Field(() => [Post])
Title,posts?: Post[];
Title,}
Title,```
Title,"Now let's create the corresponding resolver for our extension on the User entity, as follows:"
Title,```ts
Title,"import { Parent, ResolveField, Resolver } from '@nestjs/graphql';"
Title,import { PostsService } from './posts.service';
Title,import { Post } from './post.entity';
Title,import { User } from './user.entity';
Title,@Resolver(() => User)
Title,export class UsersResolver {
Title,constructor(private readonly postsService: PostsService) {}
Title,@ResolveField(() => [Post])
Title,public posts(@Parent() user: User): Post[] {
Title,return this.postsService.forAuthor(user.id);
Title,}
Title,}
Title,```
Title,We also have to define the Post entity class:
Title,```ts
Title,"import { Directive, Field, ID, Int, ObjectType } from '@nestjs/graphql';"
Title,import { User } from './user.entity';
Title,@ObjectType()
Title,"@Directive('@key(fields: ""id"")')"
Title,export class Post {
Title,@Field(() => ID)
Title,id: number;
Title,@Field()
Title,title: string;
Title,@Field(() => Int)
Title,authorId: number;
Title,@Field(() => User)
Title,user?: User;
Title,}
Title,```
Title,And its resolver:
Title,```ts
Title,"import { Query, Args, ResolveField, Resolver, Parent } from '@nestjs/graphql';"
Title,import { PostsService } from './posts.service';
Title,import { Post } from './post.entity';
Title,import { User } from './user.entity';
Title,@Resolver(() => Post)
Title,export class PostsResolver {
Title,constructor(private readonly postsService: PostsService) {}
Title,@Query(() => Post)
Title,findPost(@Args('id') id: number): Post {
Title,return this.postsService.findOne(id);
Title,}
Title,@Query(() => [Post])
Title,getPosts(): Post[] {
Title,return this.postsService.all();
Title,}
Title,@ResolveField(() => User)
Title,user(@Parent() post: Post): any {
Title,"return { __typename: 'User', id: post.authorId };"
Title,}
Title,}
Title,```
Title,"And finally, tie it together in a module. Note the schema build options, where we specify that User is an orphaned (external) type."
Title,```ts
Title,import {
Title,"MercuriusFederationDriver,"
Title,"MercuriusFederationDriverConfig,"
Title,} from '@nestjs/mercurius';
Title,import { Module } from '@nestjs/common';
Title,import { User } from './user.entity';
Title,import { PostsResolvers } from './posts.resolvers';
Title,import { UsersResolvers } from './users.resolvers';
Title,import { PostsService } from './posts.service'; // Not included in example
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"driver: MercuriusFederationDriver,"
Title,"autoSchemaFile: true,"
Title,"federationMetadata: true,"
Title,buildSchemaOptions: {
Title,"orphanedTypes: [User],"
Title,"},"
Title,"}),"
Title,"],"
Title,"providers: [PostsResolver, UsersResolver, PostsService],"
Title,})
Title,export class AppModule {}
Title,```
Title,Federated example: Gateway
Title,The gateway requires a list of endpoints to be specified and it will auto-discover the corresponding schemas. Therefore the implementation of the gateway service will remain the same for both code and schema first approaches.
Title,```typescript
Title,import {
Title,"MercuriusGatewayDriver,"
Title,"MercuriusGatewayDriverConfig,"
Title,} from '@nestjs/mercurius';
Title,import { Module } from '@nestjs/common';
Title,import { GraphQLModule } from '@nestjs/graphql';
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"driver: MercuriusGatewayDriver,"
Title,gateway: {
Title,services: [
Title,"{ name: 'users', url: 'http://user-service/graphql' },"
Title,"{ name: 'posts', url: 'http://post-service/graphql' },"
Title,"],"
Title,"},"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,Federation 2
Title,"To quote the Apollo docs, Federation 2 improves developer experience from the original Apollo Federation (called Federation 1 in this doc), which is backward compatible with most original supergraphs."
Title,
Title,warning Warning Mercurius doesn't fully support Federation 2. You can see the list of libraries that support Federation 2 here.
Title,
Title,"In the following sections, we'll upgrade the previous example to Federation 2."
Title,Federated example: Users
Title,"One change in Federation 2 is that entities have no originating subgraph, so we don't need to extend Query anymore. For more detail please refer to the entities topic in Apollo Federation 2 docs."
Title,Schema first
Title,We can simply remove extend keyword from the schema.
Title,```graphql
Title,"type User @key(fields: ""id"") {"
Title,id: ID!
Title,name: String!
Title,}
Title,type Query {
Title,getUser(id: ID!): User
Title,}
Title,```
Title,Code first
Title,"To use Federation 2, we need to specify the federation version in autoSchemaFile option."
Title,```ts
Title,import {
Title,"ApolloFederationDriver,"
Title,"ApolloFederationDriverConfig,"
Title,} from '@nestjs/apollo';
Title,import { Module } from '@nestjs/common';
Title,import { UsersResolver } from './users.resolver';
Title,import { UsersService } from './users.service'; // Not included in this example
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"driver: ApolloFederationDriver,"
Title,autoSchemaFile: {
Title,"federation: 2,"
Title,"},"
Title,"}),"
Title,"],"
Title,"providers: [UsersResolver, UsersService],"
Title,})
Title,export class AppModule {}
Title,```
Title,Federated example: Posts
Title,"With the same reason as above, we don't need to extend User and Query anymore."
Title,Schema first
Title,We can simply remove extend and external directives from the schema
Title,```graphql
Title,"type Post @key(fields: ""id"") {"
Title,id: ID!
Title,title: String!
Title,body: String!
Title,user: User
Title,}
Title,"type User @key(fields: ""id"") {"
Title,id: ID!
Title,posts: [Post]
Title,}
Title,type Query {
Title,getPosts: [Post]
Title,}
Title,```
Title,Code first
Title,"Since we don't extend User entity anymore, we can simply remove extends and external directives from User."
Title,```ts
Title,"import { Directive, ObjectType, Field, ID } from '@nestjs/graphql';"
Title,import { Post } from './post.entity';
Title,@ObjectType()
Title,"@Directive('@key(fields: ""id"")')"
Title,export class User {
Title,@Field(() => ID)
Title,id: number;
Title,@Field(() => [Post])
Title,posts?: Post[];
Title,}
Title,```
Title,"Also, similarly to the User service, we need to specify in the GraphQLModule to use Federation 2."
Title,```ts
Title,import {
Title,"ApolloFederationDriver,"
Title,"ApolloFederationDriverConfig,"
Title,} from '@nestjs/apollo';
Title,import { Module } from '@nestjs/common';
Title,import { User } from './user.entity';
Title,import { PostsResolvers } from './posts.resolvers';
Title,import { UsersResolvers } from './users.resolvers';
Title,import { PostsService } from './posts.service'; // Not included in example
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"driver: ApolloFederationDriver,"
Title,autoSchemaFile: {
Title,"federation: 2,"
Title,"},"
Title,buildSchemaOptions: {
Title,"orphanedTypes: [User],"
Title,"},"
Title,"}),"
Title,"],"
Title,"providers: [PostsResolver, UsersResolver, PostsService],"
Title,})
Title,export class AppModule {}
Title,```
Title,
Title,Field middleware
Title,
Title,warning Warning This chapter applies only to the code first approach.
Title,
Title,"Field Middleware lets you run arbitrary code before or after a field is resolved. A field middleware can be used to convert the result of a field, validate the arguments of a field, or even check field-level roles (for example, required to access a target field for which a middleware function is executed)."
Title,"You can connect multiple middleware functions to a field. In this case, they will be called sequentially along the chain where the previous middleware decides to call the next one. The order of the middleware functions in the middleware array is important. The first resolver is the ""most-outer"" layer, so it gets executed first and last (similarly to the graphql-middleware package). The second resolver is the ""second-outer"" layer, so it gets executed second and second to last."
Title,Getting started
Title,Let's start off by creating a simple middleware that will log a field value before it's sent back to the client:
Title,```typescript
Title,"import { FieldMiddleware, MiddlewareContext, NextFn } from '@nestjs/graphql';"
Title,const loggerMiddleware: FieldMiddleware = async (
Title,"ctx: MiddlewareContext,"
Title,"next: NextFn,"
Title,) => {
Title,const value = await next();
Title,console.log(value);
Title,return value;
Title,};
Title,```
Title,
Title,"info Hint The MiddlewareContext is an object that consist of the same arguments that are normally received by the GraphQL resolver function ({{ '{' }} source, args, context, info {{ '}' }}), while NextFn is a function that let you execute the next middleware in the stack (bound to this field) or the actual field resolver."
Title,"warning Warning Field middleware functions cannot inject dependencies nor access Nest's DI container as they are designed to be very lightweight and shouldn't perform any potentially time-consuming operations (like retrieving data from the database). If you need to call external services/query data from the data source, you should do it in a guard/interceptor bounded to a root query/mutation handler and assign it to context object which you can access from within the field middleware (specifically, from the MiddlewareContext object)."
Title,
Title,"Note that field middleware must match the FieldMiddleware interface. In the example above, we first run the next() function (which executes the actual field resolver and returns a field value) and then, we log this value to our terminal. Also, the value returned from the middleware function completely overrides the previous value and since we don't want to perform any changes, we simply return the original value."
Title,"With this in place, we can register our middleware directly in the @Field() decorator, as follows:"
Title,typescript
Title,@ObjectType()
Title,export class Recipe {
Title,@Field({ middleware: [loggerMiddleware] })
Title,title: string;
Title,}
Title,"Now whenever we request the title field of Recipe object type, the original field's value will be logged to the console."
Title,
Title,"info Hint To learn how you can implement a field-level permissions system with the use of extensions feature, check out this section."
Title,"warning Warning Field middleware can be applied only to ObjectType classes. For more details, check out this issue."
Title,
Title,"Also, as mentioned above, we can control the field's value from within the middleware function. For demonstration purposes, let's capitalise a recipe's title (if present):"
Title,typescript
Title,const value = await next();
Title,return value?.toUpperCase();
Title,"In this case, every title will be automatically uppercased, when requested."
Title,"Likewise, you can bind a field middleware to a custom field resolver (a method annotated with the @ResolveField() decorator), as follows:"
Title,typescript
Title,"@ResolveField(() => String, { middleware: [loggerMiddleware] })"
Title,title() {
Title,return 'Placeholder';
Title,}
Title,
Title,"warning Warning In case enhancers are enabled at the field resolver level (read more), field middleware functions will run before any interceptors, guards, etc., bounded to the method (but after the root-level enhancers registered for query or mutation handlers)."
Title,
Title,Global field middleware
Title,"In addition to binding a middleware directly to a specific field, you can also register one or multiple middleware functions globally. In this case, they will be automatically connected to all fields of your object types."
Title,typescript
Title,GraphQLModule.forRoot({
Title,"autoSchemaFile: 'schema.gql',"
Title,buildSchemaOptions: {
Title,"fieldMiddleware: [loggerMiddleware],"
Title,"},"
Title,"}),"
Title,
Title,info Hint Globally registered field middleware functions will be executed before locally registered ones (those bound directly to specific fields).
Title,
Title,
Title,Other features
Title,"In the GraphQL world, there is a lot of debate about handling issues like authentication, or side-effects of operations. Should we handle things inside the business logic? Should we use a higher-order function to enhance queries and mutations with authorization logic? Or should we use schema directives? There is no single one-size-fits-all answer to these questions."
Title,"Nest helps address these issues with its cross-platform features like guards and interceptors. The philosophy is to reduce redundancy and provide tooling that helps create well-structured, readable, and consistent applications."
Title,Overview
Title,"You can use standard guards, interceptors, filters and pipes in the same fashion with GraphQL as with any RESTful application. Additionally, you can easily create your own decorators by leveraging the custom decorators feature. Let's take a look at a sample GraphQL query handler."
Title,typescript
Title,@Query('author')
Title,@UseGuards(AuthGuard)
Title,"async getAuthor(@Args('id', ParseIntPipe) id: number) {"
Title,return this.authorsService.findOneById(id);
Title,}
Title,"As you can see, GraphQL works with both guards and pipes in the same way as HTTP REST handlers. Because of this, you can move your authentication logic to a guard; you can even reuse the same guard class across both a REST and GraphQL API interface. Similarly, interceptors work across both types of applications in the same way:"
Title,typescript
Title,@Mutation()
Title,@UseInterceptors(EventsInterceptor)
Title,async upvotePost(@Args('postId') postId: number) {
Title,return this.postsService.upvoteById({ id: postId });
Title,}
Title,Execution context
Title,"Since GraphQL receives a different type of data in the incoming request, the execution context received by both guards and interceptors is somewhat different with GraphQL vs. REST. GraphQL resolvers have a distinct set of arguments: root, args, context, and info. Thus guards and interceptors must transform the generic ExecutionContext to a GqlExecutionContext. This is straightforward:"
Title,```typescript
Title,"import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';"
Title,import { GqlExecutionContext } from '@nestjs/graphql';
Title,@Injectable()
Title,export class AuthGuard implements CanActivate {
Title,canActivate(context: ExecutionContext): boolean {
Title,const ctx = GqlExecutionContext.create(context);
Title,return true;
Title,}
Title,}
Title,```
Title,"The GraphQL context object returned by GqlExecutionContext.create() exposes a get method for each GraphQL resolver argument (e.g., getArgs(), getContext(), etc). Once transformed, we can easily pick out any GraphQL argument for the current request."
Title,Exception filters
Title,"Nest standard exception filters are compatible with GraphQL applications as well. As with ExecutionContext, GraphQL apps should transform the ArgumentsHost object to a GqlArgumentsHost object."
Title,typescript
Title,@Catch(HttpException)
Title,export class HttpExceptionFilter implements GqlExceptionFilter {
Title,"catch(exception: HttpException, host: ArgumentsHost) {"
Title,const gqlHost = GqlArgumentsHost.create(host);
Title,return exception;
Title,}
Title,}
Title,
Title,info Hint Both GqlExceptionFilter and GqlArgumentsHost are imported from the @nestjs/graphql package.
Title,
Title,"Note that unlike the REST case, you don't use the native response object to generate a response."
Title,Custom decorators
Title,"As mentioned, the custom decorators feature works as expected with GraphQL resolvers."
Title,typescript
Title,export const User = createParamDecorator(
Title,"(data: unknown, ctx: ExecutionContext) =>"
Title,"GqlExecutionContext.create(ctx).getContext().user,"
Title,);
Title,Use the @User() custom decorator as follows:
Title,typescript
Title,@Mutation()
Title,async upvotePost(
Title,"@User() user: UserEntity,"
Title,"@Args('postId') postId: number,"
Title,) {}
Title,
Title,"info Hint In the above example, we have assumed that the user object is assigned to the context of your GraphQL application."
Title,
Title,Execute enhancers at the field resolver level
Title,"In the GraphQL context, Nest does not run enhancers (the generic name for interceptors, guards and filters) at the field level see this issue: they only run for the top level @Query()/@Mutation() method. You can tell Nest to execute interceptors, guards or filters for methods annotated with @ResolveField() by setting the fieldResolverEnhancers option in GqlModuleOptions. Pass it a list of 'interceptors', 'guards', and/or 'filters' as appropriate:"
Title,typescript
Title,GraphQLModule.forRoot({
Title,fieldResolverEnhancers: ['interceptors']
Title,"}),"
Title,
Title,"Warning Enabling enhancers for field resolvers can cause performance issues when you are returning lots of records and your field resolver is executed thousands of times. For this reason, when you enable fieldResolverEnhancers, we advise you to skip execution of enhancers that are not strictly necessary for your field resolvers. You can do this using the following helper function:"
Title,
Title,typescript
Title,export function isResolvingGraphQLField(context: ExecutionContext): boolean {
Title,if (context.getType<GqlContextType>() === 'graphql') {
Title,const gqlContext = GqlExecutionContext.create(context);
Title,const info = gqlContext.getInfo();
Title,const parentType = info.parentType.name;
Title,return parentType !== 'Query' && parentType !== 'Mutation';
Title,}
Title,return false;
Title,}
Title,Creating a custom driver
Title,"Nest provides two official drivers out-of-the-box: @nestjs/apollo and @nestjs/mercurius, as well as an API allowing developers to build new custom drivers. With a custom driver, you can integrate any GraphQL library or extend the existing integration, adding extra features on top."
Title,"For example, to integrate the express-graphql package, you could create the following driver class:"
Title,```typescript
Title,"import { AbstractGraphQLDriver, GqlModuleOptions } from '@nestjs/graphql';"
Title,import { graphqlHTTP } from 'express-graphql';
Title,class ExpressGraphQLDriver extends AbstractGraphQLDriver {
Title,async start(options: GqlModuleOptions): Promise {
Title,options = await this.graphQlFactory.mergeWithSchema(options);
Title,const { httpAdapter } = this.httpAdapterHost;
Title,httpAdapter.use(
Title,"'/graphql',"
Title,graphqlHTTP({
Title,"schema: options.schema,"
Title,"graphiql: true,"
Title,"}),"
Title,);
Title,
Title,}
Title,async stop() {}
Title,}
Title,```
Title,And then use it as follows:
Title,typescript
Title,GraphQLModule.forRoot({
Title,"driver: ExpressGraphQLDriver,"
Title,});
Title,
Title,Interfaces
Title,"Like many type systems, GraphQL supports interfaces. An Interface is an abstract type that includes a certain set of fields that a type must include to implement the interface (read more here)."
Title,Code first
Title,"When using the code first approach, you define a GraphQL interface by creating an abstract class annotated with the @InterfaceType() decorator exported from the @nestjs/graphql."
Title,```typescript
Title,"import { Field, ID, InterfaceType } from '@nestjs/graphql';"
Title,@InterfaceType()
Title,export abstract class Character {
Title,@Field(() => ID)
Title,id: string;
Title,@Field()
Title,name: string;
Title,}
Title,```
Title,
Title,warning Warning TypeScript interfaces cannot be used to define GraphQL interfaces.
Title,
Title,This will result in generating the following part of the GraphQL schema in SDL:
Title,graphql
Title,interface Character {
Title,id: ID!
Title,name: String!
Title,}
Title,"Now, to implement the Character interface, use the implements key:"
Title,typescript
Title,@ObjectType({
Title,"implements: () => [Character],"
Title,})
Title,export class Human implements Character {
Title,id: string;
Title,name: string;
Title,}
Title,
Title,info Hint The @ObjectType() decorator is exported from the @nestjs/graphql package.
Title,
Title,The default resolveType() function generated by the library extracts the type based on the value returned from the resolver method. This means that you must return class instances (you cannot return literal JavaScript objects).
Title,"To provide a customized resolveType() function, pass the resolveType property to the options object passed into the @InterfaceType() decorator, as follows:"
Title,```typescript
Title,@InterfaceType({
Title,resolveType(book) {
Title,if (book.colors) {
Title,return ColoringBook;
Title,}
Title,return TextBook;
Title,"},"
Title,})
Title,export abstract class Book {
Title,@Field(() => ID)
Title,id: string;
Title,@Field()
Title,title: string;
Title,}
Title,```
Title,Interface resolvers
Title,"So far, using interfaces, you could only share field definitions with your objects. If you also want to share the actual field resolvers implementation, you can create a dedicated interface resolver, as follows:"
Title,```typescript
Title,"import { Resolver, ResolveField, Parent, Info } from '@nestjs/graphql';"
Title,@Resolver((type) => Character) // Reminder: Character is an interface
Title,export class CharacterInterfaceResolver {
Title,@ResolveField(() => [Character])
Title,friends(
Title,"@Parent() character, // Resolved object that implements Character"
Title,"@Info() { parentType }, // Type of the object that implements Character"
Title,"@Args('search', { type: () => String }) searchTerm: string,"
Title,) {
Title,// Get character's friends
Title,return [];
Title,}
Title,}
Title,```
Title,Now the friends field resolver is auto-registered for all object types that implement the Character interface.
Title,
Title,warning Warning This requires the inheritResolversFromInterfaces property set to be true in the GraphQLModule configuration.
Title,
Title,Schema first
Title,"To define an interface in the schema first approach, simply create a GraphQL interface with SDL."
Title,graphql
Title,interface Character {
Title,id: ID!
Title,name: String!
Title,}
Title,"Then, you can use the typings generation feature (as shown in the quick start chapter) to generate corresponding TypeScript definitions:"
Title,typescript
Title,export interface Character {
Title,id: string;
Title,name: string;
Title,}
Title,Interfaces require an extra __resolveType field in the resolver map to determine which type the interface should resolve to. Let's create a CharactersResolver class and define the __resolveType method:
Title,typescript
Title,@Resolver('Character')
Title,export class CharactersResolver {
Title,@ResolveField()
Title,__resolveType(value) {
Title,if ('age' in value) {
Title,return Person;
Title,}
Title,return null;
Title,}
Title,}
Title,
Title,info Hint All decorators are exported from the @nestjs/graphql package.
Title,
Title,
Title,Mapped types
Title,
Title,warning Warning This chapter applies only to the code first approach.
Title,
Title,As you build out features like CRUD (Create/Read/Update/Delete) it's often useful to construct variants on a base entity type. Nest provides several utility functions that perform type transformations to make this task more convenient.
Title,Partial
Title,"When building input validation types (also called Data Transfer Objects or DTOs), it's often useful to build create and update variations on the same type. For example, the create variant may require all fields, while the update variant may make all fields optional."
Title,Nest provides the PartialType() utility function to make this task easier and minimize boilerplate.
Title,"The PartialType() function returns a type (class) with all the properties of the input type set to optional. For example, suppose we have a create type as follows:"
Title,```typescript
Title,@InputType()
Title,class CreateUserInput {
Title,@Field()
Title,email: string;
Title,@Field()
Title,password: string;
Title,@Field()
Title,firstName: string;
Title,}
Title,```
Title,"By default, all of these fields are required. To create a type with the same fields, but with each one optional, use PartialType() passing the class reference (CreateUserInput) as an argument:"
Title,typescript
Title,@InputType()
Title,export class UpdateUserInput extends PartialType(CreateUserInput) {}
Title,
Title,info Hint The PartialType() function is imported from the @nestjs/graphql package.
Title,
Title,"The PartialType() function takes an optional second argument that is a reference to a decorator factory. This argument can be used to change the decorator function applied to the resulting (child) class. If not specified, the child class effectively uses the same decorator as the parent class (the class referenced in the first argument). In the example above, we are extending CreateUserInput which is annotated with the @InputType() decorator. Since we want UpdateUserInput to also be treated as if it were decorated with @InputType(), we didn't need to pass InputType as the second argument. If the parent and child types are different, (e.g., the parent is decorated with @ObjectType), we would pass InputType as the second argument. For example:"
Title,typescript
Title,@InputType()
Title,"export class UpdateUserInput extends PartialType(User, InputType) {}"
Title,Pick
Title,"The PickType() function constructs a new type (class) by picking a set of properties from an input type. For example, suppose we start with a type like:"
Title,```typescript
Title,@InputType()
Title,class CreateUserInput {
Title,@Field()
Title,email: string;
Title,@Field()
Title,password: string;
Title,@Field()
Title,firstName: string;
Title,}
Title,```
Title,We can pick a set of properties from this class using the PickType() utility function:
Title,typescript
Title,@InputType()
Title,"export class UpdateEmailInput extends PickType(CreateUserInput, ["
Title,"'email',"
Title,] as const) {}
Title,
Title,info Hint The PickType() function is imported from the @nestjs/graphql package.
Title,
Title,Omit
Title,"The OmitType() function constructs a type by picking all properties from an input type and then removing a particular set of keys. For example, suppose we start with a type like:"
Title,```typescript
Title,@InputType()
Title,class CreateUserInput {
Title,@Field()
Title,email: string;
Title,@Field()
Title,password: string;
Title,@Field()
Title,firstName: string;
Title,}
Title,```
Title,"We can generate a derived type that has every property except email as shown below. In this construct, the second argument to OmitType is an array of property names."
Title,typescript
Title,@InputType()
Title,"export class UpdateUserInput extends OmitType(CreateUserInput, ["
Title,"'email',"
Title,] as const) {}
Title,
Title,info Hint The OmitType() function is imported from the @nestjs/graphql package.
Title,
Title,Intersection
Title,"The IntersectionType() function combines two types into one new type (class). For example, suppose we start with two types like:"
Title,```typescript
Title,@InputType()
Title,class CreateUserInput {
Title,@Field()
Title,email: string;
Title,@Field()
Title,password: string;
Title,}
Title,@ObjectType()
Title,export class AdditionalUserInfo {
Title,@Field()
Title,firstName: string;
Title,@Field()
Title,lastName: string;
Title,}
Title,```
Title,We can generate a new type that combines all properties in both types.
Title,typescript
Title,@InputType()
Title,export class UpdateUserInput extends IntersectionType(
Title,"CreateUserInput,"
Title,"AdditionalUserInfo,"
Title,) {}
Title,
Title,info Hint The IntersectionType() function is imported from the @nestjs/graphql package.
Title,
Title,Composition
Title,"The type mapping utility functions are composable. For example, the following will produce a type (class) that has all of the properties of the CreateUserInput type except for email, and those properties will be set to optional:"
Title,typescript
Title,@InputType()
Title,export class UpdateUserInput extends PartialType(
Title,"OmitType(CreateUserInput, ['email'] as const),"
Title,) {}
Title,
Title,Migrating to v11 from v10
Title,"This chapter provides a set of guidelines for migrating from @nestjs/graphql version 10 to version 11. As part of this major release, we updated the Apollo driver to be compatible with Apollo Server v4 (instead of v3). Note: there are several breaking changes in Apollo Server v4 (especially around plugins and ecosystem packages), so you'll have to update your codebase accordingly. For more information, see the Apollo Server v4 migration guide."
Title,Apollo packages
Title,"Instead of installing the apollo-server-express package, you'll have to install @apollo/server:"
Title,bash
Title,$ npm uninstall apollo-server-express
Title,$ npm install @apollo/server
Title,"If you use the Fastify adapter, you'll have to install the @as-integrations/fastify package instead:"
Title,bash
Title,$ npm uninstall apollo-server-fastify
Title,$ npm install @apollo/server @as-integrations/fastify
Title,Mercurius packages
Title,"Mercurius gateway is no longer a part of the mercurius package. Instead, you'll have to install the @mercuriusjs/gateway package separately:"
Title,bash
Title,$ npm install @mercuriusjs/gateway
Title,"Similarly, for creating federated schemas, you'll have to install the @mercuriusjs/federation package:"
Title,bash
Title,$ npm install @mercuriusjs/federation
Title,Migrating to v10 from v9
Title,"This chapter provides a set of guidelines for migrating from @nestjs/graphql version 9 to version 10. The focus of this major-version release is to provide a lighter, platform-agnostic core library."
Title,"Introducing ""driver"" packages"
Title,"In the latest version, we made a decision to break the @nestjs/graphql package up into a few separate libraries, letting you choose whether to use Apollo (@nestjs/apollo), Mercurius (@nestjs/mercurius), or another GraphQL library in your project."
Title,This implies that now you have to explicitly specify what driver your application will use.
Title,```typescript
Title,// Before
Title,import { Module } from '@nestjs/common';
Title,import { GraphQLModule } from '@nestjs/graphql';
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"autoSchemaFile: 'schema.gql',"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,// After
Title,"import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';"
Title,import { Module } from '@nestjs/common';
Title,import { GraphQLModule } from '@nestjs/graphql';
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"driver: ApolloDriver,"
Title,"autoSchemaFile: 'schema.gql',"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,Plugins
Title,"Apollo Server plugins let you perform custom operations in response to certain events. Since this is an exclusive Apollo feature, we moved it from the @nestjs/graphql to the newly created @nestjs/apollo package so you'll have to update imports in your application."
Title,```typescript
Title,// Before
Title,import { Plugin } from '@nestjs/graphql';
Title,// After
Title,import { Plugin } from '@nestjs/apollo';
Title,```
Title,Directives
Title,schemaDirectives feature has been replaced with the new Schema directives API in v8 of @graphql-tools/schema package.
Title,```typescript
Title,// Before
Title,import { SchemaDirectiveVisitor } from '@graphql-tools/utils';
Title,"import { defaultFieldResolver, GraphQLField } from 'graphql';"
Title,export class UpperCaseDirective extends SchemaDirectiveVisitor {
Title,visitFieldDefinition(field: GraphQLField) {
Title,const { resolve = defaultFieldResolver } = field;
Title,field.resolve = async function (...args) {
Title,"const result = await resolve.apply(this, args);"
Title,if (typeof result === 'string') {
Title,return result.toUpperCase();
Title,}
Title,return result;
Title,};
Title,}
Title,}
Title,// After
Title,"import { getDirective, MapperKind, mapSchema } from '@graphql-tools/utils';"
Title,"import { defaultFieldResolver, GraphQLSchema } from 'graphql';"
Title,export function upperDirectiveTransformer(
Title,"schema: GraphQLSchema,"
Title,"directiveName: string,"
Title,) {
Title,"return mapSchema(schema, {"
Title,[MapperKind.OBJECT_FIELD]: (fieldConfig) => {
Title,const upperDirective = getDirective(
Title,"schema,"
Title,"fieldConfig,"
Title,"directiveName,"
Title,)?.[0];
Title,if (upperDirective) {
Title,const { resolve = defaultFieldResolver } = fieldConfig;
Title,
Title,// Replace the original resolver with a function that *first* calls
Title,"// the original resolver, then converts its result to upper case"
Title,"fieldConfig.resolve = async function (source, args, context, info) {"
Title,"const result = await resolve(source, args, context, info);"
Title,if (typeof result === 'string') {
Title,return result.toUpperCase();
Title,}
Title,return result;
Title,};
Title,return fieldConfig;
Title,}
Title,"},"
Title,
Title,});
Title,}
Title,```
Title,"To apply this directive implementation to a schema that contains @upper directives, use the transformSchema function:"
Title,typescript
Title,GraphQLModule.forRoot<ApolloDriverConfig>({
Title,...
Title,"transformSchema: schema => upperDirectiveTransformer(schema, 'upper'),"
Title,})
Title,Federation
Title,GraphQLFederationModule has been removed and replaced with the corresponding driver class:
Title,```typescript
Title,// Before
Title,GraphQLFederationModule.forRoot({
Title,"autoSchemaFile: true,"
Title,});
Title,// After
Title,GraphQLModule.forRoot({
Title,"driver: ApolloFederationDriver,"
Title,"autoSchemaFile: true,"
Title,});
Title,```
Title,
Title,info Hint Both ApolloFederationDriver class and ApolloFederationDriverConfig are exported from the @nestjs/apollo package.
Title,
Title,"Likewise, instead of using a dedicated GraphQLGatewayModule, simply pass the appropriate driver class to your GraphQLModule settings:"
Title,```typescript
Title,// Before
Title,GraphQLGatewayModule.forRoot({
Title,gateway: {
Title,supergraphSdl: new IntrospectAndCompose({
Title,subgraphs: [
Title,"{ name: 'users', url: 'http://localhost:3000/graphql' },"
Title,"{ name: 'posts', url: 'http://localhost:3001/graphql' },"
Title,"],"
Title,"}),"
Title,"},"
Title,});
Title,// After
Title,GraphQLModule.forRoot({
Title,"driver: ApolloGatewayDriver,"
Title,gateway: {
Title,supergraphSdl: new IntrospectAndCompose({
Title,subgraphs: [
Title,"{ name: 'users', url: 'http://localhost:3000/graphql' },"
Title,"{ name: 'posts', url: 'http://localhost:3001/graphql' },"
Title,"],"
Title,"}),"
Title,"},"
Title,});
Title,```
Title,
Title,info Hint Both ApolloGatewayDriver class and ApolloGatewayDriverConfig are exported from the @nestjs/apollo package.
Title,
Title,
Title,Mutations
Title,"Most discussions of GraphQL focus on data fetching, but any complete data platform needs a way to modify server-side data as well. In REST, any request could end up causing side-effects on the server, but best practice suggests we should not modify data in GET requests. GraphQL is similar - technically any query could be implemented to cause a data write. However, like REST, it's recommended to observe the convention that any operations that cause writes should be sent explicitly via a mutation (read more here)."
Title,"The official Apollo documentation uses an upvotePost() mutation example. This mutation implements a method to increase a post's votes property value. To create an equivalent mutation in Nest, we'll make use of the @Mutation() decorator."
Title,Code first
Title,Let's add another method to the AuthorResolver used in the previous section (see resolvers).
Title,typescript
Title,@Mutation(() => Post)
Title,"async upvotePost(@Args({ name: 'postId', type: () => Int }) postId: number) {"
Title,return this.postsService.upvoteById({ id: postId });
Title,}
Title,
Title,"info Hint All decorators (e.g., @Resolver, @ResolveField, @Args, etc.) are exported from the @nestjs/graphql package."
Title,
Title,This will result in generating the following part of the GraphQL schema in SDL:
Title,graphql
Title,type Mutation {
Title,upvotePost(postId: Int!): Post
Title,}
Title,"The upvotePost() method takes postId (Int) as an argument and returns an updated Post entity. For the reasons explained in the resolvers section, we have to explicitly set the expected type."
Title,"If the mutation needs to take an object as an argument, we can create an input type. The input type is a special kind of object type that can be passed in as an argument (read more here). To declare an input type, use the @InputType() decorator."
Title,```typescript
Title,"import { InputType, Field } from '@nestjs/graphql';"
Title,@InputType()
Title,export class UpvotePostInput {
Title,@Field()
Title,postId: number;
Title,}
Title,```
Title,
Title,"info Hint The @InputType() decorator takes an options object as an argument, so you can, for example, specify the input type's description. Note that, due to TypeScript's metadata reflection system limitations, you must either use the @Field decorator to manually indicate a type, or use a CLI plugin."
Title,
Title,We can then use this type in the resolver class:
Title,typescript
Title,@Mutation(() => Post)
Title,async upvotePost(
Title,"@Args('upvotePostData') upvotePostData: UpvotePostInput,"
Title,) {}
Title,Schema first
Title,Let's extend our AuthorResolver used in the previous section (see resolvers).
Title,typescript
Title,@Mutation()
Title,async upvotePost(@Args('postId') postId: number) {
Title,return this.postsService.upvoteById({ id: postId });
Title,}
Title,Note that we assumed above that the business logic has been moved to the PostsService (querying the post and incrementing its votes property). The logic inside the PostsService class can be as simple or sophisticated as needed. The main point of this example is to show how resolvers can interact with other providers.
Title,The last step is to add our mutation to the existing types definition.
Title,```graphql
Title,type Author {
Title,id: Int!
Title,firstName: String
Title,lastName: String
Title,posts: [Post]
Title,}
Title,type Post {
Title,id: Int!
Title,title: String
Title,votes: Int
Title,}
Title,type Query {
Title,author(id: Int!): Author
Title,}
Title,type Mutation {
Title,upvotePost(postId: Int!): Post
Title,}
Title,```
Title,The upvotePost(postId: Int!): Post mutation is now available to be called as part of our application's GraphQL API.
Title,
Title,Plugins with Apollo
Title,"Plugins enable you to extend Apollo Server's core functionality by performing custom operations in response to certain events. Currently, these events correspond to individual phases of the GraphQL request lifecycle, and to the startup of Apollo Server itself (read more here). For example, a basic logging plugin might log the GraphQL query string associated with each request that's sent to Apollo Server."
Title,Custom plugins
Title,"To create a plugin, declare a class annotated with the @Plugin decorator exported from the @nestjs/apollo package. Also, for better code autocompletion, implement the ApolloServerPlugin interface from the @apollo/server package."
Title,```typescript
Title,"import { ApolloServerPlugin, GraphQLRequestListener } from '@apollo/server';"
Title,import { Plugin } from '@nestjs/apollo';
Title,@Plugin()
Title,export class LoggingPlugin implements ApolloServerPlugin {
Title,async requestDidStart(): Promise> {
Title,console.log('Request started');
Title,return {
Title,async willSendResponse() {
Title,console.log('Will send response');
Title,"},"
Title,};
Title,}
Title,}
Title,```
Title,"With this in place, we can register the LoggingPlugin as a provider."
Title,typescript
Title,@Module({
Title,"providers: [LoggingPlugin],"
Title,})
Title,export class CommonModule {}
Title,Nest will automatically instantiate a plugin and apply it to the Apollo Server.
Title,Using external plugins
Title,"There are several plugins provided out-of-the-box. To use an existing plugin, simply import it and add it to the plugins array:"
Title,typescript
Title,GraphQLModule.forRoot({
Title,// ...
Title,plugins: [ApolloServerOperationRegistry({ /* options */})]
Title,"}),"
Title,
Title,info Hint The ApolloServerOperationRegistry plugin is exported from the @apollo/server-plugin-operation-registry package.
Title,
Title,Plugins with Mercurius
Title,Some of the existing mercurius-specific Fastify plugins must be loaded after the mercurius plugin (read more here) on the plugin tree.
Title,
Title,warning Warning mercurius-upload is an exception and should be registered in the main file.
Title,
Title,"For this, MercuriusDriver exposes an optional plugins configuration option. It represents an array of objects that consist of two attributes: plugin and its options. Therefore, registering the cache plugin would look like this:"
Title,typescript
Title,GraphQLModule.forRoot({
Title,"driver: MercuriusDriver,"
Title,// ...
Title,plugins: [
Title,{
Title,"plugin: cache,"
Title,options: {
Title,"ttl: 10,"
Title,policy: {
Title,Query: {
Title,add: true
Title,}
Title,}
Title,"},"
Title,}
Title,]
Title,"}),"
Title,
Title,Harnessing the power of TypeScript & GraphQL
Title,"GraphQL is a powerful query language for APIs and a runtime for fulfilling those queries with your existing data. It's an elegant approach that solves many problems typically found with REST APIs. For background, we suggest reading this comparison between GraphQL and REST. GraphQL combined with TypeScript helps you develop better type safety with your GraphQL queries, giving you end-to-end typing."
Title,"In this chapter, we assume a basic understanding of GraphQL, and focus on how to work with the built-in @nestjs/graphql module. The GraphQLModule can be configured to use Apollo server (with the @nestjs/apollo driver) and Mercurius (with the @nestjs/mercurius). We provide official integrations for these proven GraphQL packages to provide a simple way to use GraphQL with Nest (see more integrations here)."
Title,You can also build your own dedicated driver (read more on that here).
Title,Installation
Title,Start by installing the required packages:
Title,```bash
Title,For Express and Apollo (default)
Title,$ npm i @nestjs/graphql @nestjs/apollo @apollo/server graphql
Title,For Fastify and Apollo
Title,npm i @nestjs/graphql @nestjs/apollo @apollo/server @as-integrations/fastify graphql
Title,For Fastify and Mercurius
Title,npm i @nestjs/graphql @nestjs/mercurius graphql mercurius
Title,```
Title,
Title,"warning Warning @nestjs/graphql@>=9 and @nestjs/apollo^10 packages are compatible with Apollo v3 (check out Apollo Server 3 migration guide for more details), while @nestjs/graphql@^8 only supports Apollo v2 (e.g., apollo-server-express@2.x.x package)."
Title,
Title,Overview
Title,"Nest offers two ways of building GraphQL applications, the code first and the schema first methods. You should choose the one that works best for you. Most of the chapters in this GraphQL section are divided into two main parts: one you should follow if you adopt code first, and the other to be used if you adopt schema first."
Title,"In the code first approach, you use decorators and TypeScript classes to generate the corresponding GraphQL schema. This approach is useful if you prefer to work exclusively with TypeScript and avoid context switching between language syntaxes."
Title,"In the schema first approach, the source of truth is GraphQL SDL (Schema Definition Language) files. SDL is a language-agnostic way to share schema files between different platforms. Nest automatically generates your TypeScript definitions (using either classes or interfaces) based on the GraphQL schemas to reduce the need to write redundant boilerplate code."
Title,
Title,Getting started with GraphQL & TypeScript
Title,
Title,"info Hint In the following chapters, we'll be integrating the @nestjs/apollo package. If you want to use mercurius package instead, navigate to this section."
Title,
Title,"Once the packages are installed, we can import the GraphQLModule and configure it with the forRoot() static method."
Title,```typescript
Title,@@filename()
Title,import { Module } from '@nestjs/common';
Title,import { GraphQLModule } from '@nestjs/graphql';
Title,"import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';"
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"driver: ApolloDriver,"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,
Title,"info Hint For mercurius integration, you should be using the MercuriusDriver and MercuriusDriverConfig instead. Both are exported from the @nestjs/mercurius package."
Title,
Title,"The forRoot() method takes an options object as an argument. These options are passed through to the underlying driver instance (read more about available settings here: Apollo and Mercurius). For example, if you want to disable the playground and turn off debug mode (for Apollo), pass the following options:"
Title,```typescript
Title,@@filename()
Title,import { Module } from '@nestjs/common';
Title,import { GraphQLModule } from '@nestjs/graphql';
Title,"import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';"
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"driver: ApolloDriver,"
Title,"playground: false,"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,"In this case, these options will be forwarded to the ApolloServer constructor."
Title,GraphQL playground
Title,"The playground is a graphical, interactive, in-browser GraphQL IDE, available by default on the same URL as the GraphQL server itself. To access the playground, you need a basic GraphQL server configured and running. To see it now, you can install and build the working example here. Alternatively, if you're following along with these code samples, once you've completed the steps in the Resolvers chapter, you can access the playground."
Title,"With that in place, and with your application running in the background, you can then open your web browser and navigate to http://localhost:3000/graphql (host and port may vary depending on your configuration). You will then see the GraphQL playground, as shown below."
Title,
Title,
Title,
Title,
Title,"warning Note @nestjs/mercurius integration does not ship with the built-in GraphQL Playground integration. Instead, you can use GraphiQL (set graphiql: true)."
Title,
Title,Multiple endpoints
Title,"Another useful feature of the @nestjs/graphql module is the ability to serve multiple endpoints at once. This lets you decide which modules should be included in which endpoint. By default, GraphQL searches for resolvers throughout the whole app. To limit this scan to only a subset of modules, use the include property."
Title,typescript
Title,GraphQLModule.forRoot({
Title,"include: [CatsModule],"
Title,"}),"
Title,
Title,"warning Warning If you use the @apollo/server with @as-integrations/fastify package with multiple GraphQL endpoints in a single application, make sure to enable the disableHealthCheck setting in the GraphQLModule configuration."
Title,
Title,Code first
Title,"In the code first approach, you use decorators and TypeScript classes to generate the corresponding GraphQL schema."
Title,"To use the code first approach, start by adding the autoSchemaFile property to the options object:"
Title,typescript
Title,GraphQLModule.forRoot<ApolloDriverConfig>({
Title,"driver: ApolloDriver,"
Title,"autoSchemaFile: join(process.cwd(), 'src/schema.gql'),"
Title,"}),"
Title,"The autoSchemaFile property value is the path where your automatically generated schema will be created. Alternatively, the schema can be generated on-the-fly in memory. To enable this, set the autoSchemaFile property to true:"
Title,typescript
Title,GraphQLModule.forRoot<ApolloDriverConfig>({
Title,"driver: ApolloDriver,"
Title,"autoSchemaFile: true,"
Title,"}),"
Title,"By default, the types in the generated schema will be in the order they are defined in the included modules. To sort the schema lexicographically, set the sortSchema property to true:"
Title,typescript
Title,GraphQLModule.forRoot<ApolloDriverConfig>({
Title,"driver: ApolloDriver,"
Title,"autoSchemaFile: join(process.cwd(), 'src/schema.gql'),"
Title,"sortSchema: true,"
Title,"}),"
Title,Example
Title,A fully working code first sample is available here.
Title,Schema first
Title,"To use the schema first approach, start by adding a typePaths property to the options object. The typePaths property indicates where the GraphQLModule should look for GraphQL SDL schema definition files you'll be writing. These files will be combined in memory; this allows you to split your schemas into several files and locate them near their resolvers."
Title,typescript
Title,GraphQLModule.forRoot<ApolloDriverConfig>({
Title,"driver: ApolloDriver,"
Title,"typePaths: ['./**/*.graphql'],"
Title,"}),"
Title,"You will typically also need to have TypeScript definitions (classes and interfaces) that correspond to the GraphQL SDL types. Creating the corresponding TypeScript definitions by hand is redundant and tedious. It leaves us without a single source of truth -- each change made within SDL forces us to adjust TypeScript definitions as well. To address this, the @nestjs/graphql package can automatically generate TypeScript definitions from the abstract syntax tree (AST). To enable this feature, add the definitions options property when configuring the GraphQLModule."
Title,typescript
Title,GraphQLModule.forRoot<ApolloDriverConfig>({
Title,"driver: ApolloDriver,"
Title,"typePaths: ['./**/*.graphql'],"
Title,definitions: {
Title,"path: join(process.cwd(), 'src/graphql.ts'),"
Title,"},"
Title,"}),"
Title,"The path property of the definitions object indicates where to save generated TypeScript output. By default, all generated TypeScript types are created as interfaces. To generate classes instead, specify the outputAs property with a value of 'class'."
Title,typescript
Title,GraphQLModule.forRoot<ApolloDriverConfig>({
Title,"driver: ApolloDriver,"
Title,"typePaths: ['./**/*.graphql'],"
Title,definitions: {
Title,"path: join(process.cwd(), 'src/graphql.ts'),"
Title,"outputAs: 'class',"
Title,"},"
Title,"}),"
Title,"The above approach dynamically generates TypeScript definitions each time the application starts. Alternatively, it may be preferable to build a simple script to generate these on demand. For example, assume we create the following script as generate-typings.ts:"
Title,```typescript
Title,import { GraphQLDefinitionsFactory } from '@nestjs/graphql';
Title,import { join } from 'path';
Title,const definitionsFactory = new GraphQLDefinitionsFactory();
Title,definitionsFactory.generate({
Title,"typePaths: ['./src/*/.graphql'],"
Title,"path: join(process.cwd(), 'src/graphql.ts'),"
Title,"outputAs: 'class',"
Title,});
Title,```
Title,Now you can run this script on demand:
Title,bash
Title,$ ts-node generate-typings
Title,
Title,"info Hint You can compile the script beforehand (e.g., with tsc) and use node to execute it."
Title,
Title,"To enable watch mode for the script (to automatically generate typings whenever any .graphql file changes), pass the watch option to the generate() method."
Title,typescript
Title,definitionsFactory.generate({
Title,"typePaths: ['./src/**/*.graphql'],"
Title,"path: join(process.cwd(), 'src/graphql.ts'),"
Title,"outputAs: 'class',"
Title,"watch: true,"
Title,});
Title,"To automatically generate the additional __typename field for every object type, enable the emitTypenameField option."
Title,typescript
Title,definitionsFactory.generate({
Title,"// ...,"
Title,"emitTypenameField: true,"
Title,});
Title,"To generate resolvers (queries, mutations, subscriptions) as plain fields without arguments, enable the skipResolverArgs option."
Title,typescript
Title,definitionsFactory.generate({
Title,"// ...,"
Title,"skipResolverArgs: true,"
Title,});
Title,Apollo Sandbox
Title,"To use Apollo Sandbox instead of the graphql-playground as a GraphQL IDE for local development, use the following configuration:"
Title,```typescript
Title,"import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';"
Title,import { Module } from '@nestjs/common';
Title,import { GraphQLModule } from '@nestjs/graphql';
Title,import { ApolloServerPluginLandingPageLocalDefault } from '@apollo/server/plugin/landingPage/default';
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"driver: ApolloDriver,"
Title,"playground: false,"
Title,"plugins: [ApolloServerPluginLandingPageLocalDefault()],"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,Example
Title,A fully working schema first sample is available here.
Title,Accessing generated schema
Title,"In some circumstances (for example end-to-end tests), you may want to get a reference to the generated schema object. In end-to-end tests, you can then run queries using the graphql object without using any HTTP listeners."
Title,"You can access the generated schema (in either the code first or schema first approach), using the GraphQLSchemaHost class:"
Title,typescript
Title,const { schema } = app.get(GraphQLSchemaHost);
Title,
Title,info Hint You must call the GraphQLSchemaHost#schema getter after the application has been initialized (after the onModuleInit hook has been triggered by either the app.listen() or app.init() method).
Title,
Title,Async configuration
Title,"When you need to pass module options asynchronously instead of statically, use the forRootAsync() method. As with most dynamic modules, Nest provides several techniques to deal with async configuration."
Title,One technique is to use a factory function:
Title,typescript
Title,GraphQLModule.forRootAsync<ApolloDriverConfig>({
Title,"driver: ApolloDriver,"
Title,useFactory: () => ({
Title,"typePaths: ['./**/*.graphql'],"
Title,"}),"
Title,"}),"
Title,"Like other factory providers, our factory function can be async and can inject dependencies through inject."
Title,typescript
Title,GraphQLModule.forRootAsync<ApolloDriverConfig>({
Title,"driver: ApolloDriver,"
Title,"imports: [ConfigModule],"
Title,useFactory: async (configService: ConfigService) => ({
Title,"typePaths: configService.get<string>('GRAPHQL_TYPE_PATHS'),"
Title,"}),"
Title,"inject: [ConfigService],"
Title,"}),"
Title,"Alternatively, you can configure the GraphQLModule using a class instead of a factory, as shown below:"
Title,typescript
Title,GraphQLModule.forRootAsync<ApolloDriverConfig>({
Title,"driver: ApolloDriver,"
Title,"useClass: GqlConfigService,"
Title,"}),"
Title,"The construction above instantiates GqlConfigService inside GraphQLModule, using it to create options object. Note that in this example, the GqlConfigService has to implement the GqlOptionsFactory interface, as shown below. The GraphQLModule will call the createGqlOptions() method on the instantiated object of the supplied class."
Title,typescript
Title,@Injectable()
Title,class GqlConfigService implements GqlOptionsFactory {
Title,createGqlOptions(): ApolloDriverConfig {
Title,return {
Title,"typePaths: ['./**/*.graphql'],"
Title,};
Title,}
Title,}
Title,"If you want to reuse an existing options provider instead of creating a private copy inside the GraphQLModule, use the useExisting syntax."
Title,typescript
Title,GraphQLModule.forRootAsync<ApolloDriverConfig>({
Title,"imports: [ConfigModule],"
Title,"useExisting: ConfigService,"
Title,"}),"
Title,Mercurius integration
Title,"Instead of using Apollo, Fastify users (read more here) can alternatively use the @nestjs/mercurius driver."
Title,```typescript
Title,@@filename()
Title,import { Module } from '@nestjs/common';
Title,import { GraphQLModule } from '@nestjs/graphql';
Title,"import { MercuriusDriver, MercuriusDriverConfig } from '@nestjs/mercurius';"
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"driver: MercuriusDriver,"
Title,"graphiql: true,"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,
Title,"info Hint Once the application is running, open your browser and navigate to http://localhost:3000/graphiql. You should see the GraphQL IDE."
Title,
Title,The forRoot() method takes an options object as an argument. These options are passed through to the underlying driver instance. Read more about available settings here.
Title,Third-party integrations
Title,
Title,GraphQL Yoga
Title,
Title,Example
Title,A working example is available here.
Title,
Title,Resolvers
Title,"Resolvers provide the instructions for turning a GraphQL operation (a query, mutation, or subscription) into data. They return the same shape of data we specify in our schema -- either synchronously or as a promise that resolves to a result of that shape. Typically, you create a resolver map manually. The @nestjs/graphql package, on the other hand, generates a resolver map automatically using the metadata provided by decorators you use to annotate classes. To demonstrate the process of using the package features to create a GraphQL API, we'll create a simple authors API."
Title,Code first
Title,"In the code first approach, we don't follow the typical process of creating our GraphQL schema by writing GraphQL SDL by hand. Instead, we use TypeScript decorators to generate the SDL from TypeScript class definitions. The @nestjs/graphql package reads the metadata defined through the decorators and automatically generates the schema for you."
Title,Object types
Title,"Most of the definitions in a GraphQL schema are object types. Each object type you define should represent a domain object that an application client might need to interact with. For example, our sample API needs to be able to fetch a list of authors and their posts, so we should define the Author type and Post type to support this functionality."
Title,"If we were using the schema first approach, we'd define such a schema with SDL like this:"
Title,graphql
Title,type Author {
Title,id: Int!
Title,firstName: String
Title,lastName: String
Title,posts: [Post!]!
Title,}
Title,"In this case, using the code first approach, we define schemas using TypeScript classes and using TypeScript decorators to annotate the fields of those classes. The equivalent of the above SDL in the code first approach is:"
Title,```typescript
Title,@@filename(authors/models/author.model)
Title,"import { Field, Int, ObjectType } from '@nestjs/graphql';"
Title,import { Post } from './post';
Title,@ObjectType()
Title,export class Author {
Title,@Field(type => Int)
Title,id: number;
Title,@Field({ nullable: true })
Title,firstName?: string;
Title,@Field({ nullable: true })
Title,lastName?: string;
Title,@Field(type => [Post])
Title,posts: Post[];
Title,}
Title,```
Title,
Title,"info Hint TypeScript's metadata reflection system has several limitations which make it impossible, for instance, to determine what properties a class consists of or recognize whether a given property is optional or required. Because of these limitations, we must either explicitly use the @Field() decorator in our schema definition classes to provide metadata about each field's GraphQL type and optionality, or use a CLI plugin to generate these for us."
Title,
Title,"The Author object type, like any class, is made of a collection of fields, with each field declaring a type. A field's type corresponds to a GraphQL type. A field's GraphQL type can be either another object type or a scalar type. A GraphQL scalar type is a primitive (like ID, String, Boolean, or Int) that resolves to a single value."
Title,
Title,"info Hint In addition to GraphQL's built-in scalar types, you can define custom scalar types (read more)."
Title,
Title,The above Author object type definition will cause Nest to generate the SDL we showed above:
Title,graphql
Title,type Author {
Title,id: Int!
Title,firstName: String
Title,lastName: String
Title,posts: [Post!]!
Title,}
Title,"The @Field() decorator accepts an optional type function (e.g., type => Int), and optionally an options object."
Title,The type function is required when there's the potential for ambiguity between the TypeScript type system and the GraphQL type system. Specifically: it is not required for string and boolean types; it is required for number (which must be mapped to either a GraphQL Int or Float). The type function should simply return the desired GraphQL type (as shown in various examples in these chapters).
Title,The options object can have any of the following key/value pairs:
Title,
Title,"nullable: for specifying whether a field is nullable (in SDL, each field is non-nullable by default); boolean"
Title,description: for setting a field description; string
Title,deprecationReason: for marking a field as deprecated; string
Title,
Title,For example:
Title,typescript
Title,"@Field({ description: `Book title`, deprecationReason: 'Not useful in v2 schema' })"
Title,title: string;
Title,
Title,"info Hint You can also add a description to, or deprecate, the whole object type: @ObjectType({{ '{' }} description: 'Author model' {{ '}' }})."
Title,
Title,"When the field is an array, we must manually indicate the array type in the Field() decorator's type function, as shown below:"
Title,typescript
Title,@Field(type => [Post])
Title,posts: Post[];
Title,
Title,"info Hint Using array bracket notation ([ ]), we can indicate the depth of the array. For example, using [[Int]] would represent an integer matrix."
Title,
Title,"To declare that an array's items (not the array itself) are nullable, set the nullable property to 'items' as shown below:"
Title,typescript
Title,"@Field(type => [Post], { nullable: 'items' })"
Title,posts: Post[];
Title,
Title,"info Hint If both the array and its items are nullable, set nullable to 'itemsAndList' instead."
Title,
Title,"Now that the Author object type is created, let's define the Post object type."
Title,```typescript
Title,@@filename(posts/models/post.model)
Title,"import { Field, Int, ObjectType } from '@nestjs/graphql';"
Title,@ObjectType()
Title,export class Post {
Title,@Field(type => Int)
Title,id: number;
Title,@Field()
Title,title: string;
Title,"@Field(type => Int, { nullable: true })"
Title,votes?: number;
Title,}
Title,```
Title,The Post object type will result in generating the following part of the GraphQL schema in SDL:
Title,graphql
Title,type Post {
Title,id: Int!
Title,title: String!
Title,votes: Int
Title,}
Title,Code first resolver
Title,"At this point, we've defined the objects (type definitions) that can exist in our data graph, but clients don't yet have a way to interact with those objects. To address that, we need to create a resolver class. In the code first method, a resolver class both defines resolver functions and generates the Query type. This will be clear as we work through the example below:"
Title,```typescript
Title,@@filename(authors/authors.resolver)
Title,@Resolver(() => Author)
Title,export class AuthorsResolver {
Title,constructor(
Title,"private authorsService: AuthorsService,"
Title,"private postsService: PostsService,"
Title,) {}
Title,@Query(() => Author)
Title,"async author(@Args('id', { type: () => Int }) id: number) {"
Title,return this.authorsService.findOneById(id);
Title,}
Title,@ResolveField()
Title,async posts(@Parent() author: Author) {
Title,const { id } = author;
Title,return this.postsService.findAll({ authorId: id });
Title,}
Title,}
Title,```
Title,
Title,"info Hint All decorators (e.g., @Resolver, @ResolveField, @Args, etc.) are exported from the @nestjs/graphql package."
Title,
Title,You can define multiple resolver classes. Nest will combine these at run time. See the module section below for more on code organization.
Title,
Title,warning Note The logic inside the AuthorsService and PostsService classes can be as simple or sophisticated as needed. The main point of this example is to show how to construct resolvers and how they can interact with other providers.
Title,
Title,"In the example above, we created the AuthorsResolver which defines one query resolver function and one field resolver function. To create a resolver, we create a class with resolver functions as methods, and annotate the class with the @Resolver() decorator."
Title,"In this example, we defined a query handler to get the author object based on the id sent in the request. To specify that the method is a query handler, use the @Query() decorator."
Title,"The argument passed to the @Resolver() decorator is optional, but comes into play when our graph becomes non-trivial. It's used to supply a parent object used by field resolver functions as they traverse down through an object graph."
Title,"In our example, since the class includes a field resolver function (for the posts property of the Author object type), we must supply the @Resolver() decorator with a value to indicate which class is the parent type (i.e., the corresponding ObjectType class name) for all field resolvers defined within this class. As should be clear from the example, when writing a field resolver function, it's necessary to access the parent object (the object the field being resolved is a member of). In this example, we populate an author's posts array with a field resolver that calls a service which takes the author's id as an argument. Hence the need to identify the parent object in the @Resolver() decorator. Note the corresponding use of the @Parent() method parameter decorator to then extract a reference to that parent object in the field resolver."
Title,"We can define multiple @Query() resolver functions (both within this class, and in any other resolver class), and they will be aggregated into a single Query type definition in the generated SDL along with the appropriate entries in the resolver map. This allows you to define queries close to the models and services that they use, and to keep them well organized in modules."
Title,
Title,"info Hint Nest CLI provides a generator (schematic) that automatically generates all the boilerplate code to help us avoid doing all of this, and make the developer experience much simpler. Read more about this feature here."
Title,
Title,Query type names
Title,"In the above examples, the @Query() decorator generates a GraphQL schema query type name based on the method name. For example, consider the following construction from the example above:"
Title,typescript
Title,@Query(() => Author)
Title,"async author(@Args('id', { type: () => Int }) id: number) {"
Title,return this.authorsService.findOneById(id);
Title,}
Title,This generates the following entry for the author query in our schema (the query type uses the same name as the method name):
Title,graphql
Title,type Query {
Title,author(id: Int!): Author
Title,}
Title,
Title,info Hint Learn more about GraphQL queries here.
Title,
Title,"Conventionally, we prefer to decouple these names; for example, we prefer to use a name like getAuthor() for our query handler method, but still use author for our query type name. The same applies to our field resolvers. We can easily do this by passing the mapping names as arguments of the @Query() and @ResolveField() decorators, as shown below:"
Title,```typescript
Title,@@filename(authors/authors.resolver)
Title,@Resolver(() => Author)
Title,export class AuthorsResolver {
Title,constructor(
Title,"private authorsService: AuthorsService,"
Title,"private postsService: PostsService,"
Title,) {}
Title,"@Query(() => Author, { name: 'author' })"
Title,"async getAuthor(@Args('id', { type: () => Int }) id: number) {"
Title,return this.authorsService.findOneById(id);
Title,}
Title,"@ResolveField('posts', () => [Post])"
Title,async getPosts(@Parent() author: Author) {
Title,const { id } = author;
Title,return this.postsService.findAll({ authorId: id });
Title,}
Title,}
Title,```
Title,The getAuthor handler method above will result in generating the following part of the GraphQL schema in SDL:
Title,graphql
Title,type Query {
Title,author(id: Int!): Author
Title,}
Title,Query decorator options
Title,The @Query() decorator's options object (where we pass {{ '{' }}name: 'author'{{ '}' }} above) accepts a number of key/value pairs:
Title,
Title,name: name of the query; a string
Title,"description: a description that will be used to generate GraphQL schema documentation (e.g., in GraphQL playground); a string"
Title,"deprecationReason: sets query metadata to show the query as deprecated (e.g., in GraphQL playground); a string"
Title,nullable: whether the query can return a null data response; boolean or 'items' or 'itemsAndList' (see above for details of 'items' and 'itemsAndList')
Title,
Title,Args decorator options
Title,Use the @Args() decorator to extract arguments from a request for use in the method handler. This works in a very similar fashion to REST route parameter argument extraction.
Title,"Usually your @Args() decorator will be simple, and not require an object argument as seen with the getAuthor() method above. For example, if the type of an identifier is string, the following construction is sufficient, and simply plucks the named field from the inbound GraphQL request for use as a method argument."
Title,typescript
Title,@Args('id') id: string
Title,"In the getAuthor() case, the number type is used, which presents a challenge. The number TypeScript type doesn't give us enough information about the expected GraphQL representation (e.g., Int vs. Float). Thus we have to explicitly pass the type reference. We do that by passing a second argument to the Args() decorator, containing argument options, as shown below:"
Title,typescript
Title,"@Query(() => Author, { name: 'author' })"
Title,"async getAuthor(@Args('id', { type: () => Int }) id: number) {"
Title,return this.authorsService.findOneById(id);
Title,}
Title,The options object allows us to specify the following optional key value pairs:
Title,
Title,type: a function returning the GraphQL type
Title,defaultValue: a default value; any
Title,description: description metadata; string
Title,deprecationReason: to deprecate a field and provide meta data describing why; string
Title,nullable: whether the field is nullable
Title,
Title,"Query handler methods can take multiple arguments. Let's imagine that we want to fetch an author based on its firstName and lastName. In this case, we can call @Args twice:"
Title,typescript
Title,getAuthor(
Title,"@Args('firstName', { nullable: true }) firstName?: string,"
Title,"@Args('lastName', { defaultValue: '' }) lastName?: string,"
Title,) {}
Title,Dedicated arguments class
Title,"With inline @Args() calls, code like the example above becomes bloated. Instead, you can create a dedicated GetAuthorArgs arguments class and access it in the handler method as follows:"
Title,typescript
Title,@Args() args: GetAuthorArgs
Title,Create the GetAuthorArgs class using @ArgsType() as shown below:
Title,```typescript
Title,@@filename(authors/dto/get-author.args)
Title,import { MinLength } from 'class-validator';
Title,"import { Field, ArgsType } from '@nestjs/graphql';"
Title,@ArgsType()
Title,class GetAuthorArgs {
Title,@Field({ nullable: true })
Title,firstName?: string;
Title,@Field({ defaultValue: '' })
Title,@MinLength(3)
Title,lastName: string;
Title,}
Title,```
Title,
Title,"info Hint Again, due to TypeScript's metadata reflection system limitations, it's required to either use the @Field decorator to manually indicate type and optionality, or use a CLI plugin."
Title,
Title,This will result in generating the following part of the GraphQL schema in SDL:
Title,graphql
Title,type Query {
Title,"author(firstName: String, lastName: String = ''): Author"
Title,}
Title,
Title,info Hint Note that arguments classes like GetAuthorArgs play very well with the ValidationPipe (read more).
Title,
Title,Class inheritance
Title,"You can use standard TypeScript class inheritance to create base classes with generic utility type features (fields and field properties, validations, etc.) that can be extended. For example, you may have a set of pagination related arguments that always include the standard offset and limit fields, but also other index fields that are type-specific. You can set up a class hierarchy as shown below."
Title,Base @ArgsType() class:
Title,```typescript
Title,@ArgsType()
Title,class PaginationArgs {
Title,@Field(() => Int)
Title,offset: number = 0;
Title,@Field(() => Int)
Title,limit: number = 10;
Title,}
Title,```
Title,Type specific sub-class of the base @ArgsType() class:
Title,```typescript
Title,@ArgsType()
Title,class GetAuthorArgs extends PaginationArgs {
Title,@Field({ nullable: true })
Title,firstName?: string;
Title,@Field({ defaultValue: '' })
Title,@MinLength(3)
Title,lastName: string;
Title,}
Title,```
Title,The same approach can be taken with @ObjectType() objects. Define generic properties on the base class:
Title,```typescript
Title,@ObjectType()
Title,class Character {
Title,@Field(() => Int)
Title,id: number;
Title,@Field()
Title,name: string;
Title,}
Title,```
Title,Add type-specific properties on sub-classes:
Title,typescript
Title,@ObjectType()
Title,class Warrior extends Character {
Title,@Field()
Title,level: number;
Title,}
Title,"You can use inheritance with a resolver as well. You can ensure type safety by combining inheritance and TypeScript generics. For example, to create a base class with a generic findAll query, use a construction like this:"
Title,typescript
Title,function BaseResolver<T extends Type<unknown>>(classRef: T): any {
Title,@Resolver({ isAbstract: true })
Title,abstract class BaseResolverHost {
Title,"@Query(() => [classRef], { name: `findAll${classRef.name}` })"
Title,async findAll(): Promise<T[]> {
Title,return [];
Title,}
Title,}
Title,return BaseResolverHost;
Title,}
Title,Note the following:
Title,
Title,an explicit return type (any above) is required: otherwise TypeScript complains about the usage of a private class definition. Recommended: define an interface instead of using any.
Title,Type is imported from the @nestjs/common package
Title,"The isAbstract: true property indicates that SDL (Schema Definition Language statements) shouldn't be generated for this class. Note, you can set this property for other types as well to suppress SDL generation."
Title,
Title,Here's how you could generate a concrete sub-class of the BaseResolver:
Title,typescript
Title,@Resolver(() => Recipe)
Title,export class RecipesResolver extends BaseResolver(Recipe) {
Title,constructor(private recipesService: RecipesService) {
Title,super();
Title,}
Title,}
Title,This construct would generated the following SDL:
Title,graphql
Title,type Query {
Title,findAllRecipe: [Recipe!]!
Title,}
Title,Generics
Title,"We saw one use of generics above. This powerful TypeScript feature can be used to create useful abstractions. For example, here's a sample cursor-based pagination implementation based on this documentation:"
Title,```typescript
Title,"import { Field, ObjectType, Int } from '@nestjs/graphql';"
Title,import { Type } from '@nestjs/common';
Title,interface IEdgeType {
Title,cursor: string;
Title,node: T;
Title,}
Title,export interface IPaginatedType {
Title,edges: IEdgeType[];
Title,nodes: T[];
Title,totalCount: number;
Title,hasNextPage: boolean;
Title,}
Title,export function Paginated(classRef: Type): Type> {
Title,@ObjectType(${classRef.name}Edge)
Title,abstract class EdgeType {
Title,@Field(() => String)
Title,cursor: string;
Title,@Field(() => classRef)
Title,node: T;
Title,
Title,}
Title,@ObjectType({ isAbstract: true })
Title,abstract class PaginatedType implements IPaginatedType {
Title,"@Field(() => [EdgeType], { nullable: true })"
Title,edges: EdgeType[];
Title,"@Field(() => [classRef], { nullable: true })"
Title,nodes: T[];
Title,
Title,@Field(() => Int)
Title,totalCount: number;
Title,
Title,@Field()
Title,hasNextPage: boolean;
Title,
Title,}
Title,return PaginatedType as Type>;
Title,}
Title,```
Title,"With the above base class defined, we can now easily create specialized types that inherit this behavior. For example:"
Title,typescript
Title,@ObjectType()
Title,class PaginatedAuthor extends Paginated(Author) {}
Title,Schema first
Title,"As mentioned in the previous chapter, in the schema first approach we start by manually defining schema types in SDL (read more). Consider the following SDL type definitions."
Title,
Title,"info Hint For convenience in this chapter, we've aggregated all of the SDL in one location (e.g., one .graphql file, as shown below). In practice, you may find it appropriate to organize your code in a modular fashion. For example, it can be helpful to create individual SDL files with type definitions representing each domain entity, along with related services, resolver code, and the Nest module definition class, in a dedicated directory for that entity. Nest will aggregate all the individual schema type definitions at run time."
Title,
Title,```graphql
Title,type Author {
Title,id: Int!
Title,firstName: String
Title,lastName: String
Title,posts: [Post]
Title,}
Title,type Post {
Title,id: Int!
Title,title: String!
Title,votes: Int
Title,}
Title,type Query {
Title,author(id: Int!): Author
Title,}
Title,```
Title,Schema first resolver
Title,The schema above exposes a single query - author(id: Int!): Author.
Title,
Title,info Hint Learn more about GraphQL queries here.
Title,
Title,Let's now create an AuthorsResolver class that resolves author queries:
Title,```typescript
Title,@@filename(authors/authors.resolver)
Title,@Resolver('Author')
Title,export class AuthorsResolver {
Title,constructor(
Title,"private authorsService: AuthorsService,"
Title,"private postsService: PostsService,"
Title,) {}
Title,@Query()
Title,async author(@Args('id') id: number) {
Title,return this.authorsService.findOneById(id);
Title,}
Title,@ResolveField()
Title,async posts(@Parent() author) {
Title,const { id } = author;
Title,return this.postsService.findAll({ authorId: id });
Title,}
Title,}
Title,```
Title,
Title,"info Hint All decorators (e.g., @Resolver, @ResolveField, @Args, etc.) are exported from the @nestjs/graphql package."
Title,warning Note The logic inside the AuthorsService and PostsService classes can be as simple or sophisticated as needed. The main point of this example is to show how to construct resolvers and how they can interact with other providers.
Title,
Title,"The @Resolver() decorator is required. It takes an optional string argument with the name of a class. This class name is required whenever the class includes @ResolveField() decorators to inform Nest that the decorated method is associated with a parent type (the Author type in our current example). Alternatively, instead of setting @Resolver() at the top of the class, this can be done for each method:"
Title,typescript
Title,@Resolver('Author')
Title,@ResolveField()
Title,async posts(@Parent() author) {
Title,const { id } = author;
Title,return this.postsService.findAll({ authorId: id });
Title,}
Title,"In this case (@Resolver() decorator at the method level), if you have multiple @ResolveField() decorators inside a class, you must add @Resolver() to all of them. This is not considered the best practice (as it creates extra overhead)."
Title,
Title,info Hint Any class name argument passed to @Resolver() does not affect queries (@Query() decorator) or mutations (@Mutation() decorator).
Title,warning Warning Using the @Resolver decorator at the method level is not supported with the code first approach.
Title,
Title,"In the above examples, the @Query() and @ResolveField() decorators are associated with GraphQL schema types based on the method name. For example, consider the following construction from the example above:"
Title,typescript
Title,@Query()
Title,async author(@Args('id') id: number) {
Title,return this.authorsService.findOneById(id);
Title,}
Title,This generates the following entry for the author query in our schema (the query type uses the same name as the method name):
Title,graphql
Title,type Query {
Title,author(id: Int!): Author
Title,}
Title,"Conventionally, we would prefer to decouple these, using names like getAuthor() or getPosts() for our resolver methods. We can easily do this by passing the mapping name as an argument to the decorator, as shown below:"
Title,```typescript
Title,@@filename(authors/authors.resolver)
Title,@Resolver('Author')
Title,export class AuthorsResolver {
Title,constructor(
Title,"private authorsService: AuthorsService,"
Title,"private postsService: PostsService,"
Title,) {}
Title,@Query('author')
Title,async getAuthor(@Args('id') id: number) {
Title,return this.authorsService.findOneById(id);
Title,}
Title,@ResolveField('posts')
Title,async getPosts(@Parent() author) {
Title,const { id } = author;
Title,return this.postsService.findAll({ authorId: id });
Title,}
Title,}
Title,```
Title,
Title,"info Hint Nest CLI provides a generator (schematic) that automatically generates all the boilerplate code to help us avoid doing all of this, and make the developer experience much simpler. Read more about this feature here."
Title,
Title,Generating types
Title,"Assuming that we use the schema first approach and have enabled the typings generation feature (with outputAs: 'class' as shown in the previous chapter), once you run the application it will generate the following file (in the location you specified in the GraphQLModule.forRoot() method). For example, in src/graphql.ts:"
Title,```typescript
Title,@@filename(graphql)
Title,export (class Author {
Title,id: number;
Title,firstName?: string;
Title,lastName?: string;
Title,posts?: Post[];
Title,})
Title,export class Post {
Title,id: number;
Title,title: string;
Title,votes?: number;
Title,}
Title,export abstract class IQuery {
Title,abstract author(id: number): Author | Promise;
Title,}
Title,```
Title,"By generating classes (instead of the default technique of generating interfaces), you can use declarative validation decorators in combination with the schema first approach, which is an extremely useful technique (read more). For example, you could add class-validator decorators to the generated CreatePostInput class as shown below to enforce minimum and maximum string lengths on the title field:"
Title,```typescript
Title,"import { MinLength, MaxLength } from 'class-validator';"
Title,export class CreatePostInput {
Title,@MinLength(3)
Title,@MaxLength(50)
Title,title: string;
Title,}
Title,```
Title,
Title,"warning Notice To enable auto-validation of your inputs (and parameters), use ValidationPipe. Read more about validation here and more specifically about pipes here."
Title,
Title,"However, if you add decorators directly to the automatically generated file, they will be overwritten each time the file is generated. Instead, create a separate file and simply extend the generated class."
Title,```typescript
Title,"import { MinLength, MaxLength } from 'class-validator';"
Title,import { Post } from '../../graphql.ts';
Title,export class CreatePostInput extends Post {
Title,@MinLength(3)
Title,@MaxLength(50)
Title,title: string;
Title,}
Title,```
Title,GraphQL argument decorators
Title,We can access the standard GraphQL resolver arguments using dedicated decorators. Below is a comparison of the Nest decorators and the plain Apollo parameters they represent.
Title,
Title,
Title,
Title,@Root() and @Parent()
Title,root/parent
Title,
Title,
Title,@Context(param?: string)
Title,context / context[param]
Title,
Title,
Title,@Info(param?: string)
Title,info / info[param]
Title,
Title,
Title,@Args(param?: string)
Title,args / args[param]
Title,
Title,
Title,
Title,These arguments have the following meanings:
Title,
Title,"root: an object that contains the result returned from the resolver on the parent field, or, in the case of a top-level Query field, the rootValue passed from the server configuration."
Title,context: an object shared by all resolvers in a particular query; typically used to contain per-request state.
Title,info: an object that contains information about the execution state of the query.
Title,args: an object with the arguments passed into the field in the query.
Title,
Title,
Title,Module
Title,"Once we're done with the above steps, we have declaratively specified all the information needed by the GraphQLModule to generate a resolver map. The GraphQLModule uses reflection to introspect the meta data provided via the decorators, and transforms classes into the correct resolver map automatically."
Title,"The only other thing you need to take care of is to provide (i.e., list as a provider in some module) the resolver class(es) (AuthorsResolver), and importing the module (AuthorsModule) somewhere, so Nest will be able to utilize it."
Title,"For example, we can do this in an AuthorsModule, which can also provide other services needed in this context. Be sure to import AuthorsModule somewhere (e.g., in the root module, or some other module imported by the root module)."
Title,typescript
Title,@@filename(authors/authors.module)
Title,@Module({
Title,"imports: [PostsModule],"
Title,"providers: [AuthorsService, AuthorsResolver],"
Title,})
Title,export class AuthorsModule {}
Title,
Title,"info Hint It is helpful to organize your code by your so-called domain model (similar to the way you would organize entry points in a REST API). In this approach, keep your models (ObjectType classes), resolvers and services together within a Nest module representing the domain model. Keep all of these components in a single folder per module. When you do this, and use the Nest CLI to generate each element, Nest will wire all of these parts together (locating files in appropriate folders, generating entries in provider and imports arrays, etc.) automatically for you."
Title,
Title,
Title,Scalars
Title,"A GraphQL object type has a name and fields, but at some point those fields have to resolve to some concrete data. That's where the scalar types come in: they represent the leaves of the query (read more here). GraphQL includes the following default types: Int, Float, String, Boolean and ID. In addition to these built-in types, you may need to support custom atomic data types (e.g., Date)."
Title,Code first
Title,The code-first approach ships with five scalars in which three of them are simple aliases for the existing GraphQL types.
Title,
Title,"ID (alias for GraphQLID) - represents a unique identifier, often used to refetch an object or as the key for a cache"
Title,Int (alias for GraphQLInt) - a signed 32‐bit integer
Title,Float (alias for GraphQLFloat) - a signed double-precision floating-point value
Title,GraphQLISODateTime - a date-time string at UTC (used by default to represent Date type)
Title,GraphQLTimestamp - a signed integer which represents date and time as number of milliseconds from start of UNIX epoch
Title,
Title,"The GraphQLISODateTime (e.g. 2019-12-03T09:54:33Z) is used by default to represent the Date type. To use the GraphQLTimestamp instead, set the dateScalarMode of the buildSchemaOptions object to 'timestamp' as follows:"
Title,typescript
Title,GraphQLModule.forRoot({
Title,buildSchemaOptions: {
Title,"dateScalarMode: 'timestamp',"
Title,}
Title,"}),"
Title,"Likewise, the GraphQLFloat is used by default to represent the number type. To use the GraphQLInt instead, set the numberScalarMode of the buildSchemaOptions object to 'integer' as follows:"
Title,typescript
Title,GraphQLModule.forRoot({
Title,buildSchemaOptions: {
Title,"numberScalarMode: 'integer',"
Title,}
Title,"}),"
Title,"In addition, you can create custom scalars."
Title,Override a default scalar
Title,"To create a custom implementation for the Date scalar, simply create a new class."
Title,```typescript
Title,"import { Scalar, CustomScalar } from '@nestjs/graphql';"
Title,"import { Kind, ValueNode } from 'graphql';"
Title,"@Scalar('Date', () => Date)"
Title,export class DateScalar implements CustomScalar {
Title,description = 'Date custom scalar type';
Title,parseValue(value: number): Date {
Title,return new Date(value); // value from the client
Title,}
Title,serialize(value: Date): number {
Title,return value.getTime(); // value sent to the client
Title,}
Title,parseLiteral(ast: ValueNode): Date {
Title,if (ast.kind === Kind.INT) {
Title,return new Date(ast.value);
Title,}
Title,return null;
Title,}
Title,}
Title,```
Title,"With this in place, register DateScalar as a provider."
Title,typescript
Title,@Module({
Title,"providers: [DateScalar],"
Title,})
Title,export class CommonModule {}
Title,Now we can use the Date type in our classes.
Title,typescript
Title,@Field()
Title,creationDate: Date;
Title,Import a custom scalar
Title,"To use a custom scalar, import and register it as a resolver. We’ll use the graphql-type-json package for demonstration purposes. This npm package defines a JSON GraphQL scalar type."
Title,Start by installing the package:
Title,bash
Title,$ npm i --save graphql-type-json
Title,"Once the package is installed, we pass a custom resolver to the forRoot() method:"
Title,```typescript
Title,import GraphQLJSON from 'graphql-type-json';
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"resolvers: { JSON: GraphQLJSON },"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,Now we can use the JSON type in our classes.
Title,typescript
Title,@Field(() => GraphQLJSON)
Title,info: JSON;
Title,"For a suite of useful scalars, take a look at the graphql-scalars package."
Title,Create a custom scalar
Title,"To define a custom scalar, create a new GraphQLScalarType instance. We'll create a custom UUID scalar."
Title,```typescript
Title,const regex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
Title,function validate(uuid: unknown): string | never {
Title,if (typeof uuid !== 'string' || !regex.test(uuid)) {
Title,throw new Error('invalid uuid');
Title,}
Title,return uuid;
Title,}
Title,export const CustomUuidScalar = new GraphQLScalarType({
Title,"name: 'UUID',"
Title,"description: 'A simple UUID parser',"
Title,"serialize: (value) => validate(value),"
Title,"parseValue: (value) => validate(value),"
Title,"parseLiteral: (ast) => validate(ast.value),"
Title,});
Title,```
Title,We pass a custom resolver to the forRoot() method:
Title,typescript
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"resolvers: { UUID: CustomUuidScalar },"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,Now we can use the UUID type in our classes.
Title,typescript
Title,@Field(() => CustomUuidScalar)
Title,uuid: string;
Title,Schema first
Title,"To define a custom scalar (read more about scalars here), create a type definition and a dedicated resolver. Here (as in the official documentation), we’ll use the graphql-type-json package for demonstration purposes. This npm package defines a JSON GraphQL scalar type."
Title,Start by installing the package:
Title,bash
Title,$ npm i --save graphql-type-json
Title,"Once the package is installed, we pass a custom resolver to the forRoot() method:"
Title,```typescript
Title,import GraphQLJSON from 'graphql-type-json';
Title,@Module({
Title,imports: [
Title,GraphQLModule.forRoot({
Title,"typePaths: ['./*/.graphql'],"
Title,"resolvers: { JSON: GraphQLJSON },"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,Now we can use the JSON scalar in our type definitions:
Title,```graphql
Title,scalar JSON
Title,type Foo {
Title,field: JSON
Title,}
Title,```
Title,Another method to define a scalar type is to create a simple class. Assume we want to enhance our schema with the Date type.
Title,```typescript
Title,"import { Scalar, CustomScalar } from '@nestjs/graphql';"
Title,"import { Kind, ValueNode } from 'graphql';"
Title,@Scalar('Date')
Title,export class DateScalar implements CustomScalar {
Title,description = 'Date custom scalar type';
Title,parseValue(value: number): Date {
Title,return new Date(value); // value from the client
Title,}
Title,serialize(value: Date): number {
Title,return value.getTime(); // value sent to the client
Title,}
Title,parseLiteral(ast: ValueNode): Date {
Title,if (ast.kind === Kind.INT) {
Title,return new Date(ast.value);
Title,}
Title,return null;
Title,}
Title,}
Title,```
Title,"With this in place, register DateScalar as a provider."
Title,typescript
Title,@Module({
Title,"providers: [DateScalar],"
Title,})
Title,export class CommonModule {}
Title,Now we can use the Date scalar in type definitions.
Title,graphql
Title,scalar Date
Title,"By default, the generated TypeScript definition for all scalars is any - which isn't particularly typesafe."
Title,"But, you can configure how Nest generates typings for your custom scalars when you specify how to generate types:"
Title,```typescript
Title,import { GraphQLDefinitionsFactory } from '@nestjs/graphql';
Title,import { join } from 'path';
Title,const definitionsFactory = new GraphQLDefinitionsFactory();
Title,definitionsFactory.generate({
Title,"typePaths: ['./src/*/.graphql'],"
Title,"path: join(process.cwd(), 'src/graphql.ts'),"
Title,"outputAs: 'class',"
Title,"defaultScalarType: 'unknown',"
Title,customScalarTypeMapping: {
Title,"DateTime: 'Date',"
Title,"BigNumber: '_BigNumber',"
Title,"},"
Title,"additionalHeader: ""import _BigNumber from 'bignumber.js'"","
Title,});
Title,```
Title,
Title,"info Hint Alternatively, you can use a type reference instead, for example: DateTime: Date. In this case, GraphQLDefinitionsFactory will extract the name property of the specified type (Date.name) to generate TS definitions. Note: adding an import statement for non-built-in types (custom types) is required."
Title,
Title,"Now, given the following GraphQL custom scalar types:"
Title,graphql
Title,scalar DateTime
Title,scalar BigNumber
Title,scalar Payload
Title,We will now see the following generated TypeScript definitions in src/graphql.ts:
Title,```typescript
Title,import _BigNumber from 'bignumber.js';
Title,export type DateTime = Date;
Title,export type BigNumber = _BigNumber;
Title,export type Payload = unknown;
Title,```
Title,"Here, we've used the customScalarTypeMapping property to supply a map of the types we wish to declare for our custom scalars. We've"
Title,"also provided an additionalHeader property so that we can add any imports required for these type definitions. Lastly, we've added"
Title,"a defaultScalarType of 'unknown', so that any custom scalars not specified in customScalarTypeMapping will be aliased to"
Title,unknown instead of any (which TypeScript recommends using since 3.0 for added type safety).
Title,
Title,info Hint Note that we've imported _BigNumber from bignumber.js; this is to avoid circular type references.
Title,
Title,
Title,Generating SDL
Title,
Title,warning Warning This chapter applies only to the code first approach.
Title,
Title,"To manually generate a GraphQL SDL schema (i.e., without running an application, connecting to the database, hooking up resolvers, etc.), use the GraphQLSchemaBuilderModule."
Title,```typescript
Title,async function generateSchema() {
Title,const app = await NestFactory.create(GraphQLSchemaBuilderModule);
Title,await app.init();
Title,const gqlSchemaFactory = app.get(GraphQLSchemaFactory);
Title,const schema = await gqlSchemaFactory.create([RecipesResolver]);
Title,console.log(printSchema(schema));
Title,}
Title,```
Title,
Title,info Hint The GraphQLSchemaBuilderModule and GraphQLSchemaFactory are imported from the @nestjs/graphql package. The printSchema function is imported from the graphql package.
Title,
Title,Usage
Title,The gqlSchemaFactory.create() method takes an array of resolver class references. For example:
Title,typescript
Title,const schema = await gqlSchemaFactory.create([
Title,"RecipesResolver,"
Title,"AuthorsResolver,"
Title,"PostsResolvers,"
Title,]);
Title,It also takes a second optional argument with an array of scalar classes:
Title,typescript
Title,const schema = await gqlSchemaFactory.create(
Title,"[RecipesResolver, AuthorsResolver, PostsResolvers],"
Title,"[DurationScalar, DateScalar],"
Title,);
Title,"Lastly, you can pass an options object:"
Title,typescript
Title,"const schema = await gqlSchemaFactory.create([RecipesResolver], {"
Title,"skipCheck: true,"
Title,"orphanedTypes: [],"
Title,});
Title,
Title,"skipCheck: ignore schema validation; boolean, defaults to false"
Title,"orphanedTypes: list of classes that are not explicitly referenced (not part of the object graph) to be generated. Normally, if a class is declared but isn't otherwise referenced in the graph, it's omitted. The property value is an array of class references."
Title,
Title,
Title,Sharing models
Title,
Title,warning Warning This chapter applies only to the code first approach.
Title,
Title,"One of the biggest advantages of using Typescript for the backend of your project is the ability to reuse the same models in a Typescript-based frontend application, by using a common Typescript package."
Title,"But there's a problem: the models created using the code first approach are heavily decorated with GraphQL related decorators. Those decorators are irrelevant in the frontend, negatively impacting performance."
Title,Using the model shim
Title,"To solve this issue, NestJS provides a ""shim"" which allows you to replace the original decorators with inert code by using a webpack (or similar) configuration."
Title,"To use this shim, configure an alias between the @nestjs/graphql package and the shim."
Title,"For example, for webpack this is resolved this way:"
Title,typescript
Title,resolve: { // see: https://webpack.js.org/configuration/resolve/
Title,alias: {
Title,"""@nestjs/graphql"": path.resolve(__dirname, ""../node_modules/@nestjs/graphql/dist/extra/graphql-model-shim"")"
Title,}
Title,}
Title,
Title,info Hint The TypeORM package has a similar shim that can be found here.
Title,
Title,
Title,Subscriptions
Title,"In addition to fetching data using queries and modifying data using mutations, the GraphQL spec supports a third operation type, called subscription. GraphQL subscriptions are a way to push data from the server to the clients that choose to listen to real time messages from the server. Subscriptions are similar to queries in that they specify a set of fields to be delivered to the client, but instead of immediately returning a single answer, a channel is opened and a result is sent to the client every time a particular event happens on the server."
Title,"A common use case for subscriptions is notifying the client side about particular events, for example the creation of a new object, updated fields and so on (read more here)."
Title,Enable subscriptions with Apollo driver
Title,"To enable subscriptions, set the installSubscriptionHandlers property to true."
Title,typescript
Title,GraphQLModule.forRoot<ApolloDriverConfig>({
Title,"driver: ApolloDriver,"
Title,"installSubscriptionHandlers: true,"
Title,"}),"
Title,
Title,"warning Warning The installSubscriptionHandlers configuration option has been removed from the latest version of Apollo server and will be soon deprecated in this package as well. By default, installSubscriptionHandlers will fallback to use the subscriptions-transport-ws (read more) but we strongly recommend using the graphql-ws(read more) library instead."
Title,
Title,"To switch to use the graphql-ws package instead, use the following configuration:"
Title,typescript
Title,GraphQLModule.forRoot<ApolloDriverConfig>({
Title,"driver: ApolloDriver,"
Title,subscriptions: {
Title,'graphql-ws': true
Title,"},"
Title,"}),"
Title,
Title,"info Hint You can also use both packages (subscriptions-transport-ws and graphql-ws) at the same time, for example, for backward compatibility."
Title,
Title,Code first
Title,"To create a subscription using the code first approach, we use the @Subscription() decorator (exported from the @nestjs/graphql package) and the PubSub class from the graphql-subscriptions package, which provides a simple publish/subscribe API."
Title,"The following subscription handler takes care of subscribing to an event by calling PubSub#asyncIterator. This method takes a single argument, the triggerName, which corresponds to an event topic name."
Title,```typescript
Title,const pubSub = new PubSub();
Title,@Resolver(() => Author)
Title,export class AuthorResolver {
Title,// ...
Title,@Subscription(() => Comment)
Title,commentAdded() {
Title,return pubSub.asyncIterator('commentAdded');
Title,}
Title,}
Title,```
Title,
Title,"info Hint All decorators are exported from the @nestjs/graphql package, while the PubSub class is exported from the graphql-subscriptions package."
Title,warning Note PubSub is a class that exposes a simple publish and subscribe API. Read more about it here. Note that the Apollo docs warn that the default implementation is not suitable for production (read more here). Production apps should use a PubSub implementation backed by an external store (read more here).
Title,
Title,This will result in generating the following part of the GraphQL schema in SDL:
Title,graphql
Title,type Subscription {
Title,commentAdded(): Comment!
Title,}
Title,"Note that subscriptions, by definition, return an object with a single top level property whose key is the name of the subscription. This name is either inherited from the name of the subscription handler method (i.e., commentAdded above), or is provided explicitly by passing an option with the key name as the second argument to the @Subscription() decorator, as shown below."
Title,typescript
Title,"@Subscription(() => Comment, {"
Title,"name: 'commentAdded',"
Title,})
Title,subscribeToCommentAdded() {
Title,return pubSub.asyncIterator('commentAdded');
Title,}
Title,"This construct produces the same SDL as the previous code sample, but allows us to decouple the method name from the subscription."
Title,Publishing
Title,"Now, to publish the event, we use the PubSub#publish method. This is often used within a mutation to trigger a client-side update when a part of the object graph has changed. For example:"
Title,typescript
Title,@@filename(posts/posts.resolver)
Title,@Mutation(() => Comment)
Title,async addComment(
Title,"@Args('postId', { type: () => Int }) postId: number,"
Title,"@Args('comment', { type: () => Comment }) comment: CommentInput,"
Title,) {
Title,"const newComment = this.commentsService.addComment({ id: postId, comment });"
Title,"pubSub.publish('commentAdded', { commentAdded: newComment });"
Title,return newComment;
Title,}
Title,"The PubSub#publish method takes a triggerName (again, think of this as an event topic name) as the first parameter, and an event payload as the second parameter. As mentioned, the subscription, by definition, returns a value and that value has a shape. Look again at the generated SDL for our commentAdded subscription:"
Title,graphql
Title,type Subscription {
Title,commentAdded(): Comment!
Title,}
Title,"This tells us that the subscription must return an object with a top-level property name of commentAdded that has a value which is a Comment object. The important point to note is that the shape of the event payload emitted by the PubSub#publish method must correspond to the shape of the value expected to return from the subscription. So, in our example above, the pubSub.publish('commentAdded', {{ '{' }} commentAdded: newComment {{ '}' }}) statement publishes a commentAdded event with the appropriately shaped payload. If these shapes don't match, your subscription will fail during the GraphQL validation phase."
Title,Filtering subscriptions
Title,"To filter out specific events, set the filter property to a filter function. This function acts similar to the function passed to an array filter. It takes two arguments: payload containing the event payload (as sent by the event publisher), and variables taking any arguments passed in during the subscription request. It returns a boolean determining whether this event should be published to client listeners."
Title,typescript
Title,"@Subscription(() => Comment, {"
Title,"filter: (payload, variables) =>"
Title,"payload.commentAdded.title === variables.title,"
Title,})
Title,commentAdded(@Args('title') title: string) {
Title,return pubSub.asyncIterator('commentAdded');
Title,}
Title,Mutating subscription payloads
Title,"To mutate the published event payload, set the resolve property to a function. The function receives the event payload (as sent by the event publisher) and returns the appropriate value."
Title,typescript
Title,"@Subscription(() => Comment, {"
Title,"resolve: value => value,"
Title,})
Title,commentAdded() {
Title,return pubSub.asyncIterator('commentAdded');
Title,}
Title,
Title,"warning Note If you use the resolve option, you should return the unwrapped payload (e.g., with our example, return a newComment object directly, not a {{ '{' }} commentAdded: newComment {{ '}' }} object)."
Title,
Title,"If you need to access injected providers (e.g., use an external service to validate the data), use the following construction."
Title,typescript
Title,"@Subscription(() => Comment, {"
Title,"resolve(this: AuthorResolver, value) {"
Title,"// ""this"" refers to an instance of ""AuthorResolver"""
Title,return value;
Title,}
Title,})
Title,commentAdded() {
Title,return pubSub.asyncIterator('commentAdded');
Title,}
Title,The same construction works with filters:
Title,typescript
Title,"@Subscription(() => Comment, {"
Title,"filter(this: AuthorResolver, payload, variables) {"
Title,"// ""this"" refers to an instance of ""AuthorResolver"""
Title,return payload.commentAdded.title === variables.title;
Title,}
Title,})
Title,commentAdded() {
Title,return pubSub.asyncIterator('commentAdded');
Title,}
Title,Schema first
Title,"To create an equivalent subscription in Nest, we'll make use of the @Subscription() decorator."
Title,```typescript
Title,const pubSub = new PubSub();
Title,@Resolver('Author')
Title,export class AuthorResolver {
Title,// ...
Title,@Subscription()
Title,commentAdded() {
Title,return pubSub.asyncIterator('commentAdded');
Title,}
Title,}
Title,```
Title,"To filter out specific events based on context and arguments, set the filter property."
Title,typescript
Title,"@Subscription('commentAdded', {"
Title,"filter: (payload, variables) =>"
Title,"payload.commentAdded.title === variables.title,"
Title,})
Title,commentAdded() {
Title,return pubSub.asyncIterator('commentAdded');
Title,}
Title,"To mutate the published payload, we can use a resolve function."
Title,typescript
Title,"@Subscription('commentAdded', {"
Title,"resolve: value => value,"
Title,})
Title,commentAdded() {
Title,return pubSub.asyncIterator('commentAdded');
Title,}
Title,"If you need to access injected providers (e.g., use an external service to validate the data), use the following construction:"
Title,typescript
Title,"@Subscription('commentAdded', {"
Title,"resolve(this: AuthorResolver, value) {"
Title,"// ""this"" refers to an instance of ""AuthorResolver"""
Title,return value;
Title,}
Title,})
Title,commentAdded() {
Title,return pubSub.asyncIterator('commentAdded');
Title,}
Title,The same construction works with filters:
Title,typescript
Title,"@Subscription('commentAdded', {"
Title,"filter(this: AuthorResolver, payload, variables) {"
Title,"// ""this"" refers to an instance of ""AuthorResolver"""
Title,return payload.commentAdded.title === variables.title;
Title,}
Title,})
Title,commentAdded() {
Title,return pubSub.asyncIterator('commentAdded');
Title,}
Title,The last step is to update the type definitions file.
Title,```graphql
Title,type Author {
Title,id: Int!
Title,firstName: String
Title,lastName: String
Title,posts: [Post]
Title,}
Title,type Post {
Title,id: Int!
Title,title: String
Title,votes: Int
Title,}
Title,type Query {
Title,author(id: Int!): Author
Title,}
Title,type Comment {
Title,id: String
Title,content: String
Title,}
Title,type Subscription {
Title,commentAdded(title: String!): Comment
Title,}
Title,```
Title,"With this, we've created a single commentAdded(title: String!): Comment subscription. You can find a full sample implementation here."
Title,PubSub
Title,"We instantiated a local PubSub instance above. The preferred approach is to define PubSub as a provider and inject it through the constructor (using the @Inject() decorator). This allows us to re-use the instance across the whole application. For example, define a provider as follows, then inject 'PUB_SUB' where needed."
Title,typescript
Title,{
Title,"provide: 'PUB_SUB',"
Title,"useValue: new PubSub(),"
Title,}
Title,Customize subscriptions server
Title,"To customize the subscriptions server (e.g., change the path), use the subscriptions options property."
Title,typescript
Title,GraphQLModule.forRoot<ApolloDriverConfig>({
Title,"driver: ApolloDriver,"
Title,subscriptions: {
Title,'subscriptions-transport-ws': {
Title,path: '/graphql'
Title,"},"
Title,}
Title,"}),"
Title,"If you're using the graphql-ws package for subscriptions, replace the subscriptions-transport-ws key with graphql-ws, as follows:"
Title,typescript
Title,GraphQLModule.forRoot<ApolloDriverConfig>({
Title,"driver: ApolloDriver,"
Title,subscriptions: {
Title,'graphql-ws': {
Title,path: '/graphql'
Title,"},"
Title,}
Title,"}),"
Title,Authentication over WebSockets
Title,Checking whether the user is authenticated can be done inside the onConnect callback function that you can specify in the subscriptions options.
Title,The onConnect will receive as a first argument the connectionParams passed to the SubscriptionClient (read more).
Title,typescript
Title,GraphQLModule.forRoot<ApolloDriverConfig>({
Title,"driver: ApolloDriver,"
Title,subscriptions: {
Title,'subscriptions-transport-ws': {
Title,onConnect: (connectionParams) => {
Title,const authToken = connectionParams.authToken;
Title,if (!isValid(authToken)) {
Title,throw new Error('Token is not valid');
Title,}
Title,// extract user information from token
Title,const user = parseToken(authToken);
Title,// return user info to add them to the context later
Title,return { user };
Title,"},"
Title,}
Title,"},"
Title,context: ({ connection }) => {
Title,"// connection.context will be equal to what was returned by the ""onConnect"" callback"
Title,"},"
Title,"}),"
Title,"The authToken in this example is only sent once by the client, when the connection is first established."
Title,"All subscriptions made with this connection will have the same authToken, and thus the same user info."
Title,
Title,"warning Note There is a bug in subscriptions-transport-ws that allows connections to skip the onConnect phase (read more). You should not assume that onConnect was called when the user starts a subscription, and always check that the context is populated."
Title,
Title,"If you're using the graphql-ws package, the signature of the onConnect callback will be slightly different:"
Title,typescript
Title,GraphQLModule.forRoot<ApolloDriverConfig>({
Title,"driver: ApolloDriver,"
Title,subscriptions: {
Title,'graphql-ws': {
Title,onConnect: (context: Context<any>) => {
Title,"const { connectionParams, extra } = context;"
Title,// user validation will remain the same as in the example above
Title,"// when using with graphql-ws, additional context value should be stored in the extra field"
Title,extra.user = { user: {} };
Title,"},"
Title,"},"
Title,"},"
Title,context: ({ extra }) => {
Title,// you can now access your additional context value through the extra field
Title,"},"
Title,});
Title,Enable subscriptions with Mercurius driver
Title,"To enable subscriptions, set the subscription property to true."
Title,typescript
Title,GraphQLModule.forRoot<MercuriusDriverConfig>({
Title,"driver: MercuriusDriver,"
Title,"subscription: true,"
Title,"}),"
Title,
Title,"info Hint You can also pass the options object to set up a custom emitter, validate incoming connections, etc. Read more here (see subscription)."
Title,
Title,Code first
Title,"To create a subscription using the code first approach, we use the @Subscription() decorator (exported from the @nestjs/graphql package) and the PubSub class from the mercurius package, which provides a simple publish/subscribe API."
Title,"The following subscription handler takes care of subscribing to an event by calling PubSub#asyncIterator. This method takes a single argument, the triggerName, which corresponds to an event topic name."
Title,typescript
Title,@Resolver(() => Author)
Title,export class AuthorResolver {
Title,// ...
Title,@Subscription(() => Comment)
Title,commentAdded(@Context('pubsub') pubSub: PubSub) {
Title,return pubSub.subscribe('commentAdded');
Title,}
Title,}
Title,
Title,"info Hint All decorators used in the example above are exported from the @nestjs/graphql package, while the PubSub class is exported from the mercurius package."
Title,warning Note PubSub is a class that exposes a simple publish and subscribe API. Check out this section on how to register a custom PubSub class.
Title,
Title,This will result in generating the following part of the GraphQL schema in SDL:
Title,graphql
Title,type Subscription {
Title,commentAdded(): Comment!
Title,}
Title,"Note that subscriptions, by definition, return an object with a single top level property whose key is the name of the subscription. This name is either inherited from the name of the subscription handler method (i.e., commentAdded above), or is provided explicitly by passing an option with the key name as the second argument to the @Subscription() decorator, as shown below."
Title,typescript
Title,"@Subscription(() => Comment, {"
Title,"name: 'commentAdded',"
Title,})
Title,subscribeToCommentAdded(@Context('pubsub') pubSub: PubSub) {
Title,return pubSub.subscribe('commentAdded');
Title,}
Title,"This construct produces the same SDL as the previous code sample, but allows us to decouple the method name from the subscription."
Title,Publishing
Title,"Now, to publish the event, we use the PubSub#publish method. This is often used within a mutation to trigger a client-side update when a part of the object graph has changed. For example:"
Title,typescript
Title,@@filename(posts/posts.resolver)
Title,@Mutation(() => Comment)
Title,async addComment(
Title,"@Args('postId', { type: () => Int }) postId: number,"
Title,"@Args('comment', { type: () => Comment }) comment: CommentInput,"
Title,"@Context('pubsub') pubSub: PubSub,"
Title,) {
Title,"const newComment = this.commentsService.addComment({ id: postId, comment });"
Title,await pubSub.publish({
Title,"topic: 'commentAdded',"
Title,payload: {
Title,commentAdded: newComment
Title,}
Title,});
Title,return newComment;
Title,}
Title,"As mentioned, the subscription, by definition, returns a value and that value has a shape. Look again at the generated SDL for our commentAdded subscription:"
Title,graphql
Title,type Subscription {
Title,commentAdded(): Comment!
Title,}
Title,"This tells us that the subscription must return an object with a top-level property name of commentAdded that has a value which is a Comment object. The important point to note is that the shape of the event payload emitted by the PubSub#publish method must correspond to the shape of the value expected to return from the subscription. So, in our example above, the pubSub.publish({{ '{' }} topic: 'commentAdded', payload: {{ '{' }} commentAdded: newComment {{ '}' }} {{ '}' }}) statement publishes a commentAdded event with the appropriately shaped payload. If these shapes don't match, your subscription will fail during the GraphQL validation phase."
Title,Filtering subscriptions
Title,"To filter out specific events, set the filter property to a filter function. This function acts similar to the function passed to an array filter. It takes two arguments: payload containing the event payload (as sent by the event publisher), and variables taking any arguments passed in during the subscription request. It returns a boolean determining whether this event should be published to client listeners."
Title,typescript
Title,"@Subscription(() => Comment, {"
Title,"filter: (payload, variables) =>"
Title,"payload.commentAdded.title === variables.title,"
Title,})
Title,"commentAdded(@Args('title') title: string, @Context('pubsub') pubSub: PubSub) {"
Title,return pubSub.subscribe('commentAdded');
Title,}
Title,"If you need to access injected providers (e.g., use an external service to validate the data), use the following construction."
Title,typescript
Title,"@Subscription(() => Comment, {"
Title,"filter(this: AuthorResolver, payload, variables) {"
Title,"// ""this"" refers to an instance of ""AuthorResolver"""
Title,return payload.commentAdded.title === variables.title;
Title,}
Title,})
Title,"commentAdded(@Args('title') title: string, @Context('pubsub') pubSub: PubSub) {"
Title,return pubSub.subscribe('commentAdded');
Title,}
Title,Schema first
Title,"To create an equivalent subscription in Nest, we'll make use of the @Subscription() decorator."
Title,```typescript
Title,const pubSub = new PubSub();
Title,@Resolver('Author')
Title,export class AuthorResolver {
Title,// ...
Title,@Subscription()
Title,commentAdded(@Context('pubsub') pubSub: PubSub) {
Title,return pubSub.subscribe('commentAdded');
Title,}
Title,}
Title,```
Title,"To filter out specific events based on context and arguments, set the filter property."
Title,typescript
Title,"@Subscription('commentAdded', {"
Title,"filter: (payload, variables) =>"
Title,"payload.commentAdded.title === variables.title,"
Title,})
Title,commentAdded(@Context('pubsub') pubSub: PubSub) {
Title,return pubSub.subscribe('commentAdded');
Title,}
Title,"If you need to access injected providers (e.g., use an external service to validate the data), use the following construction:"
Title,typescript
Title,"@Subscription('commentAdded', {"
Title,"filter(this: AuthorResolver, payload, variables) {"
Title,"// ""this"" refers to an instance of ""AuthorResolver"""
Title,return payload.commentAdded.title === variables.title;
Title,}
Title,})
Title,commentAdded(@Context('pubsub') pubSub: PubSub) {
Title,return pubSub.subscribe('commentAdded');
Title,}
Title,The last step is to update the type definitions file.
Title,```graphql
Title,type Author {
Title,id: Int!
Title,firstName: String
Title,lastName: String
Title,posts: [Post]
Title,}
Title,type Post {
Title,id: Int!
Title,title: String
Title,votes: Int
Title,}
Title,type Query {
Title,author(id: Int!): Author
Title,}
Title,type Comment {
Title,id: String
Title,content: String
Title,}
Title,type Subscription {
Title,commentAdded(title: String!): Comment
Title,}
Title,```
Title,"With this, we've created a single commentAdded(title: String!): Comment subscription."
Title,PubSub
Title,"In the examples above, we used the default PubSub emitter (mqemitter)"
Title,"The preferred approach (for production) is to use mqemitter-redis. Alternatively, a custom PubSub implementation can be provided (read more here)"
Title,typescript
Title,GraphQLModule.forRoot<MercuriusDriverConfig>({
Title,"driver: MercuriusDriver,"
Title,subscription: {
Title,emitter: require('mqemitter-redis')({
Title,"port: 6579,"
Title,"host: '127.0.0.1',"
Title,"}),"
Title,"},"
Title,});
Title,Authentication over WebSockets
Title,Checking whether the user is authenticated can be done inside the verifyClient callback function that you can specify in the subscription options.
Title,The verifyClient will receive the info object as a first argument which you can use to retrieve the request's headers.
Title,typescript
Title,GraphQLModule.forRoot<MercuriusDriverConfig>({
Title,"driver: MercuriusDriver,"
Title,subscription: {
Title,"verifyClient: (info, next) => {"
Title,const authorization = info.req.headers?.authorization as string;
Title,if (!authorization?.startsWith('Bearer ')) {
Title,return next(false);
Title,}
Title,next(true);
Title,"},"
Title,}
Title,"}),"
Title,
Title,Unions
Title,"Union types are very similar to interfaces, but they don't get to specify any common fields between the types (read more here). Unions are useful for returning disjoint data types from a single field."
Title,Code first
Title,"To define a GraphQL union type, we must define classes that this union will be composed of. Following the example from the Apollo documentation, we'll create two classes. First, Book:"
Title,```typescript
Title,"import { Field, ObjectType } from '@nestjs/graphql';"
Title,@ObjectType()
Title,export class Book {
Title,@Field()
Title,title: string;
Title,}
Title,```
Title,And then Author:
Title,```typescript
Title,"import { Field, ObjectType } from '@nestjs/graphql';"
Title,@ObjectType()
Title,export class Author {
Title,@Field()
Title,name: string;
Title,}
Title,```
Title,"With this in place, register the ResultUnion union using the createUnionType function exported from the @nestjs/graphql package:"
Title,typescript
Title,export const ResultUnion = createUnionType({
Title,"name: 'ResultUnion',"
Title,"types: () => [Author, Book] as const,"
Title,});
Title,
Title,"warning Warning The array returned by the types property of the createUnionType function should be given a const assertion. If the const assertion is not given, a wrong declaration file will be generated at compile time, and an error will occur when using it from another project."
Title,
Title,"Now, we can reference the ResultUnion in our query:"
Title,typescript
Title,@Query(() => [ResultUnion])
Title,search(): Array<typeof ResultUnion> {
Title,"return [new Author(), new Book()];"
Title,}
Title,This will result in generating the following part of the GraphQL schema in SDL:
Title,```graphql
Title,type Author {
Title,name: String!
Title,}
Title,type Book {
Title,title: String!
Title,}
Title,union ResultUnion = Author | Book
Title,type Query {
Title,search: [ResultUnion!]!
Title,}
Title,```
Title,The default resolveType() function generated by the library will extract the type based on the value returned from the resolver method. That means returning class instances instead of literal JavaScript object is obligatory.
Title,"To provide a customized resolveType() function, pass the resolveType property to the options object passed into the createUnionType() function, as follows:"
Title,typescript
Title,export const ResultUnion = createUnionType({
Title,"name: 'ResultUnion',"
Title,"types: () => [Author, Book] as const,"
Title,resolveType(value) {
Title,if (value.name) {
Title,return Author;
Title,}
Title,if (value.title) {
Title,return Book;
Title,}
Title,return null;
Title,"},"
Title,});
Title,Schema first
Title,"To define a union in the schema first approach, simply create a GraphQL union with SDL."
Title,```graphql
Title,type Author {
Title,name: String!
Title,}
Title,type Book {
Title,title: String!
Title,}
Title,union ResultUnion = Author | Book
Title,```
Title,"Then, you can use the typings generation feature (as shown in the quick start chapter) to generate corresponding TypeScript definitions:"
Title,```typescript
Title,export class Author {
Title,name: string;
Title,}
Title,export class Book {
Title,title: string;
Title,}
Title,export type ResultUnion = Author | Book;
Title,```
Title,"Unions require an extra __resolveType field in the resolver map to determine which type the union should resolve to. Also, note that the ResultUnionResolver class has to be registered as a provider in any module. Let's create a ResultUnionResolver class and define the __resolveType method."
Title,typescript
Title,@Resolver('ResultUnion')
Title,export class ResultUnionResolver {
Title,@ResolveField()
Title,__resolveType(value) {
Title,if (value.name) {
Title,return 'Author';
Title,}
Title,if (value.title) {
Title,return 'Book';
Title,}
Title,return null;
Title,}
Title,}
Title,
Title,info Hint All decorators are exported from the @nestjs/graphql package.
Title,
Title,Enums
Title,Enumeration types are a special kind of scalar that is restricted to a particular set of allowed values (read more here). This allows you to:
Title,
Title,validate that any arguments of this type are one of the allowed values
Title,communicate through the type system that a field will always be one of a finite set of values
Title,
Title,Code first
Title,"When using the code first approach, you define a GraphQL enum type by simply creating a TypeScript enum."
Title,typescript
Title,export enum AllowedColor {
Title,"RED,"
Title,"GREEN,"
Title,"BLUE,"
Title,}
Title,"With this in place, register the AllowedColor enum using the registerEnumType function exported from the @nestjs/graphql package:"
Title,typescript
Title,"registerEnumType(AllowedColor, {"
Title,"name: 'AllowedColor',"
Title,});
Title,Now you can reference the AllowedColor in our types:
Title,typescript
Title,@Field(type => AllowedColor)
Title,favoriteColor: AllowedColor;
Title,This will result in generating the following part of the GraphQL schema in SDL:
Title,graphql
Title,enum AllowedColor {
Title,RED
Title,GREEN
Title,BLUE
Title,}
Title,"To provide a description for the enum, pass the description property into the registerEnumType() function."
Title,typescript
Title,"registerEnumType(AllowedColor, {"
Title,"name: 'AllowedColor',"
Title,"description: 'The supported colors.',"
Title,});
Title,"To provide a description for the enum values, or to mark a value as deprecated, pass the valuesMap property, as follows:"
Title,typescript
Title,"registerEnumType(AllowedColor, {"
Title,"name: 'AllowedColor',"
Title,"description: 'The supported colors.',"
Title,valuesMap: {
Title,RED: {
Title,"description: 'The default color.',"
Title,"},"
Title,BLUE: {
Title,"deprecationReason: 'Too blue.',"
Title,"},"
Title,"},"
Title,});
Title,This will generate the following GraphQL schema in SDL:
Title,graphql
Title,""""""""
Title,The supported colors.
Title,""""""""
Title,enum AllowedColor {
Title,""""""""
Title,The default color.
Title,""""""""
Title,RED
Title,GREEN
Title,"BLUE @deprecated(reason: ""Too blue."")"
Title,}
Title,Schema first
Title,"To define an enumerator in the schema first approach, simply create a GraphQL enum with SDL."
Title,graphql
Title,enum AllowedColor {
Title,RED
Title,GREEN
Title,BLUE
Title,}
Title,Then you can use the typings generation feature (as shown in the quick start chapter) to generate corresponding TypeScript definitions:
Title,typescript
Title,export enum AllowedColor {
Title,RED
Title,GREEN
Title,BLUE
Title,}
Title,"Sometimes a backend forces a different value for an enum internally than in the public API. In this example the API contains RED, however in resolvers we may use #f00 instead (read more here). To accomplish this, declare a resolver object for the AllowedColor enum:"
Title,typescript
Title,"export const allowedColorResolver: Record<keyof typeof AllowedColor, any> = {"
Title,"RED: '#f00',"
Title,};
Title,
Title,info Hint All decorators are exported from the @nestjs/graphql package.
Title,
Title,"Then use this resolver object together with the resolvers property of the GraphQLModule#forRoot() method, as follows:"
Title,typescript
Title,GraphQLModule.forRoot({
Title,resolvers: {
Title,"AllowedColor: allowedColorResolver,"
Title,"},"
Title,});
Title,
Title,Guards
Title,"A guard is a class annotated with the @Injectable() decorator, which implements the CanActivate interface."
Title,
Title,"Guards have a single responsibility. They determine whether a given request will be handled by the route handler or not, depending on certain conditions (like permissions, roles, ACLs, etc.) present at run-time. This is often referred to as authorization. Authorization (and its cousin, authentication, with which it usually collaborates) has typically been handled by middleware in traditional Express applications. Middleware is a fine choice for authentication, since things like token validation and attaching properties to the request object are not strongly connected with a particular route context (and its metadata)."
Title,"But middleware, by its nature, is dumb. It doesn't know which handler will be executed after calling the next() function. On the other hand, Guards have access to the ExecutionContext instance, and thus know exactly what's going to be executed next. They're designed, much like exception filters, pipes, and interceptors, to let you interpose processing logic at exactly the right point in the request/response cycle, and to do so declaratively. This helps keep your code DRY and declarative."
Title,
Title,"info Hint Guards are executed after all middleware, but before any interceptor or pipe."
Title,
Title,Authorization guard
Title,"As mentioned, authorization is a great use case for Guards because specific routes should be available only when the caller (usually a specific authenticated user) has sufficient permissions. The AuthGuard that we'll build now assumes an authenticated user (and that, therefore, a token is attached to the request headers). It will extract and validate the token, and use the extracted information to determine whether the request can proceed or not."
Title,```typescript
Title,@@filename(auth.guard)
Title,"import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';"
Title,import { Observable } from 'rxjs';
Title,@Injectable()
Title,export class AuthGuard implements CanActivate {
Title,canActivate(
Title,"context: ExecutionContext,"
Title,): boolean | Promise | Observable {
Title,const request = context.switchToHttp().getRequest();
Title,return validateRequest(request);
Title,}
Title,}
Title,@@switch
Title,import { Injectable } from '@nestjs/common';
Title,@Injectable()
Title,export class AuthGuard {
Title,async canActivate(context) {
Title,const request = context.switchToHttp().getRequest();
Title,return validateRequest(request);
Title,}
Title,}
Title,```
Title,
Title,"info Hint If you are looking for a real-world example on how to implement an authentication mechanism in your application, visit this chapter. Likewise, for more sophisticated authorization example, check this page."
Title,
Title,The logic inside the validateRequest() function can be as simple or sophisticated as needed. The main point of this example is to show how guards fit into the request/response cycle.
Title,"Every guard must implement a canActivate() function. This function should return a boolean, indicating whether the current request is allowed or not. It can return the response either synchronously or asynchronously (via a Promise or Observable). Nest uses the return value to control the next action:"
Title,
Title,"if it returns true, the request will be processed."
Title,"if it returns false, Nest will deny the request."
Title,
Title,
Title,Execution context
Title,"The canActivate() function takes a single argument, the ExecutionContext instance. The ExecutionContext inherits from ArgumentsHost. We saw ArgumentsHost previously in the exception filters chapter. In the sample above, we are just using the same helper methods defined on ArgumentsHost that we used earlier, to get a reference to the Request object. You can refer back to the Arguments host section of the exception filters chapter for more on this topic."
Title,"By extending ArgumentsHost, ExecutionContext also adds several new helper methods that provide additional details about the current execution process. These details can be helpful in building more generic guards that can work across a broad set of controllers, methods, and execution contexts. Learn more about ExecutionContext here."
Title,Role-based authentication
Title,"Let's build a more functional guard that permits access only to users with a specific role. We'll start with a basic guard template, and build on it in the coming sections. For now, it allows all requests to proceed:"
Title,```typescript
Title,@@filename(roles.guard)
Title,"import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';"
Title,import { Observable } from 'rxjs';
Title,@Injectable()
Title,export class RolesGuard implements CanActivate {
Title,canActivate(
Title,"context: ExecutionContext,"
Title,): boolean | Promise | Observable {
Title,return true;
Title,}
Title,}
Title,@@switch
Title,import { Injectable } from '@nestjs/common';
Title,@Injectable()
Title,export class RolesGuard {
Title,canActivate(context) {
Title,return true;
Title,}
Title,}
Title,```
Title,Binding guards
Title,"Like pipes and exception filters, guards can be controller-scoped, method-scoped, or global-scoped. Below, we set up a controller-scoped guard using the @UseGuards() decorator. This decorator may take a single argument, or a comma-separated list of arguments. This lets you easily apply the appropriate set of guards with one declaration."
Title,typescript
Title,@@filename()
Title,@Controller('cats')
Title,@UseGuards(RolesGuard)
Title,export class CatsController {}
Title,
Title,info Hint The @UseGuards() decorator is imported from the @nestjs/common package.
Title,
Title,"Above, we passed the RolesGuard class (instead of an instance), leaving responsibility for instantiation to the framework and enabling dependency injection. As with pipes and exception filters, we can also pass an in-place instance:"
Title,typescript
Title,@@filename()
Title,@Controller('cats')
Title,@UseGuards(new RolesGuard())
Title,export class CatsController {}
Title,"The construction above attaches the guard to every handler declared by this controller. If we wish the guard to apply only to a single method, we apply the @UseGuards() decorator at the method level."
Title,"In order to set up a global guard, use the useGlobalGuards() method of the Nest application instance:"
Title,typescript
Title,@@filename()
Title,const app = await NestFactory.create(AppModule);
Title,app.useGlobalGuards(new RolesGuard());
Title,
Title,"warning Notice In the case of hybrid apps the useGlobalGuards() method doesn't set up guards for gateways and microservices by default (see Hybrid application for information on how to change this behavior). For ""standard"" (non-hybrid) microservice apps, useGlobalGuards() does mount the guards globally."
Title,
Title,"Global guards are used across the whole application, for every controller and every route handler. In terms of dependency injection, global guards registered from outside of any module (with useGlobalGuards() as in the example above) cannot inject dependencies since this is done outside the context of any module. In order to solve this issue, you can set up a guard directly from any module using the following construction:"
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { APP_GUARD } from '@nestjs/core';
Title,@Module({
Title,providers: [
Title,{
Title,"provide: APP_GUARD,"
Title,"useClass: RolesGuard,"
Title,"},"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,
Title,"info Hint When using this approach to perform dependency injection for the guard, note that regardless of the"
Title,"module where this construction is employed, the guard is, in fact, global. Where should this be done? Choose the module"
Title,"where the guard (RolesGuard in the example above) is defined. Also, useClass is not the only way of dealing with"
Title,custom provider registration. Learn more here.
Title,
Title,Setting roles per handler
Title,"Our RolesGuard is working, but it's not very smart yet. We're not yet taking advantage of the most important guard feature - the execution context. It doesn't yet know about roles, or which roles are allowed for each handler. The CatsController, for example, could have different permission schemes for different routes. Some might be available only for an admin user, and others could be open for everyone. How can we match roles to routes in a flexible and reusable way?"
Title,"This is where custom metadata comes into play (learn more here). Nest provides the ability to attach custom metadata to route handlers through either decorators created via Reflector#createDecorator static method, or the built-in @SetMetadata() decorator."
Title,"For example, let's create a @Roles() decorator using the Reflector#createDecorator method that will attach the metadata to the handler. Reflector is provided out of the box by the framework and exposed from the @nestjs/core package."
Title,```ts
Title,@@filename(roles.decorator)
Title,import { Reflector } from '@nestjs/core';
Title,export const Roles = Reflector.createDecorator();
Title,```
Title,The Roles decorator here is a function that takes a single argument of type string[].
Title,"Now, to use this decorator, we simply annotate the handler with it:"
Title,typescript
Title,@@filename(cats.controller)
Title,@Post()
Title,@Roles(['admin'])
Title,async create(@Body() createCatDto: CreateCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,@@switch
Title,@Post()
Title,@Roles(['admin'])
Title,@Bind(Body())
Title,async create(createCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,"Here we've attached the Roles decorator metadata to the create() method, indicating that only users with the admin role should be allowed to access this route."
Title,"Alternatively, instead of using the Reflector#createDecorator method, we could use the built-in @SetMetadata() decorator. Learn more about here."
Title,Putting it all together
Title,"Let's now go back and tie this together with our RolesGuard. Currently, it simply returns true in all cases, allowing every request to proceed. We want to make the return value conditional based on comparing the roles assigned to the current user to the actual roles required by the current route being processed. In order to access the route's role(s) (custom metadata), we'll use the Reflector helper class again, as follows:"
Title,```typescript
Title,@@filename(roles.guard)
Title,"import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';"
Title,import { Reflector } from '@nestjs/core';
Title,import { Roles } from './roles.decorator';
Title,@Injectable()
Title,export class RolesGuard implements CanActivate {
Title,constructor(private reflector: Reflector) {}
Title,canActivate(context: ExecutionContext): boolean {
Title,"const roles = this.reflector.get(Roles, context.getHandler());"
Title,if (!roles) {
Title,return true;
Title,}
Title,const request = context.switchToHttp().getRequest();
Title,const user = request.user;
Title,"return matchRoles(roles, user.roles);"
Title,}
Title,}
Title,@@switch
Title,"import { Injectable, Dependencies } from '@nestjs/common';"
Title,import { Reflector } from '@nestjs/core';
Title,import { Roles } from './roles.decorator';
Title,@Injectable()
Title,@Dependencies(Reflector)
Title,export class RolesGuard {
Title,constructor(reflector) {
Title,this.reflector = reflector;
Title,}
Title,canActivate(context) {
Title,"const roles = this.reflector.get(Roles, context.getHandler());"
Title,if (!roles) {
Title,return true;
Title,}
Title,const request = context.switchToHttp().getRequest();
Title,const user = request.user;
Title,"return matchRoles(roles, user.roles);"
Title,}
Title,}
Title,```
Title,
Title,"info Hint In the node.js world, it's common practice to attach the authorized user to the request object. Thus, in our sample code above, we are assuming that request.user contains the user instance and allowed roles. In your app, you will probably make that association in your custom authentication guard (or middleware). Check this chapter for more information on this topic."
Title,warning Warning The logic inside the matchRoles() function can be as simple or sophisticated as needed. The main point of this example is to show how guards fit into the request/response cycle.
Title,
Title,Refer to the Reflection and metadata section of the Execution context chapter for more details on utilizing Reflector in a context-sensitive way.
Title,"When a user with insufficient privileges requests an endpoint, Nest automatically returns the following response:"
Title,typescript
Title,{
Title,"""statusCode"": 403,"
Title,"""message"": ""Forbidden resource"","
Title,"""error"": ""Forbidden"""
Title,}
Title,"Note that behind the scenes, when a guard returns false, the framework throws a ForbiddenException. If you want to return a different error response, you should throw your own specific exception. For example:"
Title,typescript
Title,throw new UnauthorizedException();
Title,Any exception thrown by a guard will be handled by the exceptions layer (global exceptions filter and any exceptions filters that are applied to the current context).
Title,
Title,"info Hint If you are looking for a real-world example on how to implement authorization, check this chapter."
Title,
Title,
Title,Interceptors
Title,An interceptor is a class annotated with the @Injectable() decorator and implements the NestInterceptor interface.
Title,
Title,Interceptors have a set of useful capabilities which are inspired by the Aspect Oriented Programming (AOP) technique. They make it possible to:
Title,
Title,bind extra logic before / after method execution
Title,transform the result returned from a function
Title,transform the exception thrown from a function
Title,extend the basic function behavior
Title,"completely override a function depending on specific conditions (e.g., for caching purposes)"
Title,
Title,Basics
Title,"Each interceptor implements the intercept() method, which takes two arguments. The first one is the ExecutionContext instance (exactly the same object as for guards). The ExecutionContext inherits from ArgumentsHost. We saw ArgumentsHost before in the exception filters chapter. There, we saw that it's a wrapper around arguments that have been passed to the original handler, and contains different arguments arrays based on the type of the application. You can refer back to the exception filters for more on this topic."
Title,Execution context
Title,"By extending ArgumentsHost, ExecutionContext also adds several new helper methods that provide additional details about the current execution process. These details can be helpful in building more generic interceptors that can work across a broad set of controllers, methods, and execution contexts. Learn more about ExecutionContext here."
Title,Call handler
Title,"The second argument is a CallHandler. The CallHandler interface implements the handle() method, which you can use to invoke the route handler method at some point in your interceptor. If you don't call the handle() method in your implementation of the intercept() method, the route handler method won't be executed at all."
Title,"This approach means that the intercept() method effectively wraps the request/response stream. As a result, you may implement custom logic both before and after the execution of the final route handler. It's clear that you can write code in your intercept() method that executes before calling handle(), but how do you affect what happens afterward? Because the handle() method returns an Observable, we can use powerful RxJS operators to further manipulate the response. Using Aspect Oriented Programming terminology, the invocation of the route handler (i.e., calling handle()) is called a Pointcut, indicating that it's the point at which our additional logic is inserted."
Title,"Consider, for example, an incoming POST /cats request. This request is destined for the create() handler defined inside the CatsController. If an interceptor which does not call the handle() method is called anywhere along the way, the create() method won't be executed. Once handle() is called (and its Observable has been returned), the create() handler will be triggered. And once the response stream is received via the Observable, additional operations can be performed on the stream, and a final result returned to the caller."
Title,
Title,Aspect interception
Title,"The first use case we'll look at is to use an interceptor to log user interaction (e.g., storing user calls, asynchronously dispatching events or calculating a timestamp). We show a simple LoggingInterceptor below:"
Title,```typescript
Title,@@filename(logging.interceptor)
Title,"import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';"
Title,import { Observable } from 'rxjs';
Title,import { tap } from 'rxjs/operators';
Title,@Injectable()
Title,export class LoggingInterceptor implements NestInterceptor {
Title,"intercept(context: ExecutionContext, next: CallHandler): Observable {"
Title,console.log('Before...');
Title,const now = Date.now();
Title,return next
Title,.handle()
Title,.pipe(
Title,"tap(() => console.log(`After... ${Date.now() - now}ms`)),"
Title,);
Title,
Title,}
Title,}
Title,@@switch
Title,import { Injectable } from '@nestjs/common';
Title,import { Observable } from 'rxjs';
Title,import { tap } from 'rxjs/operators';
Title,@Injectable()
Title,export class LoggingInterceptor {
Title,"intercept(context, next) {"
Title,console.log('Before...');
Title,const now = Date.now();
Title,return next
Title,.handle()
Title,.pipe(
Title,"tap(() => console.log(`After... ${Date.now() - now}ms`)),"
Title,);
Title,
Title,}
Title,}
Title,```
Title,
Title,"info Hint The NestInterceptor<T, R> is a generic interface in which T indicates the type of an Observable<T> (supporting the response stream), and R is the type of the value wrapped by Observable<R>."
Title,"warning Notice Interceptors, like controllers, providers, guards, and so on, can inject dependencies through their constructor."
Title,
Title,"Since handle() returns an RxJS Observable, we have a wide choice of operators we can use to manipulate the stream. In the example above, we used the tap() operator, which invokes our anonymous logging function upon graceful or exceptional termination of the observable stream, but doesn't otherwise interfere with the response cycle."
Title,Binding interceptors
Title,"In order to set up the interceptor, we use the @UseInterceptors() decorator imported from the @nestjs/common package. Like pipes and guards, interceptors can be controller-scoped, method-scoped, or global-scoped."
Title,typescript
Title,@@filename(cats.controller)
Title,@UseInterceptors(LoggingInterceptor)
Title,export class CatsController {}
Title,
Title,info Hint The @UseInterceptors() decorator is imported from the @nestjs/common package.
Title,
Title,"Using the above construction, each route handler defined in CatsController will use LoggingInterceptor. When someone calls the GET /cats endpoint, you'll see the following output in your standard output:"
Title,typescript
Title,Before...
Title,After... 1ms
Title,"Note that we passed the LoggingInterceptor class (instead of an instance), leaving responsibility for instantiation to the framework and enabling dependency injection. As with pipes, guards, and exception filters, we can also pass an in-place instance:"
Title,typescript
Title,@@filename(cats.controller)
Title,@UseInterceptors(new LoggingInterceptor())
Title,export class CatsController {}
Title,"As mentioned, the construction above attaches the interceptor to every handler declared by this controller. If we want to restrict the interceptor's scope to a single method, we simply apply the decorator at the method level."
Title,"In order to set up a global interceptor, we use the useGlobalInterceptors() method of the Nest application instance:"
Title,typescript
Title,const app = await NestFactory.create(AppModule);
Title,app.useGlobalInterceptors(new LoggingInterceptor());
Title,"Global interceptors are used across the whole application, for every controller and every route handler. In terms of dependency injection, global interceptors registered from outside of any module (with useGlobalInterceptors(), as in the example above) cannot inject dependencies since this is done outside the context of any module. In order to solve this issue, you can set up an interceptor directly from any module using the following construction:"
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { APP_INTERCEPTOR } from '@nestjs/core';
Title,@Module({
Title,providers: [
Title,{
Title,"provide: APP_INTERCEPTOR,"
Title,"useClass: LoggingInterceptor,"
Title,"},"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,
Title,"info Hint When using this approach to perform dependency injection for the interceptor, note that regardless of the"
Title,"module where this construction is employed, the interceptor is, in fact, global. Where should this be done? Choose the module"
Title,"where the interceptor (LoggingInterceptor in the example above) is defined. Also, useClass is not the only way of dealing with custom provider registration. Learn more here."
Title,
Title,Response mapping
Title,"We already know that handle() returns an Observable. The stream contains the value returned from the route handler, and thus we can easily mutate it using RxJS's map() operator."
Title,
Title,warning Warning The response mapping feature doesn't work with the library-specific response strategy (using the @Res() object directly is forbidden).
Title,
Title,"Let's create the TransformInterceptor, which will modify each response in a trivial way to demonstrate the process. It will use RxJS's map() operator to assign the response object to the data property of a newly created object, returning the new object to the client."
Title,```typescript
Title,@@filename(transform.interceptor)
Title,"import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';"
Title,import { Observable } from 'rxjs';
Title,import { map } from 'rxjs/operators';
Title,export interface Response {
Title,data: T;
Title,}
Title,@Injectable()
Title,export class TransformInterceptor implements NestInterceptor> {
Title,"intercept(context: ExecutionContext, next: CallHandler): Observable> {"
Title,return next.handle().pipe(map(data => ({ data })));
Title,}
Title,}
Title,@@switch
Title,import { Injectable } from '@nestjs/common';
Title,import { map } from 'rxjs/operators';
Title,@Injectable()
Title,export class TransformInterceptor {
Title,"intercept(context, next) {"
Title,return next.handle().pipe(map(data => ({ data })));
Title,}
Title,}
Title,```
Title,
Title,info Hint Nest interceptors work with both synchronous and asynchronous intercept() methods. You can simply switch the method to async if necessary.
Title,
Title,"With the above construction, when someone calls the GET /cats endpoint, the response would look like the following (assuming that route handler returns an empty array []):"
Title,json
Title,{
Title,"""data"": []"
Title,}
Title,Interceptors have great value in creating re-usable solutions to requirements that occur across an entire application.
Title,"For example, imagine we need to transform each occurrence of a null value to an empty string ''. We can do it using one line of code and bind the interceptor globally so that it will automatically be used by each registered handler."
Title,```typescript
Title,@@filename()
Title,"import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';"
Title,import { Observable } from 'rxjs';
Title,import { map } from 'rxjs/operators';
Title,@Injectable()
Title,export class ExcludeNullInterceptor implements NestInterceptor {
Title,"intercept(context: ExecutionContext, next: CallHandler): Observable {"
Title,return next
Title,.handle()
Title,.pipe(map(value => value === null ? '' : value ));
Title,}
Title,}
Title,@@switch
Title,import { Injectable } from '@nestjs/common';
Title,import { map } from 'rxjs/operators';
Title,@Injectable()
Title,export class ExcludeNullInterceptor {
Title,"intercept(context, next) {"
Title,return next
Title,.handle()
Title,.pipe(map(value => value === null ? '' : value ));
Title,}
Title,}
Title,```
Title,Exception mapping
Title,Another interesting use-case is to take advantage of RxJS's catchError() operator to override thrown exceptions:
Title,```typescript
Title,@@filename(errors.interceptor)
Title,import {
Title,"Injectable,"
Title,"NestInterceptor,"
Title,"ExecutionContext,"
Title,"BadGatewayException,"
Title,"CallHandler,"
Title,} from '@nestjs/common';
Title,"import { Observable, throwError } from 'rxjs';"
Title,import { catchError } from 'rxjs/operators';
Title,@Injectable()
Title,export class ErrorsInterceptor implements NestInterceptor {
Title,"intercept(context: ExecutionContext, next: CallHandler): Observable {"
Title,return next
Title,.handle()
Title,.pipe(
Title,"catchError(err => throwError(() => new BadGatewayException())),"
Title,);
Title,}
Title,}
Title,@@switch
Title,"import { Injectable, BadGatewayException } from '@nestjs/common';"
Title,import { throwError } from 'rxjs';
Title,import { catchError } from 'rxjs/operators';
Title,@Injectable()
Title,export class ErrorsInterceptor {
Title,"intercept(context, next) {"
Title,return next
Title,.handle()
Title,.pipe(
Title,"catchError(err => throwError(() => new BadGatewayException())),"
Title,);
Title,}
Title,}
Title,```
Title,Stream overriding
Title,"There are several reasons why we may sometimes want to completely prevent calling the handler and return a different value instead. An obvious example is to implement a cache to improve response time. Let's take a look at a simple cache interceptor that returns its response from a cache. In a realistic example, we'd want to consider other factors like TTL, cache invalidation, cache size, etc., but that's beyond the scope of this discussion. Here we'll provide a basic example that demonstrates the main concept."
Title,```typescript
Title,@@filename(cache.interceptor)
Title,"import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';"
Title,"import { Observable, of } from 'rxjs';"
Title,@Injectable()
Title,export class CacheInterceptor implements NestInterceptor {
Title,"intercept(context: ExecutionContext, next: CallHandler): Observable {"
Title,const isCached = true;
Title,if (isCached) {
Title,return of([]);
Title,}
Title,return next.handle();
Title,}
Title,}
Title,@@switch
Title,import { Injectable } from '@nestjs/common';
Title,import { of } from 'rxjs';
Title,@Injectable()
Title,export class CacheInterceptor {
Title,"intercept(context, next) {"
Title,const isCached = true;
Title,if (isCached) {
Title,return of([]);
Title,}
Title,return next.handle();
Title,}
Title,}
Title,```
Title,"Our CacheInterceptor has a hardcoded isCached variable and a hardcoded response [] as well. The key point to note is that we return a new stream here, created by the RxJS of() operator, therefore the route handler won't be called at all. When someone calls an endpoint that makes use of CacheInterceptor, the response (a hardcoded, empty array) will be returned immediately. In order to create a generic solution, you can take advantage of Reflector and create a custom decorator. The Reflector is well described in the guards chapter."
Title,More operators
Title,"The possibility of manipulating the stream using RxJS operators gives us many capabilities. Let's consider another common use case. Imagine you would like to handle timeouts on route requests. When your endpoint doesn't return anything after a period of time, you want to terminate with an error response. The following construction enables this:"
Title,```typescript
Title,@@filename(timeout.interceptor)
Title,"import { Injectable, NestInterceptor, ExecutionContext, CallHandler, RequestTimeoutException } from '@nestjs/common';"
Title,"import { Observable, throwError, TimeoutError } from 'rxjs';"
Title,"import { catchError, timeout } from 'rxjs/operators';"
Title,@Injectable()
Title,export class TimeoutInterceptor implements NestInterceptor {
Title,"intercept(context: ExecutionContext, next: CallHandler): Observable {"
Title,return next.handle().pipe(
Title,"timeout(5000),"
Title,catchError(err => {
Title,if (err instanceof TimeoutError) {
Title,return throwError(() => new RequestTimeoutException());
Title,}
Title,return throwError(() => err);
Title,"}),"
Title,);
Title,};
Title,};
Title,@@switch
Title,"import { Injectable, RequestTimeoutException } from '@nestjs/common';"
Title,"import { Observable, throwError, TimeoutError } from 'rxjs';"
Title,"import { catchError, timeout } from 'rxjs/operators';"
Title,@Injectable()
Title,export class TimeoutInterceptor {
Title,"intercept(context, next) {"
Title,return next.handle().pipe(
Title,"timeout(5000),"
Title,catchError(err => {
Title,if (err instanceof TimeoutError) {
Title,return throwError(() => new RequestTimeoutException());
Title,}
Title,return throwError(() => err);
Title,"}),"
Title,);
Title,};
Title,};
Title,```
Title,"After 5 seconds, request processing will be canceled. You can also add custom logic before throwing RequestTimeoutException (e.g. release resources)."
Title,
Title,Introduction
Title,"Nest (NestJS) is a framework for building efficient, scalable Node.js server-side applications. It uses progressive JavaScript, is built with and fully supports TypeScript (yet still enables developers to code in pure JavaScript) and combines elements of OOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming)."
Title,"Under the hood, Nest makes use of robust HTTP Server frameworks like Express (the default) and optionally can be configured to use Fastify as well!"
Title,"Nest provides a level of abstraction above these common Node.js frameworks (Express/Fastify), but also exposes their APIs directly to the developer. This gives developers the freedom to use the myriad of third-party modules which are available for the underlying platform."
Title,Philosophy
Title,"In recent years, thanks to Node.js, JavaScript has become the “lingua franca” of the web for both front and backend applications. This has given rise to awesome projects like Angular, React and Vue, which improve developer productivity and enable the creation of fast, testable, and extensible frontend applications. However, while plenty of superb libraries, helpers, and tools exist for Node (and server-side JavaScript), none of them effectively solve the main problem of - Architecture."
Title,"Nest provides an out-of-the-box application architecture which allows developers and teams to create highly testable, scalable, loosely coupled, and easily maintainable applications. The architecture is heavily inspired by Angular."
Title,Installation
Title,"To get started, you can either scaffold the project with the Nest CLI, or clone a starter project (both will produce the same outcome)."
Title,"To scaffold the project with the Nest CLI, run the following commands. This will create a new project directory, and populate the directory with the initial core Nest files and supporting modules, creating a conventional base structure for your project. Creating a new project with the Nest CLI is recommended for first-time users. We'll continue with this approach in First Steps."
Title,bash
Title,$ npm i -g @nestjs/cli
Title,$ nest new project-name
Title,
Title,"info Hint To create a new TypeScript project with stricter feature set, pass the --strict flag to the nest new command."
Title,
Title,Alternatives
Title,"Alternatively, to install the TypeScript starter project with Git:"
Title,bash
Title,$ git clone https://github.com/nestjs/typescript-starter.git project
Title,$ cd project
Title,$ npm install
Title,$ npm run start
Title,
Title,"info Hint If you'd like to clone the repository without the git history, you can use degit."
Title,
Title,Open your browser and navigate to http://localhost:3000/.
Title,"To install the JavaScript flavor of the starter project, use javascript-starter.git in the command sequence above."
Title,"You can also start a new project from scratch by installing the core and supporting packages. Keep in mind that you'll need to set up the project boilerplate files on your own. At a minimum, you'll need these dependencies: @nestjs/core, @nestjs/common, rxjs, and reflect-metadata. Check out this short article on how to create a complete project: 5 steps to create a bare minimum NestJS app from scratch!."
Title,
Title,Overview
Title,"In addition to traditional (sometimes called monolithic) application architectures, Nest natively supports the microservice architectural style of development. Most of the concepts discussed elsewhere in this documentation, such as dependency injection, decorators, exception filters, pipes, guards and interceptors, apply equally to microservices. Wherever possible, Nest abstracts implementation details so that the same components can run across HTTP-based platforms, WebSockets, and Microservices. This section covers the aspects of Nest that are specific to microservices."
Title,"In Nest, a microservice is fundamentally an application that uses a different transport layer than HTTP."
Title,
Title,"Nest supports several built-in transport layer implementations, called transporters, which are responsible for transmitting messages between different microservice instances. Most transporters natively support both request-response and event-based message styles. Nest abstracts the implementation details of each transporter behind a canonical interface for both request-response and event-based messaging. This makes it easy to switch from one transport layer to another -- for example to leverage the specific reliability or performance features of a particular transport layer -- without impacting your application code."
Title,Installation
Title,"To start building microservices, first install the required package:"
Title,bash
Title,$ npm i --save @nestjs/microservices
Title,Getting started
Title,"To instantiate a microservice, use the createMicroservice() method of the NestFactory class:"
Title,```typescript
Title,@@filename(main)
Title,import { NestFactory } from '@nestjs/core';
Title,"import { Transport, MicroserviceOptions } from '@nestjs/microservices';"
Title,import { AppModule } from './app.module';
Title,async function bootstrap() {
Title,const app = await NestFactory.createMicroservice(
Title,"AppModule,"
Title,{
Title,"transport: Transport.TCP,"
Title,"},"
Title,);
Title,await app.listen();
Title,}
Title,bootstrap();
Title,@@switch
Title,import { NestFactory } from '@nestjs/core';
Title,import { Transport } from '@nestjs/microservices';
Title,import { AppModule } from './app.module';
Title,async function bootstrap() {
Title,"const app = await NestFactory.createMicroservice(AppModule, {"
Title,"transport: Transport.TCP,"
Title,});
Title,await app.listen();
Title,}
Title,bootstrap();
Title,```
Title,
Title,info Hint Microservices use the TCP transport layer by default.
Title,
Title,The second argument of the createMicroservice() method is an options object. This object may consist of two members:
Title,
Title,
Title,transport
Title,"Specifies the transporter (for example, Transport.NATS)"
Title,
Title,
Title,options
Title,A transporter-specific options object that determines transporter behavior
Title,
Title,
Title,
Title,The options object is specific to the chosen transporter. The TCP transporter exposes
Title,"the properties described below.  For other transporters (e.g, Redis, MQTT, etc.), see the relevant chapter for a description of the available options."
Title,
Title,
Title,
Title,host
Title,Connection hostname
Title,
Title,
Title,port
Title,Connection port
Title,
Title,
Title,retryAttempts
Title,Number of times to retry message (default: 0)
Title,
Title,
Title,retryDelay
Title,Delay between message retry attempts (ms) (default: 0)
Title,
Title,
Title,serializer
Title,Custom serializer for outcoming messages
Title,
Title,
Title,deserializer
Title,Custom deserializer for incoming messages
Title,
Title,
Title,socketClass
Title,A custom Socket that extends TcpSocket (default: JsonSocket)
Title,
Title,
Title,tlsOptions
Title,Options to configure the tls protocol
Title,
Title,
Title,Patterns
Title,"Microservices recognize both messages and events by patterns. A pattern is a plain value, for example, a literal object or a string. Patterns are automatically serialized and sent over the network along with the data portion of a message. In this way, message senders and consumers can coordinate which requests are consumed by which handlers."
Title,Request-response
Title,"The request-response message style is useful when you need to exchange messages between various external services. With this paradigm, you can be certain that the service has actually received the message (without the need to manually implement a message ACK protocol). However, the request-response paradigm is not always the best choice. For example, streaming transporters that use log-based persistence, such as Kafka or NATS streaming, are optimized for solving a different range of issues, more aligned with an event messaging paradigm (see event-based messaging below for more details)."
Title,"To enable the request-response message type, Nest creates two logical channels - one is responsible for transferring the data while the other waits for incoming responses. For some underlying transports, such as NATS, this dual-channel support is provided out-of-the-box. For others, Nest compensates by manually creating separate channels. There can be overhead for this, so if you do not require a request-response message style, you should consider using the event-based method."
Title,"To create a message handler based on the request-response paradigm use the @MessagePattern() decorator, which is imported from the @nestjs/microservices package. This decorator should be used only within the controller classes since they are the entry points for your application. Using them inside providers won't have any effect as they are simply ignored by Nest runtime."
Title,```typescript
Title,@@filename(math.controller)
Title,import { Controller } from '@nestjs/common';
Title,import { MessagePattern } from '@nestjs/microservices';
Title,@Controller()
Title,export class MathController {
Title,@MessagePattern({ cmd: 'sum' })
Title,accumulate(data: number[]): number {
Title,"return (data || []).reduce((a, b) => a + b);"
Title,}
Title,}
Title,@@switch
Title,import { Controller } from '@nestjs/common';
Title,import { MessagePattern } from '@nestjs/microservices';
Title,@Controller()
Title,export class MathController {
Title,@MessagePattern({ cmd: 'sum' })
Title,accumulate(data) {
Title,"return (data || []).reduce((a, b) => a + b);"
Title,}
Title,}
Title,```
Title,"In the above code, the accumulate() message handler listens for messages that fulfill the {{ '{' }} cmd: 'sum' {{ '}' }} message pattern. The message handler takes a single argument, the data passed from the client. In this case, the data is an array of numbers which are to be accumulated."
Title,Asynchronous responses
Title,"Message handlers are able to respond either synchronously or asynchronously. Hence, async methods are supported."
Title,typescript
Title,@@filename()
Title,@MessagePattern({ cmd: 'sum' })
Title,async accumulate(data: number[]): Promise<number> {
Title,"return (data || []).reduce((a, b) => a + b);"
Title,}
Title,@@switch
Title,@MessagePattern({ cmd: 'sum' })
Title,async accumulate(data) {
Title,"return (data || []).reduce((a, b) => a + b);"
Title,}
Title,"A message handler is also able to return an Observable, in which case the result values will be emitted until the stream is completed."
Title,typescript
Title,@@filename()
Title,@MessagePattern({ cmd: 'sum' })
Title,accumulate(data: number[]): Observable<number> {
Title,"return from([1, 2, 3]);"
Title,}
Title,@@switch
Title,@MessagePattern({ cmd: 'sum' })
Title,accumulate(data: number[]): Observable<number> {
Title,"return from([1, 2, 3]);"
Title,}
Title,"In the example above, the message handler will respond 3 times (with each item from the array)."
Title,Event-based
Title,"While the request-response method is ideal for exchanging messages between services, it is less suitable when your message style is event-based - when you just want to publish events without waiting for a response. In that case, you do not want the overhead required by request-response for maintaining two channels."
Title,Suppose you would like to simply notify another service that a certain condition has occurred in this part of the system. This is the ideal use case for the event-based message style.
Title,"To create an event handler, we use the @EventPattern() decorator, which is imported from the @nestjs/microservices package."
Title,typescript
Title,@@filename()
Title,@EventPattern('user_created')
Title,"async handleUserCreated(data: Record<string, unknown>) {"
Title,// business logic
Title,}
Title,@@switch
Title,@EventPattern('user_created')
Title,async handleUserCreated(data) {
Title,// business logic
Title,}
Title,
Title,info Hint You can register multiple event handlers for a single event pattern and all of them will be automatically triggered in parallel.
Title,
Title,"The handleUserCreated() event handler listens for the 'user_created' event. The event handler takes a single argument, the data passed from the client (in this case, an event payload which has been sent over the network)."
Title,
Title,Decorators
Title,"In more sophisticated scenarios, you may want to access more information about the incoming request. For example, in the case of NATS with wildcard subscriptions, you may want to get the original subject that the producer has sent the message to. Likewise, in Kafka you may want to access the message headers. In order to accomplish that, you can use built-in decorators as follows:"
Title,typescript
Title,@@filename()
Title,@MessagePattern('time.us.*')
Title,"getDate(@Payload() data: number[], @Ctx() context: NatsContext) {"
Title,"console.log(`Subject: ${context.getSubject()}`); // e.g. ""time.us.east"""
Title,return new Date().toLocaleTimeString(...);
Title,}
Title,@@switch
Title,"@Bind(Payload(), Ctx())"
Title,@MessagePattern('time.us.*')
Title,"getDate(data, context) {"
Title,"console.log(`Subject: ${context.getSubject()}`); // e.g. ""time.us.east"""
Title,return new Date().toLocaleTimeString(...);
Title,}
Title,
Title,"info Hint @Payload(), @Ctx() and NatsContext are imported from @nestjs/microservices."
Title,"info Hint You can also pass in a property key to the @Payload() decorator to extract a specific property from the incoming payload object, for example, @Payload('id')."
Title,
Title,Client
Title,"A client Nest application can exchange messages or publish events to a Nest microservice using the ClientProxy class. This class defines several methods, such as send() (for request-response messaging) and emit() (for event-driven messaging) that let you communicate with a remote microservice. Obtain an instance of this class in one of the following ways."
Title,"One technique is to import the ClientsModule, which exposes the static register() method. This method takes an argument which is an array of objects representing microservice transporters. Each such object has a name property, an optional transport property (default is Transport.TCP), and an optional transporter-specific options property."
Title,"The name property serves as an injection token that can be used to inject an instance of a ClientProxy where needed. The value of the name property, as an injection token, can be an arbitrary string or JavaScript symbol, as described here."
Title,The options property is an object that contains the same properties we saw in the createMicroservice() method earlier.
Title,typescript
Title,@Module({
Title,imports: [
Title,ClientsModule.register([
Title,"{ name: 'MATH_SERVICE', transport: Transport.TCP },"
Title,"]),"
Title,"],"
Title,})
Title,"Alternatively, you can use the registerAsync() method if you need to pass in configuration or perform any other asynchronous processes."
Title,typescript
Title,@Module({
Title,imports: [
Title,ClientsModule.registerAsync([
Title,{
Title,"imports: [ConfigModule],"
Title,"name: 'MATH_SERVICE',"
Title,useFactory: async (configService: ConfigService) => ({
Title,"transport: Transport.TCP,"
Title,options: {
Title,"url: configService.get('URL'),"
Title,"},"
Title,"}),"
Title,"inject: [ConfigService],"
Title,"},"
Title,"]),"
Title,"],"
Title,})
Title,"Once the module has been imported, you can inject an instance of the ClientProxy configured with the specified options for the 'MATH_SERVICE' transporter using the @Inject() decorator."
Title,typescript
Title,constructor(
Title,"@Inject('MATH_SERVICE') private client: ClientProxy,"
Title,) {}
Title,
Title,info Hint The ClientsModule and ClientProxy classes are imported from the @nestjs/microservices package.
Title,
Title,"At times we may need to fetch the transporter configuration from another service (say a ConfigService), rather than hard-coding it in our client application. To do this, we can register a custom provider using the ClientProxyFactory class. This class has a static create() method, which accepts a transporter options object, and returns a customized ClientProxy instance."
Title,typescript
Title,@Module({
Title,providers: [
Title,{
Title,"provide: 'MATH_SERVICE',"
Title,useFactory: (configService: ConfigService) => {
Title,const mathSvcOptions = configService.getMathSvcOptions();
Title,return ClientProxyFactory.create(mathSvcOptions);
Title,"},"
Title,"inject: [ConfigService],"
Title,}
Title,]
Title,...
Title,})
Title,
Title,info Hint The ClientProxyFactory is imported from the @nestjs/microservices package.
Title,
Title,Another option is to use the @Client() property decorator.
Title,typescript
Title,@Client({ transport: Transport.TCP })
Title,client: ClientProxy;
Title,
Title,info Hint The @Client() decorator is imported from the @nestjs/microservices package.
Title,
Title,"Using the @Client() decorator is not the preferred technique, as it is harder to test and harder to share a client instance."
Title,"The ClientProxy is lazy. It doesn't initiate a connection immediately. Instead, it will be established before the first microservice call, and then reused across each subsequent call. However, if you want to delay the application bootstrapping process until a connection is established, you can manually initiate a connection using the ClientProxy object's connect() method inside the OnApplicationBootstrap lifecycle hook."
Title,typescript
Title,@@filename()
Title,async onApplicationBootstrap() {
Title,await this.client.connect();
Title,}
Title,"If the connection cannot be created, the connect() method will reject with the corresponding error object."
Title,Sending messages
Title,"The ClientProxy exposes a send() method. This method is intended to call the microservice and returns an Observable with its response. Thus, we can subscribe to the emitted values easily."
Title,typescript
Title,@@filename()
Title,accumulate(): Observable<number> {
Title,const pattern = { cmd: 'sum' };
Title,"const payload = [1, 2, 3];"
Title,"return this.client.send<number>(pattern, payload);"
Title,}
Title,@@switch
Title,accumulate() {
Title,const pattern = { cmd: 'sum' };
Title,"const payload = [1, 2, 3];"
Title,"return this.client.send(pattern, payload);"
Title,}
Title,"The send() method takes two arguments, pattern and payload. The pattern should match one defined in a @MessagePattern() decorator. The payload is a message that we want to transmit to the remote microservice. This method returns a cold Observable, which means that you have to explicitly subscribe to it before the message will be sent."
Title,Publishing events
Title,"To send an event, use the ClientProxy object's emit() method. This method publishes an event to the message broker."
Title,typescript
Title,@@filename()
Title,async publish() {
Title,"this.client.emit<number>('user_created', new UserCreatedEvent());"
Title,}
Title,@@switch
Title,async publish() {
Title,"this.client.emit('user_created', new UserCreatedEvent());"
Title,}
Title,"The emit() method takes two arguments, pattern and payload. The patternshould match one defined in an @EventPattern() decorator. The payload is an event payload that we want to transmit to the remote microservice. This method returns a hot Observable (unlike the cold Observable returned by send()), which means that whether or not you explicitly subscribe to the observable, the proxy will immediately try to deliver the event."
Title,
Title,Scopes
Title,"For people coming from different programming language backgrounds, it might be unexpected to learn that in Nest, almost everything is shared across incoming requests. We have a connection pool to the database, singleton services with global state, etc. Remember that Node.js doesn't follow the request/response Multi-Threaded Stateless Model in which every request is processed by a separate thread. Hence, using singleton instances is fully safe for our applications."
Title,"However, there are edge-cases when request-based lifetime of the handler may be the desired behavior, for instance per-request caching in GraphQL applications, request tracking or multi-tenancy. Learn how to control scopes here."
Title,Request-scoped handlers and providers can inject RequestContext using the @Inject() decorator in combination with CONTEXT token:
Title,```typescript
Title,"import { Injectable, Scope, Inject } from '@nestjs/common';"
Title,"import { CONTEXT, RequestContext } from '@nestjs/microservices';"
Title,@Injectable({ scope: Scope.REQUEST })
Title,export class CatsService {
Title,constructor(@Inject(CONTEXT) private ctx: RequestContext) {}
Title,}
Title,```
Title,"This provides access to the RequestContext object, which has two properties:"
Title,typescript
Title,export interface RequestContext<T = any> {
Title,"pattern: string | Record<string, any>;"
Title,data: T;
Title,}
Title,The data property is the message payload sent by the message producer. The pattern property is the pattern used to identify an appropriate handler to handle the incoming message.
Title,Handling timeouts
Title,"In distributed systems, sometimes microservices might be down or not available. To avoid infinitely long waiting, you can use Timeouts. A timeout is an incredibly useful pattern when communicating with other services. To apply timeouts to your microservice calls, you can use the RxJS timeout operator. If the microservice does not respond to the request within a certain time, an exception is thrown, which can be caught and handled appropriately."
Title,To solve this problem you have to use rxjs package. Just use the timeout operator in the pipe:
Title,typescript
Title,@@filename()
Title,this.client
Title,".send<TResult, TInput>(pattern, data)"
Title,.pipe(timeout(5000));
Title,@@switch
Title,this.client
Title,".send(pattern, data)"
Title,.pipe(timeout(5000));
Title,
Title,info Hint The timeout operator is imported from the rxjs/operators package.
Title,
Title,"After 5 seconds, if the microservice isn't responding, it will throw an error."
Title,TLS support
Title,"When communicating outside of a private network, it’s important to encrypt traffic to ensure security. In NestJS, this can be achieved with TLS over TCP using Node's built-in TLS module. Nest provides built-in support for TLS in its TCP transport, allowing us to encrypt communication between microservices or clients."
Title,"To enable TLS for a TCP server, you'll need both a private key and a certificate in PEM format. These are added to the server's options by setting the tlsOptions and specifying the key and cert files, as shown below:"
Title,```typescript
Title,import * as fs from 'fs';
Title,import { NestFactory } from '@nestjs/core';
Title,import { AppModule } from './app.module';
Title,"import { MicroserviceOptions, Transport } from '@nestjs/microservices';"
Title,async function bootstrap() {
Title,"const key = fs.readFileSync('', 'utf8').toString();"
Title,"const cert = fs.readFileSync('', 'utf8').toString();"
Title,const app = await NestFactory.createMicroservice(
Title,"AppModule,"
Title,{
Title,"transport: Transport.TCP,"
Title,options: {
Title,tlsOptions: {
Title,"key,"
Title,"cert,"
Title,"},"
Title,"},"
Title,"},"
Title,);
Title,await app.listen();
Title,}
Title,bootstrap();
Title,```
Title,"For a client to communicate securely over TLS, we also define the tlsOptions object but this time with the CA certificate. This is the certificate of the authority that signed the server's certificate. This ensures that the client trusts the server's certificate and can establish a secure connection."
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,"import { ClientsModule, Transport } from '@nestjs/microservices';"
Title,@Module({
Title,imports: [
Title,ClientsModule.register([
Title,{
Title,"name: 'MATH_SERVICE',"
Title,"transport: Transport.TCP,"
Title,options: {
Title,tlsOptions: {
Title,"ca: [fs.readFileSync('', 'utf-8').toString()],"
Title,"},"
Title,"},"
Title,"},"
Title,"]),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,You can also pass an array of CAs if your setup involves multiple trusted authorities.
Title,"Once everything is set up, you can inject the ClientProxy as usual using the @Inject() decorator to use the client in your services. This ensures encrypted communication across your NestJS microservices, with Node's TLS module handling the encryption details."
Title,"For more information, refer to Node’s TLS documentation."
Title,
Title,Custom transporters
Title,"Nest provides a variety of transporters out-of-the-box, as well as an API allowing developers to build new custom transport strategies."
Title,Transporters enable you to connect components over a network using a pluggable communications layer and a very simple application-level message protocol (read full article).
Title,
Title,"info Hint Building a microservice with Nest does not necessarily mean you must use the @nestjs/microservices package. For example, if you want to communicate with external services (let's say other microservices written in different languages), you may not need all the features provided by @nestjs/microservice library."
Title,"In fact, if you don't need decorators (@EventPattern or @MessagePattern) that let you declaratively define subscribers, running a Standalone Application and manually maintaining connection/subscribing to channels should be enough for most use-cases and will provide you with more flexibility."
Title,
Title,"With a custom transporter, you can integrate any messaging system/protocol (including Google Cloud Pub/Sub, Amazon Kinesis, and others) or extend the existing one, adding extra features on top (for example, QoS for MQTT)."
Title,
Title,"info Hint To better understand how Nest microservices work and how you can extend the capabilities of existing transporters, we recommend reading the NestJS Microservices in Action and Advanced NestJS Microservices article series."
Title,
Title,Creating a strategy
Title,"First, let's define a class representing our custom transporter."
Title,```typescript
Title,"import { CustomTransportStrategy, Server } from '@nestjs/microservices';"
Title,class GoogleCloudPubSubServer
Title,extends Server
Title,implements CustomTransportStrategy {
Title,/*
Title,"* This method is triggered when you run ""app.listen()""."
Title,/
Title,listen(callback: () => void) {
Title,callback();
Title,}
Title,/*
Title,* This method is triggered on application shutdown.
Title,/
Title,close() {}
Title,}
Title,```
Title,
Title,"warning Warning Please, note we won't be implementing a fully-featured Google Cloud Pub/Sub server in this chapter as this would require diving into transporter specific technical details."
Title,
Title,"In our example above, we declared the GoogleCloudPubSubServer class and provided listen() and close() methods enforced by the CustomTransportStrategy interface."
Title,"Also, our class extends the Server class imported from the @nestjs/microservices package that provides a few useful methods, for example, methods used by Nest runtime to register message handlers. Alternatively, in case you want to extend the capabilities of an existing transport strategy, you could extend the corresponding server class, for example, ServerRedis."
Title,"Conventionally, we added the ""Server"" suffix to our class as it will be responsible for subscribing to messages/events (and responding to them, if necessary)."
Title,"With this in place, we can now use our custom strategy instead of using a built-in transporter, as follows:"
Title,typescript
Title,const app = await NestFactory.createMicroservice<MicroserviceOptions>(
Title,"AppModule,"
Title,{
Title,"strategy: new GoogleCloudPubSubServer(),"
Title,"},"
Title,);
Title,"Basically, instead of passing the normal transporter options object with transport and options properties, we pass a single property, strategy, whose value is an instance of our custom transporter class."
Title,"Back to our GoogleCloudPubSubServer class, in a real-world application, we would be establishing a connection to our message broker/external service and registering subscribers/listening to specific channels in listen() method (and then removing subscriptions & closing the connection in the close() teardown method),"
Title,"but since this requires a good understanding of how Nest microservices communicate with each other, we recommend reading this article series."
Title,"In this chapter instead, we'll focus on the capabilities the Server class provides and how you can leverage them to build custom strategies."
Title,"For example, let's say that somewhere in our application, the following message handler is defined:"
Title,typescript
Title,@MessagePattern('echo')
Title,echo(@Payload() data: object) {
Title,return data;
Title,}
Title,"This message handler will be automatically registered by Nest runtime. With Server class, you can see what message patterns have been registered and also, access and execute the actual methods that were assigned to them."
Title,"To test this out, let's add a simple console.log inside listen() method before callback function is called:"
Title,typescript
Title,listen(callback: () => void) {
Title,console.log(this.messageHandlers);
Title,callback();
Title,}
Title,"After your application restarts, you'll see the following log in your terminal:"
Title,typescript
Title,Map { 'echo' => [AsyncFunction] { isEventHandler: false } }
Title,
Title,"info Hint If we used the @EventPattern decorator, you would see the same output, but with the isEventHandler property set to true."
Title,
Title,"As you can see, the messageHandlers property is a Map collection of all message (and event) handlers, in which patterns are being used as keys."
Title,"Now, you can use a key (for example, ""echo"") to receive a reference to the message handler:"
Title,typescript
Title,async listen(callback: () => void) {
Title,const echoHandler = this.messageHandlers.get('echo');
Title,console.log(await echoHandler('Hello world!'));
Title,callback();
Title,}
Title,"Once we execute the echoHandler passing an arbitrary string as an argument (""Hello world!"" here), we should see it in the console:"
Title,json
Title,Hello world!
Title,Which means that our method handler was properly executed.
Title,When using a CustomTransportStrategy with Interceptors the handlers are wrapped into RxJS streams. This means that you need to subscribe to them in order to execute the streams underlying logic (e.g. continue into the controller logic after an interceptor has been executed).
Title,An example of this can be seen below:
Title,typescript
Title,async listen(callback: () => void) {
Title,const echoHandler = this.messageHandlers.get('echo');
Title,const streamOrResult = await echoHandler('Hello World');
Title,if (isObservable(streamOrResult)) {
Title,streamOrResult.subscribe();
Title,}
Title,callback();
Title,}
Title,Client proxy
Title,"As we mentioned in the first section, you don't necessarily need to use the @nestjs/microservices package to create microservices, but if you decide to do so and you need to integrate a custom strategy, you will need to provide a ""client"" class too."
Title,
Title,"info Hint Again, implementing a fully-featured client class compatible with all @nestjs/microservices features (e.g., streaming) requires a good understanding of communication techniques used by the framework. To learn more, check out this article."
Title,
Title,"To communicate with an external service/emit & publish messages (or events) you can either use a library-specific SDK package, or implement a custom client class that extends the ClientProxy, as follows:"
Title,```typescript
Title,"import { ClientProxy, ReadPacket, WritePacket } from '@nestjs/microservices';"
Title,class GoogleCloudPubSubClient extends ClientProxy {
Title,async connect(): Promise {}
Title,async close() {}
Title,async dispatchEvent(packet: ReadPacket): Promise {}
Title,publish(
Title,"packet: ReadPacket,"
Title,"callback: (packet: WritePacket) => void,"
Title,): Function {}
Title,}
Title,```
Title,
Title,"warning Warning Please, note we won't be implementing a fully-featured Google Cloud Pub/Sub client in this chapter as this would require diving into transporter specific technical details."
Title,
Title,"As you can see, ClientProxy class requires us to provide several methods for establishing & closing the connection and publishing messages (publish) and events (dispatchEvent)."
Title,"Note, if you don't need a request-response communication style support, you can leave the publish() method empty. Likewise, if you don't need to support event-based communication, skip the dispatchEvent() method."
Title,"To observe what and when those methods are executed, let's add multiple console.log calls, as follows:"
Title,```typescript
Title,class GoogleCloudPubSubClient extends ClientProxy {
Title,async connect(): Promise {
Title,console.log('connect');
Title,}
Title,async close() {
Title,console.log('close');
Title,}
Title,async dispatchEvent(packet: ReadPacket): Promise {
Title,"return console.log('event to dispatch: ', packet);"
Title,}
Title,publish(
Title,"packet: ReadPacket,"
Title,"callback: (packet: WritePacket) => void,"
Title,): Function {
Title,"console.log('message:', packet);"
Title,"// In a real-world application, the ""callback"" function should be executed"
Title,"// with payload sent back from the responder. Here, we'll simply simulate (5 seconds delay)"
Title,"// that response came through by passing the same ""data"" as we've originally passed in."
Title,"setTimeout(() => callback({ response: packet.data }), 5000);"
Title,
Title,return () => console.log('teardown');
Title,
Title,}
Title,}
Title,```
Title,"With this in place, let's create an instance of GoogleCloudPubSubClient class and run the send() method (which you might have seen in earlier chapters), subscribing to the returned observable stream."
Title,typescript
Title,const googlePubSubClient = new GoogleCloudPubSubClient();
Title,googlePubSubClient
Title,".send('pattern', 'Hello world!')"
Title,.subscribe((response) => console.log(response));
Title,"Now, you should see the following output in your terminal:"
Title,typescript
Title,connect
Title,"message: { pattern: 'pattern', data: 'Hello world!' }"
Title,Hello world! // <-- after 5 seconds
Title,"To test if our ""teardown"" method (which our publish() method returns) is properly executed, let's apply a timeout operator to our stream, setting it to 2 seconds to make sure it throws earlier then our setTimeout calls the callback function."
Title,typescript
Title,const googlePubSubClient = new GoogleCloudPubSubClient();
Title,googlePubSubClient
Title,".send('pattern', 'Hello world!')"
Title,.pipe(timeout(2000))
Title,.subscribe(
Title,"(response) => console.log(response),"
Title,"(error) => console.error(error.message),"
Title,);
Title,
Title,info Hint The timeout operator is imported from the rxjs/operators package.
Title,
Title,"With timeout operator applied, your terminal output should look as follows:"
Title,typescript
Title,connect
Title,"message: { pattern: 'pattern', data: 'Hello world!' }"
Title,teardown // <-- teardown
Title,Timeout has occurred
Title,"To dispatch an event (instead of sending a message), use the emit() method:"
Title,typescript
Title,"googlePubSubClient.emit('event', 'Hello world!');"
Title,And that's what you should see in the console:
Title,typescript
Title,connect
Title,"event to dispatch:  { pattern: 'event', data: 'Hello world!' }"
Title,Message serialization
Title,"If you need to add some custom logic around the serialization of responses on the client side, you can use a custom class that extends the ClientProxy class or one of its child classes. For modifying successful requests you can override the serializeResponse method, and for modifying any errors that go through this client you can override the serializeError method. To make use of this custom class, you can pass the class itself to the ClientsModule.register() method using the customClass property. Below is an example of a custom ClientProxy that serializes each error into an RpcException."
Title,```typescript
Title,@@filename(error-handling.proxy)
Title,"import { ClientTcp, RpcException } from '@nestjs/microservices';"
Title,class ErrorHandlingProxy extends ClientTCP {
Title,serializeError(err: Error) {
Title,return new RpcException(err);
Title,}
Title,}
Title,```
Title,and then use it in the ClientsModule like so:
Title,typescript
Title,@@filename(app.module)
Title,@Module({
Title,imports: [
Title,ClientsModule.register([{
Title,"name: 'CustomProxy',"
Title,"customClass: ErrorHandlingProxy,"
Title,"}]),"
Title,]
Title,})
Title,export class AppModule
Title,
Title,"info hint This is the class itself being passed to customClass, not an instance of the class. Nest will create the instance under the hood for you, and will pass any options given to the options property to the new ClientProxy."
Title,
Title,
Title,Exception filters
Title,"The only difference between the HTTP exception filter layer and the corresponding microservices layer is that instead of throwing HttpException, you should use RpcException."
Title,typescript
Title,throw new RpcException('Invalid credentials.');
Title,
Title,info Hint The RpcException class is imported from the @nestjs/microservices package.
Title,
Title,"With the sample above, Nest will handle the thrown exception and return the error object with the following structure:"
Title,json
Title,{
Title,"""status"": ""error"","
Title,"""message"": ""Invalid credentials."""
Title,}
Title,Filters
Title,"Microservice exception filters behave similarly to HTTP exception filters, with one small difference. The catch() method must return an Observable."
Title,```typescript
Title,@@filename(rpc-exception.filter)
Title,"import { Catch, RpcExceptionFilter, ArgumentsHost } from '@nestjs/common';"
Title,"import { Observable, throwError } from 'rxjs';"
Title,import { RpcException } from '@nestjs/microservices';
Title,@Catch(RpcException)
Title,export class ExceptionFilter implements RpcExceptionFilter {
Title,"catch(exception: RpcException, host: ArgumentsHost): Observable {"
Title,return throwError(() => exception.getError());
Title,}
Title,}
Title,@@switch
Title,import { Catch } from '@nestjs/common';
Title,import { throwError } from 'rxjs';
Title,@Catch(RpcException)
Title,export class ExceptionFilter {
Title,"catch(exception, host) {"
Title,return throwError(() => exception.getError());
Title,}
Title,}
Title,```
Title,
Title,warning Warning Global microservice exception filters aren't enabled by default when using a hybrid application.
Title,
Title,"The following example uses a manually instantiated method-scoped filter. Just as with HTTP based applications, you can also use controller-scoped filters (i.e., prefix the controller class with a @UseFilters() decorator)."
Title,typescript
Title,@@filename()
Title,@UseFilters(new ExceptionFilter())
Title,@MessagePattern({ cmd: 'sum' })
Title,accumulate(data: number[]): number {
Title,"return (data || []).reduce((a, b) => a + b);"
Title,}
Title,@@switch
Title,@UseFilters(new ExceptionFilter())
Title,@MessagePattern({ cmd: 'sum' })
Title,accumulate(data) {
Title,"return (data || []).reduce((a, b) => a + b);"
Title,}
Title,Inheritance
Title,"Typically, you'll create fully customized exception filters crafted to fulfill your application requirements. However, there might be use-cases when you would like to simply extend the core exception filter, and override the behavior based on certain factors."
Title,"In order to delegate exception processing to the base filter, you need to extend BaseExceptionFilter and call the inherited catch() method."
Title,```typescript
Title,@@filename()
Title,"import { Catch, ArgumentsHost } from '@nestjs/common';"
Title,import { BaseRpcExceptionFilter } from '@nestjs/microservices';
Title,@Catch()
Title,export class AllExceptionsFilter extends BaseRpcExceptionFilter {
Title,"catch(exception: any, host: ArgumentsHost) {"
Title,"return super.catch(exception, host);"
Title,}
Title,}
Title,@@switch
Title,import { Catch } from '@nestjs/common';
Title,import { BaseRpcExceptionFilter } from '@nestjs/microservices';
Title,@Catch()
Title,export class AllExceptionsFilter extends BaseRpcExceptionFilter {
Title,"catch(exception, host) {"
Title,"return super.catch(exception, host);"
Title,}
Title,}
Title,```
Title,"The above implementation is just a shell demonstrating the approach. Your implementation of the extended exception filter would include your tailored business logic (e.g., handling various conditions)."
Title,
Title,gRPC
Title,"gRPC is a modern, open source, high performance RPC framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking and authentication."
Title,"Like many RPC systems, gRPC is based on the concept of defining a service in terms of functions (methods) that can be called remotely. For each method, you define the parameters and return types. Services, parameters, and return types are defined in .proto files using Google's open source language-neutral protocol buffers mechanism."
Title,"With the gRPC transporter, Nest uses .proto files to dynamically bind clients and servers to make it easy to implement remote procedure calls, automatically serializing and deserializing structured data."
Title,Installation
Title,"To start building gRPC-based microservices, first install the required packages:"
Title,bash
Title,$ npm i --save @grpc/grpc-js @grpc/proto-loader
Title,Overview
Title,"Like other Nest microservices transport layer implementations, you select the gRPC transporter mechanism using the transport property of the options object passed to the createMicroservice() method. In the following example, we'll set up a hero service. The options property provides metadata about that service; its properties are described below."
Title,typescript
Title,@@filename(main)
Title,"const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {"
Title,"transport: Transport.GRPC,"
Title,options: {
Title,"package: 'hero',"
Title,"protoPath: join(__dirname, 'hero/hero.proto'),"
Title,"},"
Title,});
Title,@@switch
Title,"const app = await NestFactory.createMicroservice(AppModule, {"
Title,"transport: Transport.GRPC,"
Title,options: {
Title,"package: 'hero',"
Title,"protoPath: join(__dirname, 'hero/hero.proto'),"
Title,"},"
Title,});
Title,
Title,info Hint The join() function is imported from the path package; the Transport enum is imported from the @nestjs/microservices package.
Title,
Title,"In the nest-cli.json file, we add the assets property that allows us to distribute non-TypeScript files, and watchAssets - to turn on watching all non-TypeScript assets. In our case, we want .proto files to be automatically copied to the dist folder."
Title,json
Title,{
Title,"""compilerOptions"": {"
Title,"""assets"": [""**/*.proto""],"
Title,"""watchAssets"": true"
Title,}
Title,}
Title,Options
Title,The gRPC transporter options object exposes the properties described below.
Title,
Title,
Title,package
Title,Protobuf package name (matches package setting from .proto file).  Required
Title,
Title,
Title,protoPath
Title,
Title,Absolute (or relative to the root dir) path to the
Title,.proto file. Required
Title,
Title,
Title,
Title,url
Title,"Connection url.  String in the format ip address/dns name:port (for example, '0.0.0.0:50051' for a Docker server) defining the address/port on which the transporter establishes a connection.  Optional.  Defaults to 'localhost:5000'"
Title,
Title,
Title,protoLoader
Title,NPM package name for the utility to load .proto files.  Optional.  Defaults to '@grpc/proto-loader'
Title,
Title,
Title,loader
Title,
Title,@grpc/proto-loader options. These provide detailed control over the behavior of .proto files. Optional. See
Title,here for more details
Title,
Title,
Title,
Title,credentials
Title,
Title,Server credentials.  Optional. Read more here
Title,
Title,
Title,
Title,Sample gRPC service
Title,"Let's define our sample gRPC service called HeroesService. In the above options object, theprotoPath property sets a path to the .proto definitions file hero.proto. The hero.proto file is structured using protocol buffers. Here's what it looks like:"
Title,```typescript
Title,// hero/hero.proto
Title,"syntax = ""proto3"";"
Title,package hero;
Title,service HeroesService {
Title,rpc FindOne (HeroById) returns (Hero) {}
Title,}
Title,message HeroById {
Title,int32 id = 1;
Title,}
Title,message Hero {
Title,int32 id = 1;
Title,string name = 2;
Title,}
Title,```
Title,Our HeroesService exposes a FindOne() method. This method expects an input argument of type HeroById and returns a Hero message (protocol buffers use message elements to define both parameter types and return types).
Title,"Next, we need to implement the service. To define a handler that fulfills this definition, we use the @GrpcMethod() decorator in a controller, as shown below. This decorator provides the metadata needed to declare a method as a gRPC service method."
Title,
Title,info Hint The @MessagePattern() decorator (read more) introduced in previous microservices chapters is not used with gRPC-based microservices. The @GrpcMethod() decorator effectively takes its place for gRPC-based microservices.
Title,
Title,typescript
Title,@@filename(heroes.controller)
Title,@Controller()
Title,export class HeroesController {
Title,"@GrpcMethod('HeroesService', 'FindOne')"
Title,"findOne(data: HeroById, metadata: Metadata, call: ServerUnaryCall<any, any>): Hero {"
Title,const items = [
Title,"{ id: 1, name: 'John' },"
Title,"{ id: 2, name: 'Doe' },"
Title,];
Title,return items.find(({ id }) => id === data.id);
Title,}
Title,}
Title,@@switch
Title,@Controller()
Title,export class HeroesController {
Title,"@GrpcMethod('HeroesService', 'FindOne')"
Title,"findOne(data, metadata, call) {"
Title,const items = [
Title,"{ id: 1, name: 'John' },"
Title,"{ id: 2, name: 'Doe' },"
Title,];
Title,return items.find(({ id }) => id === data.id);
Title,}
Title,}
Title,
Title,"info Hint The @GrpcMethod() decorator is imported from the @nestjs/microservices package, while Metadata and ServerUnaryCall from the grpc package."
Title,
Title,"The decorator shown above takes two arguments. The first is the service name (e.g., 'HeroesService'), corresponding to the HeroesService service definition in hero.proto. The second (the string 'FindOne') corresponds to the FindOne() rpc method defined within HeroesService in the hero.proto file."
Title,"The findOne() handler method takes three arguments, the data passed from the caller, metadata that stores gRPC"
Title,request metadata and call to obtain the GrpcCall object properties such as sendMetadata for send metadata to client.
Title,"Both @GrpcMethod() decorator arguments are optional. If called without the second argument (e.g., 'FindOne'), Nest will automatically associate the .proto file rpc method with the handler based on converting the handler name to upper camel case (e.g., the findOne handler is associated with the FindOne rpc call definition). This is shown below."
Title,typescript
Title,@@filename(heroes.controller)
Title,@Controller()
Title,export class HeroesController {
Title,@GrpcMethod('HeroesService')
Title,"findOne(data: HeroById, metadata: Metadata, call: ServerUnaryCall<any, any>): Hero {"
Title,const items = [
Title,"{ id: 1, name: 'John' },"
Title,"{ id: 2, name: 'Doe' },"
Title,];
Title,return items.find(({ id }) => id === data.id);
Title,}
Title,}
Title,@@switch
Title,@Controller()
Title,export class HeroesController {
Title,@GrpcMethod('HeroesService')
Title,"findOne(data, metadata, call) {"
Title,const items = [
Title,"{ id: 1, name: 'John' },"
Title,"{ id: 2, name: 'Doe' },"
Title,];
Title,return items.find(({ id }) => id === data.id);
Title,}
Title,}
Title,"You can also omit the first @GrpcMethod() argument. In this case, Nest automatically associates the handler with the service definition from the proto definitions file based on the class name where the handler is defined. For example, in the following code, class HeroesService associates its handler methods with the HeroesService service definition in the hero.proto file based on the matching of the name 'HeroesService'."
Title,typescript
Title,@@filename(heroes.controller)
Title,@Controller()
Title,export class HeroesService {
Title,@GrpcMethod()
Title,"findOne(data: HeroById, metadata: Metadata, call: ServerUnaryCall<any, any>): Hero {"
Title,const items = [
Title,"{ id: 1, name: 'John' },"
Title,"{ id: 2, name: 'Doe' },"
Title,];
Title,return items.find(({ id }) => id === data.id);
Title,}
Title,}
Title,@@switch
Title,@Controller()
Title,export class HeroesService {
Title,@GrpcMethod()
Title,"findOne(data, metadata, call) {"
Title,const items = [
Title,"{ id: 1, name: 'John' },"
Title,"{ id: 2, name: 'Doe' },"
Title,];
Title,return items.find(({ id }) => id === data.id);
Title,}
Title,}
Title,Client
Title,"Nest applications can act as gRPC clients, consuming services defined in .proto files. You access remote services through a ClientGrpc object. You can obtain a ClientGrpc object in several ways."
Title,"The preferred technique is to import the ClientsModule. Use the register() method to bind a package of services defined in a .proto file to an injection token, and to configure the service. The name property is the injection token. For gRPC services, use transport: Transport.GRPC. The options property is an object with the same properties described above."
Title,typescript
Title,imports: [
Title,ClientsModule.register([
Title,{
Title,"name: 'HERO_PACKAGE',"
Title,"transport: Transport.GRPC,"
Title,options: {
Title,"package: 'hero',"
Title,"protoPath: join(__dirname, 'hero/hero.proto'),"
Title,"},"
Title,"},"
Title,"]),"
Title,];
Title,
Title,info Hint The register() method takes an array of objects. Register multiple packages by providing a comma separated list of registration objects.
Title,
Title,"Once registered, we can inject the configured ClientGrpc object with @Inject(). Then we use the ClientGrpc object's getService() method to retrieve the service instance, as shown below."
Title,```typescript
Title,@Injectable()
Title,export class AppService implements OnModuleInit {
Title,private heroesService: HeroesService;
Title,constructor(@Inject('HERO_PACKAGE') private client: ClientGrpc) {}
Title,onModuleInit() {
Title,this.heroesService = this.client.getService('HeroesService');
Title,}
Title,getHero(): Observable {
Title,return this.heroesService.findOne({ id: 1 });
Title,}
Title,}
Title,```
Title,
Title,error Warning gRPC Client will not send fields that contain underscore _ in their names unless the keepCase options is set to true in the proto loader configuration (options.loader.keepcase in the microservice transporter configuration).
Title,
Title,"Notice that there is a small difference compared to the technique used in other microservice transport methods. Instead of the ClientProxy class, we use the ClientGrpc class, which provides the getService() method. The getService() generic method takes a service name as an argument and returns its instance (if available)."
Title,"Alternatively, you can use the @Client() decorator to instantiate a ClientGrpc object, as follows:"
Title,```typescript
Title,@Injectable()
Title,export class AppService implements OnModuleInit {
Title,@Client({
Title,"transport: Transport.GRPC,"
Title,options: {
Title,"package: 'hero',"
Title,"protoPath: join(__dirname, 'hero/hero.proto'),"
Title,"},"
Title,})
Title,client: ClientGrpc;
Title,private heroesService: HeroesService;
Title,onModuleInit() {
Title,this.heroesService = this.client.getService('HeroesService');
Title,}
Title,getHero(): Observable {
Title,return this.heroesService.findOne({ id: 1 });
Title,}
Title,}
Title,```
Title,"Finally, for more complex scenarios, we can inject a dynamically configured client using the ClientProxyFactory class as described here."
Title,"In either case, we end up with a reference to our HeroesService proxy object, which exposes the same set of methods that are defined inside the .proto file. Now, when we access this proxy object (i.e., heroesService), the gRPC system automatically serializes requests, forwards them to the remote system, returns a response, and deserializes the response. Because gRPC shields us from these network communication details, heroesService looks and acts like a local provider."
Title,"Note, all service methods are lower camel cased (in order to follow the natural convention of the language). So, for example, while our .proto file HeroesService definition contains the FindOne() function, the heroesService instance will provide the findOne() method."
Title,typescript
Title,interface HeroesService {
Title,findOne(data: { id: number }): Observable<any>;
Title,}
Title,"A message handler is also able to return an Observable, in which case the result values will be emitted until the stream is completed."
Title,typescript
Title,@@filename(heroes.controller)
Title,@Get()
Title,call(): Observable<any> {
Title,return this.heroesService.findOne({ id: 1 });
Title,}
Title,@@switch
Title,@Get()
Title,call() {
Title,return this.heroesService.findOne({ id: 1 });
Title,}
Title,"To send gRPC metadata (along with the request), you can pass a second argument, as follows:"
Title,```typescript
Title,call(): Observable {
Title,const metadata = new Metadata();
Title,"metadata.add('Set-Cookie', 'yummy_cookie=choco');"
Title,"return this.heroesService.findOne({ id: 1 }, metadata);"
Title,}
Title,```
Title,
Title,info Hint The Metadata class is imported from the grpc package.
Title,
Title,Please note that this would require updating the HeroesService interface that we've defined a few steps earlier.
Title,Example
Title,A working example is available here.
Title,gRPC Reflection
Title,"The gRPC Server Reflection Specification is a standard which allows gRPC clients to request details about the API that the server exposes, akin to exposing an OpenAPI document for a REST API. This can make working with developer debugging tools such as grpc-ui or postman significantly easier."
Title,"To add gRPC reflection support to your server, first install the required implementation package:"
Title,bash
Title,$ npm i --save @grpc/reflection
Title,"Then it can be hooked into the gRPC server using the onLoadPackageDefinition hook in your gRPC server options, as follows:"
Title,```typescript
Title,@@filename(main)
Title,import { ReflectionService } from '@grpc/reflection';
Title,"const app = await NestFactory.createMicroservice(AppModule, {"
Title,options: {
Title,"onLoadPackageDefinition: (pkg, server) => {"
Title,new ReflectionService(pkg).addToServer(server);
Title,"},"
Title,"},"
Title,});
Title,```
Title,Now your server will respond to messages requesting API details using the reflection specification.
Title,gRPC Streaming
Title,"gRPC on its own supports long-term live connections, conventionally known as streams. Streams are useful for cases such as Chatting, Observations or Chunk-data transfers. Find more details in the official documentation here."
Title,Nest supports GRPC stream handlers in two possible ways:
Title,
Title,RxJS Subject + Observable handler: can be useful to write responses right inside of a Controller method or to be passed down to Subject/Observable consumer
Title,Pure GRPC call stream handler: can be useful to be passed to some executor which will handle the rest of dispatch for the Node standard Duplex stream handler.
Title,
Title,
Title,Streaming sample
Title,Let's define a new sample gRPC service called HelloService. The hello.proto file is structured using protocol buffers. Here's what it looks like:
Title,```typescript
Title,// hello/hello.proto
Title,"syntax = ""proto3"";"
Title,package hello;
Title,service HelloService {
Title,rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);
Title,rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);
Title,}
Title,message HelloRequest {
Title,string greeting = 1;
Title,}
Title,message HelloResponse {
Title,string reply = 1;
Title,}
Title,```
Title,
Title,info Hint The LotsOfGreetings method can be simply implemented with the @GrpcMethod decorator (as in the examples above) since the returned stream can emit multiple values.
Title,
Title,"Based on this .proto file, let's define the HelloService interface:"
Title,```typescript
Title,interface HelloService {
Title,bidiHello(upstream: Observable): Observable;
Title,lotsOfGreetings(
Title,"upstream: Observable,"
Title,): Observable;
Title,}
Title,interface HelloRequest {
Title,greeting: string;
Title,}
Title,interface HelloResponse {
Title,reply: string;
Title,}
Title,```
Title,
Title,"info Hint The proto interface can be automatically generated by the ts-proto package, learn more here."
Title,
Title,Subject strategy
Title,"The @GrpcStreamMethod() decorator provides the function parameter as an RxJS Observable. Thus, we can receive and process multiple messages."
Title,```typescript
Title,@GrpcStreamMethod()
Title,"bidiHello(messages: Observable, metadata: Metadata, call: ServerDuplexStream): Observable {"
Title,const subject = new Subject();
Title,const onNext = message => {
Title,console.log(message);
Title,subject.next({
Title,"reply: 'Hello, world!'"
Title,});
Title,};
Title,const onComplete = () => subject.complete();
Title,messages.subscribe({
Title,"next: onNext,"
Title,"complete: onComplete,"
Title,});
Title,return subject.asObservable();
Title,}
Title,```
Title,
Title,"warning Warning For supporting full-duplex interaction with the @GrpcStreamMethod() decorator, the controller method must return an RxJS Observable."
Title,info Hint The Metadata and ServerUnaryCall classes/interfaces are imported from the grpc package.
Title,
Title,"According to the service definition (in the .proto file), the BidiHello method should stream requests to the service. To send multiple asynchronous messages to the stream from a client, we leverage an RxJS ReplaySubject class."
Title,```typescript
Title,const helloService = this.client.getService('HelloService');
Title,const helloRequest$ = new ReplaySubject();
Title,helloRequest$.next({ greeting: 'Hello (1)!' });
Title,helloRequest$.next({ greeting: 'Hello (2)!' });
Title,helloRequest$.complete();
Title,return helloService.bidiHello(helloRequest$);
Title,```
Title,"In the example above, we wrote two messages to the stream (next() calls) and notified the service that we've completed sending the data (complete() call)."
Title,Call stream handler
Title,"When the method return value is defined as stream, the @GrpcStreamCall() decorator provides the function parameter as grpc.ServerDuplexStream, which supports standard methods like .on('data', callback), .write(message) or .cancel(). Full documentation on available methods can be found here."
Title,"Alternatively, when the method return value is not a stream, the @GrpcStreamCall() decorator provides two function parameters, respectively grpc.ServerReadableStream (read more here) and callback."
Title,Let's start with implementing the BidiHello which should support a full-duplex interaction.
Title,typescript
Title,@GrpcStreamCall()
Title,bidiHello(requestStream: any) {
Title,"requestStream.on('data', message => {"
Title,console.log(message);
Title,requestStream.write({
Title,"reply: 'Hello, world!'"
Title,});
Title,});
Title,}
Title,
Title,info Hint This decorator does not require any specific return parameter to be provided. It is expected that the stream will be handled similar to any other standard stream type.
Title,
Title,"In the example above, we used the write() method to write objects to the response stream. The callback passed into the .on() method as a second parameter will be called every time our service receives a new chunk of data."
Title,Let's implement the LotsOfGreetings method.
Title,typescript
Title,@GrpcStreamCall()
Title,"lotsOfGreetings(requestStream: any, callback: (err: unknown, value: HelloResponse) => void) {"
Title,"requestStream.on('data', message => {"
Title,console.log(message);
Title,});
Title,"requestStream.on('end', () => callback(null, { reply: 'Hello, world!' }));"
Title,}
Title,Here we used the callback function to send the response once processing of the requestStream has been completed.
Title,gRPC Metadata
Title,"Metadata is information about a particular RPC call in the form of a list of key-value pairs, where the keys are strings and the values are typically strings but can be binary data. Metadata is opaque to gRPC itself - it lets the client provide information associated with the call to the server and vice versa. Metadata may include authentication tokens, request identifiers and tags for monitoring purposes, and data information such as the number of records in a data set."
Title,"To read the metadata in @GrpcMethod() handler, use the second argument (metadata), which is of type Metadata (imported from the grpc package)."
Title,"To send back metadata from the handler, use the ServerUnaryCall#sendMetadata() method (third handler argument)."
Title,```typescript
Title,@@filename(heroes.controller)
Title,@Controller()
Title,export class HeroesService {
Title,@GrpcMethod()
Title,"findOne(data: HeroById, metadata: Metadata, call: ServerUnaryCall): Hero {"
Title,const serverMetadata = new Metadata();
Title,const items = [
Title,"{ id: 1, name: 'John' },"
Title,"{ id: 2, name: 'Doe' },"
Title,];
Title,"serverMetadata.add('Set-Cookie', 'yummy_cookie=choco');"
Title,call.sendMetadata(serverMetadata);
Title,
Title,return items.find(({ id }) => id === data.id);
Title,
Title,}
Title,}
Title,@@switch
Title,@Controller()
Title,export class HeroesService {
Title,@GrpcMethod()
Title,"findOne(data, metadata, call) {"
Title,const serverMetadata = new Metadata();
Title,const items = [
Title,"{ id: 1, name: 'John' },"
Title,"{ id: 2, name: 'Doe' },"
Title,];
Title,"serverMetadata.add('Set-Cookie', 'yummy_cookie=choco');"
Title,call.sendMetadata(serverMetadata);
Title,
Title,return items.find(({ id }) => id === data.id);
Title,
Title,}
Title,}
Title,```
Title,"Likewise, to read the metadata in handlers annotated with the @GrpcStreamMethod() handler (subject strategy), use the second argument (metadata), which is of type Metadata (imported from the grpc package)."
Title,"To send back metadata from the handler, use the ServerDuplexStream#sendMetadata() method (third handler argument)."
Title,"To read metadata from within the call stream handlers (handlers annotated with @GrpcStreamCall() decorator), listen to the metadata event on the requestStream reference, as follows:"
Title,typescript
Title,"requestStream.on('metadata', (metadata: Metadata) => {"
Title,const meta = metadata.get('X-Meta');
Title,});
Title,
Title,Guards
Title,There is no fundamental difference between microservices guards and regular HTTP application guards.
Title,"The only difference is that instead of throwing HttpException, you should use RpcException."
Title,
Title,info Hint The RpcException class is exposed from @nestjs/microservices package.
Title,
Title,Binding guards
Title,"The following example uses a method-scoped guard. Just as with HTTP based applications, you can also use controller-scoped guards (i.e., prefix the controller class with a @UseGuards() decorator)."
Title,typescript
Title,@@filename()
Title,@UseGuards(AuthGuard)
Title,@MessagePattern({ cmd: 'sum' })
Title,accumulate(data: number[]): number {
Title,"return (data || []).reduce((a, b) => a + b);"
Title,}
Title,@@switch
Title,@UseGuards(AuthGuard)
Title,@MessagePattern({ cmd: 'sum' })
Title,accumulate(data) {
Title,"return (data || []).reduce((a, b) => a + b);"
Title,}
Title,
Title,Interceptors
Title,"There is no difference between regular interceptors and microservices interceptors. The following example uses a manually instantiated method-scoped interceptor. Just as with HTTP based applications, you can also use controller-scoped interceptors (i.e., prefix the controller class with a @UseInterceptors() decorator)."
Title,typescript
Title,@@filename()
Title,@UseInterceptors(new TransformInterceptor())
Title,@MessagePattern({ cmd: 'sum' })
Title,accumulate(data: number[]): number {
Title,"return (data || []).reduce((a, b) => a + b);"
Title,}
Title,@@switch
Title,@UseInterceptors(new TransformInterceptor())
Title,@MessagePattern({ cmd: 'sum' })
Title,accumulate(data) {
Title,"return (data || []).reduce((a, b) => a + b);"
Title,}
Title,
Title,Kafka
Title,"Kafka is an open source, distributed streaming platform which has three key capabilities:"
Title,
Title,"Publish and subscribe to streams of records, similar to a message queue or enterprise messaging system."
Title,Store streams of records in a fault-tolerant durable way.
Title,Process streams of records as they occur.
Title,
Title,"The Kafka project aims to provide a unified, high-throughput, low-latency platform for handling real-time data feeds. It integrates very well with Apache Storm and Spark for real-time streaming data analysis."
Title,Installation
Title,"To start building Kafka-based microservices, first install the required package:"
Title,bash
Title,$ npm i --save kafkajs
Title,Overview
Title,"Like other Nest microservice transport layer implementations, you select the Kafka transporter mechanism using the transport property of the options object passed to the createMicroservice() method, along with an optional options property, as shown below:"
Title,typescript
Title,@@filename(main)
Title,"const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {"
Title,"transport: Transport.KAFKA,"
Title,options: {
Title,client: {
Title,"brokers: ['localhost:9092'],"
Title,}
Title,}
Title,});
Title,@@switch
Title,"const app = await NestFactory.createMicroservice(AppModule, {"
Title,"transport: Transport.KAFKA,"
Title,options: {
Title,client: {
Title,"brokers: ['localhost:9092'],"
Title,}
Title,}
Title,});
Title,
Title,info Hint The Transport enum is imported from the @nestjs/microservices package.
Title,
Title,Options
Title,The options property is specific to the chosen transporter. The Kafka transporter exposes the properties described below.
Title,
Title,
Title,client
Title,Client configuration options (read more
Title,here)
Title,
Title,
Title,consumer
Title,Consumer configuration options (read more
Title,here)
Title,
Title,
Title,run
Title,Run configuration options (read more
Title,here)
Title,
Title,
Title,subscribe
Title,Subscribe configuration options (read more
Title,here)
Title,
Title,
Title,producer
Title,Producer configuration options (read more
Title,here)
Title,
Title,
Title,send
Title,Send configuration options (read more
Title,here)
Title,
Title,
Title,producerOnlyMode
Title,Feature flag to skip consumer group registration and only act as a producer (boolean)
Title,
Title,
Title,postfixId
Title,Change suffix of clientId value (string)
Title,
Title,
Title,Client
Title,"There is a small difference in Kafka compared to other microservice transporters. Instead of the ClientProxy class, we use the ClientKafka class."
Title,"Like other microservice transporters, you have several options for creating a ClientKafka instance."
Title,"One method for creating an instance is to use the ClientsModule. To create a client instance with the ClientsModule, import it and use the register() method to pass an options object with the same properties shown above in the createMicroservice() method, as well as a name property to be used as the injection token. Read more about ClientsModule here."
Title,typescript
Title,@Module({
Title,imports: [
Title,ClientsModule.register([
Title,{
Title,"name: 'HERO_SERVICE',"
Title,"transport: Transport.KAFKA,"
Title,options: {
Title,client: {
Title,"clientId: 'hero',"
Title,"brokers: ['localhost:9092'],"
Title,"},"
Title,consumer: {
Title,groupId: 'hero-consumer'
Title,}
Title,}
Title,"},"
Title,"]),"
Title,]
Title,...
Title,})
Title,Other options to create a client (either ClientProxyFactory or @Client()) can be used as well. You can read about them here.
Title,Use the @Client() decorator as follows:
Title,typescript
Title,@Client({
Title,"transport: Transport.KAFKA,"
Title,options: {
Title,client: {
Title,"clientId: 'hero',"
Title,"brokers: ['localhost:9092'],"
Title,"},"
Title,consumer: {
Title,groupId: 'hero-consumer'
Title,}
Title,}
Title,})
Title,client: ClientKafka;
Title,Message pattern
Title,"The Kafka microservice message pattern utilizes two topics for the request and reply channels. The ClientKafka#send() method sends messages with a return address by associating a correlation id, reply topic, and reply partition with the request message. This requires the ClientKafka instance to be subscribed to the reply topic and assigned to at least one partition before sending a message."
Title,"Subsequently, you need to have at least one reply topic partition for every Nest application running. For example, if you are running 4 Nest applications but the reply topic only has 3 partitions, then 1 of the Nest applications will error out when trying to send a message."
Title,When new ClientKafka instances are launched they join the consumer group and subscribe to their respective topics. This process triggers a rebalance of topic partitions assigned to consumers of the consumer group.
Title,"Normally, topic partitions are assigned using the round robin partitioner, which assigns topic partitions to a collection of consumers sorted by consumer names which are randomly set on application launch. However, when a new consumer joins the consumer group, the new consumer can be positioned anywhere within the collection of consumers. This creates a condition where pre-existing consumers can be assigned different partitions when the pre-existing consumer is positioned after the new consumer. As a result, the consumers that are assigned different partitions will lose response messages of requests sent before the rebalance."
Title,"To prevent the ClientKafka consumers from losing response messages, a Nest-specific built-in custom partitioner is utilized. This custom partitioner assigns partitions to a collection of consumers sorted by high-resolution timestamps (process.hrtime()) that are set on application launch."
Title,Message response subscription
Title,
Title,warning Note This section is only relevant if you use request-response message style (with the @MessagePattern decorator and the ClientKafka#send method). Subscribing to the response topic is not necessary for the event-based communication (@EventPattern decorator and ClientKafka#emit method).
Title,
Title,The ClientKafka class provides the subscribeToResponseOf() method. The subscribeToResponseOf() method takes a request's topic name as an argument and adds the derived reply topic name to a collection of reply topics. This method is required when implementing the message pattern.
Title,typescript
Title,@@filename(heroes.controller)
Title,onModuleInit() {
Title,this.client.subscribeToResponseOf('hero.kill.dragon');
Title,}
Title,"If the ClientKafka instance is created asynchronously, the subscribeToResponseOf() method must be called before calling the connect() method."
Title,typescript
Title,@@filename(heroes.controller)
Title,async onModuleInit() {
Title,this.client.subscribeToResponseOf('hero.kill.dragon');
Title,await this.client.connect();
Title,}
Title,Incoming
Title,"Nest receives incoming Kafka messages as an object with key, value, and headers properties that have values of type Buffer. Nest then parses these values by transforming the buffers into strings. If the string is ""object like"", Nest attempts to parse the string as JSON. The value is then passed to its associated handler."
Title,Outgoing
Title,"Nest sends outgoing Kafka messages after a serialization process when publishing events or sending messages. This occurs on arguments passed to the ClientKafka emit() and send() methods or on values returned from a @MessagePattern method. This serialization ""stringifies"" objects that are not strings or buffers by using JSON.stringify() or the toString() prototype method."
Title,typescript
Title,@@filename(heroes.controller)
Title,@Controller()
Title,export class HeroesController {
Title,@MessagePattern('hero.kill.dragon')
Title,killDragon(@Payload() message: KillDragonMessage): any {
Title,const dragonId = message.dragonId;
Title,const items = [
Title,"{ id: 1, name: 'Mythical Sword' },"
Title,"{ id: 2, name: 'Key to Dungeon' },"
Title,];
Title,return items;
Title,}
Title,}
Title,
Title,info Hint @Payload() is imported from the @nestjs/microservices package.
Title,
Title,Outgoing messages can also be keyed by passing an object with the key and value properties. Keying messages is important for meeting the co-partitioning requirement.
Title,```typescript
Title,@@filename(heroes.controller)
Title,@Controller()
Title,export class HeroesController {
Title,@MessagePattern('hero.kill.dragon')
Title,killDragon(@Payload() message: KillDragonMessage): any {
Title,const realm = 'Nest';
Title,const heroId = message.heroId;
Title,const dragonId = message.dragonId;
Title,const items = [
Title,"{ id: 1, name: 'Mythical Sword' },"
Title,"{ id: 2, name: 'Key to Dungeon' },"
Title,];
Title,
Title,return {
Title,headers: {
Title,realm
Title,"},"
Title,"key: heroId,"
Title,value: items
Title,}
Title,
Title,}
Title,}
Title,```
Title,"Additionally, messages passed in this format can also contain custom headers set in the headers hash property. Header hash property values must be either of type string or type Buffer."
Title,```typescript
Title,@@filename(heroes.controller)
Title,@Controller()
Title,export class HeroesController {
Title,@MessagePattern('hero.kill.dragon')
Title,killDragon(@Payload() message: KillDragonMessage): any {
Title,const realm = 'Nest';
Title,const heroId = message.heroId;
Title,const dragonId = message.dragonId;
Title,const items = [
Title,"{ id: 1, name: 'Mythical Sword' },"
Title,"{ id: 2, name: 'Key to Dungeon' },"
Title,];
Title,
Title,return {
Title,headers: {
Title,kafka_nestRealm: realm
Title,"},"
Title,"key: heroId,"
Title,value: items
Title,}
Title,
Title,}
Title,}
Title,```
Title,Event-based
Title,"While the request-response method is ideal for exchanging messages between services, it is less suitable when your message style is event-based (which in turn is ideal for Kafka) - when you just want to publish events without waiting for a response. In that case, you do not want the overhead required by request-response for maintaining two topics."
Title,Check out these two sections to learn more about this: Overview: Event-based and Overview: Publishing events.
Title,Context
Title,"In more sophisticated scenarios, you may want to access more information about the incoming request. When using the Kafka transporter, you can access the KafkaContext object."
Title,typescript
Title,@@filename()
Title,@MessagePattern('hero.kill.dragon')
Title,"killDragon(@Payload() message: KillDragonMessage, @Ctx() context: KafkaContext) {"
Title,console.log(`Topic: ${context.getTopic()}`);
Title,}
Title,@@switch
Title,"@Bind(Payload(), Ctx())"
Title,@MessagePattern('hero.kill.dragon')
Title,"killDragon(message, context) {"
Title,console.log(`Topic: ${context.getTopic()}`);
Title,}
Title,
Title,"info Hint @Payload(), @Ctx() and KafkaContext are imported from the @nestjs/microservices package."
Title,
Title,"To access the original Kafka IncomingMessage object, use the getMessage() method of the KafkaContext object, as follows:"
Title,typescript
Title,@@filename()
Title,@MessagePattern('hero.kill.dragon')
Title,"killDragon(@Payload() message: KillDragonMessage, @Ctx() context: KafkaContext) {"
Title,const originalMessage = context.getMessage();
Title,const partition = context.getPartition();
Title,"const { headers, timestamp } = originalMessage;"
Title,}
Title,@@switch
Title,"@Bind(Payload(), Ctx())"
Title,@MessagePattern('hero.kill.dragon')
Title,"killDragon(message, context) {"
Title,const originalMessage = context.getMessage();
Title,const partition = context.getPartition();
Title,"const { headers, timestamp } = originalMessage;"
Title,}
Title,Where the IncomingMessage fulfills the following interface:
Title,typescript
Title,interface IncomingMessage {
Title,topic: string;
Title,partition: number;
Title,timestamp: string;
Title,size: number;
Title,attributes: number;
Title,offset: string;
Title,key: any;
Title,value: any;
Title,"headers: Record<string, any>;"
Title,}
Title,"If your handler involves a slow processing time for each received message you should consider using the heartbeat callback. To retrieve the heartbeat function, use the getHeartbeat() method of the KafkaContext, as follows:"
Title,```typescript
Title,@@filename()
Title,@MessagePattern('hero.kill.dragon')
Title,"async killDragon(@Payload() message: KillDragonMessage, @Ctx() context: KafkaContext) {"
Title,const heartbeat = context.getHeartbeat();
Title,// Do some slow processing
Title,await doWorkPart1();
Title,// Send heartbeat to not exceed the sessionTimeout
Title,await heartbeat();
Title,// Do some slow processing again
Title,await doWorkPart2();
Title,}
Title,```
Title,Naming conventions
Title,The Kafka microservice components append a description of their respective role onto the client.clientId and consumer.groupId options to prevent collisions between Nest microservice client and server components. By default the ClientKafka components append -client and the ServerKafka components append -server to both of these options. Note how the provided values below are transformed in that way (as shown in the comments).
Title,typescript
Title,@@filename(main)
Title,"const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {"
Title,"transport: Transport.KAFKA,"
Title,options: {
Title,client: {
Title,"clientId: 'hero', // hero-server"
Title,"brokers: ['localhost:9092'],"
Title,"},"
Title,consumer: {
Title,groupId: 'hero-consumer' // hero-consumer-server
Title,"},"
Title,}
Title,});
Title,And for the client:
Title,typescript
Title,@@filename(heroes.controller)
Title,@Client({
Title,"transport: Transport.KAFKA,"
Title,options: {
Title,client: {
Title,"clientId: 'hero', // hero-client"
Title,"brokers: ['localhost:9092'],"
Title,"},"
Title,consumer: {
Title,groupId: 'hero-consumer' // hero-consumer-client
Title,}
Title,}
Title,})
Title,client: ClientKafka;
Title,
Title,info Hint Kafka client and consumer naming conventions can be customized by extending ClientKafka and KafkaServer in your own custom provider and overriding the constructor.
Title,
Title,"Since the Kafka microservice message pattern utilizes two topics for the request and reply channels, a reply pattern should be derived from the request topic. By default, the name of the reply topic is the composite of the request topic name with .reply appended."
Title,typescript
Title,@@filename(heroes.controller)
Title,onModuleInit() {
Title,this.client.subscribeToResponseOf('hero.get'); // hero.get.reply
Title,}
Title,
Title,info Hint Kafka reply topic naming conventions can be customized by extending ClientKafka in your own custom provider and overriding the getResponsePatternName method.
Title,
Title,Retriable exceptions
Title,"Similar to other transporters, all unhandled exceptions are automatically wrapped into an RpcException and converted to a ""user-friendly"" format. However, there are edge-cases when you might want to bypass this mechanism and let exceptions be consumed by the kafkajs driver instead. Throwing an exception when processing a message instructs kafkajs to retry it (redeliver it) which means that even though the message (or event) handler was triggered, the offset won't be committed to Kafka."
Title,
Title,"warning Warning For event handlers (event-based communication), all unhandled exceptions are considered retriable exceptions by default."
Title,
Title,"For this, you can use a dedicated class called KafkaRetriableException, as follows:"
Title,typescript
Title,throw new KafkaRetriableException('...');
Title,
Title,info Hint KafkaRetriableException class is exported from the @nestjs/microservices package.
Title,
Title,Commit offsets
Title,"Committing offsets is essential when working with Kafka. Per default, messages will be automatically committed after a specific time. For more information visit KafkaJS docs. KafkaContext offers a way to access the active consumer for manually committing offsets. The consumer is the KafkaJS consumer and works as the native KafkaJS implementation."
Title,```typescript
Title,@@filename()
Title,@EventPattern('user.created')
Title,"async handleUserCreated(@Payload() data: IncomingMessage, @Ctx() context: KafkaContext) {"
Title,// business logic
Title,const { offset } = context.getMessage();
Title,const partition = context.getPartition();
Title,const topic = context.getTopic();
Title,const consumer = context.getConsumer();
Title,"await consumer.commitOffsets([{ topic, partition, offset }])"
Title,}
Title,@@switch
Title,"@Bind(Payload(), Ctx())"
Title,@EventPattern('user.created')
Title,"async handleUserCreated(data, context) {"
Title,// business logic
Title,const { offset } = context.getMessage();
Title,const partition = context.getPartition();
Title,const topic = context.getTopic();
Title,const consumer = context.getConsumer();
Title,"await consumer.commitOffsets([{ topic, partition, offset }])"
Title,}
Title,```
Title,"To disable auto-committing of messages set autoCommit: false in the run configuration, as follows:"
Title,typescript
Title,@@filename(main)
Title,"const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {"
Title,"transport: Transport.KAFKA,"
Title,options: {
Title,client: {
Title,"brokers: ['localhost:9092'],"
Title,"},"
Title,run: {
Title,autoCommit: false
Title,}
Title,}
Title,});
Title,@@switch
Title,"const app = await NestFactory.createMicroservice(AppModule, {"
Title,"transport: Transport.KAFKA,"
Title,options: {
Title,client: {
Title,"brokers: ['localhost:9092'],"
Title,"},"
Title,run: {
Title,autoCommit: false
Title,}
Title,}
Title,});
Title,
Title,MQTT
Title,"MQTT (Message Queuing Telemetry Transport) is an open source, lightweight messaging protocol, optimized for low latency. This protocol provides a scalable and cost-efficient way to connect devices using a publish/subscribe model. A communication system built on MQTT consists of the publishing server, a broker and one or more clients. It is designed for constrained devices and low-bandwidth, high-latency or unreliable networks."
Title,Installation
Title,"To start building MQTT-based microservices, first install the required package:"
Title,bash
Title,$ npm i --save mqtt
Title,Overview
Title,"To use the MQTT transporter, pass the following options object to the createMicroservice() method:"
Title,typescript
Title,@@filename(main)
Title,"const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {"
Title,"transport: Transport.MQTT,"
Title,options: {
Title,"url: 'mqtt://localhost:1883',"
Title,"},"
Title,});
Title,@@switch
Title,"const app = await NestFactory.createMicroservice(AppModule, {"
Title,"transport: Transport.MQTT,"
Title,options: {
Title,"url: 'mqtt://localhost:1883',"
Title,"},"
Title,});
Title,
Title,info Hint The Transport enum is imported from the @nestjs/microservices package.
Title,
Title,Options
Title,The options object is specific to the chosen transporter. The MQTT transporter exposes the properties described here.
Title,Client
Title,"Like other microservice transporters, you have several options for creating a MQTT ClientProxy instance."
Title,"One method for creating an instance is to use use the ClientsModule. To create a client instance with the ClientsModule, import it and use the register() method to pass an options object with the same properties shown above in the createMicroservice() method, as well as a name property to be used as the injection token. Read more about ClientsModule here."
Title,typescript
Title,@Module({
Title,imports: [
Title,ClientsModule.register([
Title,{
Title,"name: 'MATH_SERVICE',"
Title,"transport: Transport.MQTT,"
Title,options: {
Title,"url: 'mqtt://localhost:1883',"
Title,}
Title,"},"
Title,"]),"
Title,]
Title,...
Title,})
Title,Other options to create a client (either ClientProxyFactory or @Client()) can be used as well. You can read about them here.
Title,Context
Title,"In more sophisticated scenarios, you may want to access more information about the incoming request. When using the MQTT transporter, you can access the MqttContext object."
Title,typescript
Title,@@filename()
Title,@MessagePattern('notifications')
Title,"getNotifications(@Payload() data: number[], @Ctx() context: MqttContext) {"
Title,console.log(`Topic: ${context.getTopic()}`);
Title,}
Title,@@switch
Title,"@Bind(Payload(), Ctx())"
Title,@MessagePattern('notifications')
Title,"getNotifications(data, context) {"
Title,console.log(`Topic: ${context.getTopic()}`);
Title,}
Title,
Title,"info Hint @Payload(), @Ctx() and MqttContext are imported from the @nestjs/microservices package."
Title,
Title,"To access the original mqtt packet, use the getPacket() method of the MqttContext object, as follows:"
Title,typescript
Title,@@filename()
Title,@MessagePattern('notifications')
Title,"getNotifications(@Payload() data: number[], @Ctx() context: MqttContext) {"
Title,console.log(context.getPacket());
Title,}
Title,@@switch
Title,"@Bind(Payload(), Ctx())"
Title,@MessagePattern('notifications')
Title,"getNotifications(data, context) {"
Title,console.log(context.getPacket());
Title,}
Title,Wildcards
Title,"A subscription may be to an explicit topic, or it may include wildcards. Two wildcards are available, + and #. + is a single-level wildcard, while # is a multi-level wildcard which covers many topic levels."
Title,typescript
Title,@@filename()
Title,@MessagePattern('sensors/+/temperature/+')
Title,getTemperature(@Ctx() context: MqttContext) {
Title,console.log(`Topic: ${context.getTopic()}`);
Title,}
Title,@@switch
Title,@Bind(Ctx())
Title,@MessagePattern('sensors/+/temperature/+')
Title,getTemperature(context) {
Title,console.log(`Topic: ${context.getTopic()}`);
Title,}
Title,Quality of Service (QoS)
Title,"Any subscription created with @MessagePattern or @EventPattern decorators will subscribe with QoS 0. If a higher QoS is required, it can be set globally using the subscribeOptions block when establishing the connection as follows:"
Title,typescript
Title,@@filename(main)
Title,"const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {"
Title,"transport: Transport.MQTT,"
Title,options: {
Title,"url: 'mqtt://localhost:1883',"
Title,subscribeOptions: {
Title,qos: 2
Title,"},"
Title,"},"
Title,});
Title,@@switch
Title,"const app = await NestFactory.createMicroservice(AppModule, {"
Title,"transport: Transport.MQTT,"
Title,options: {
Title,"url: 'mqtt://localhost:1883',"
Title,subscribeOptions: {
Title,qos: 2
Title,"},"
Title,"},"
Title,});
Title,"If a topic specific QoS is required, consider creating a Custom transporter."
Title,Record builders
Title,"To configure message options (adjust the QoS level, set the Retain or DUP flags, or add additional properties to the payload), you can use the MqttRecordBuilder class. For example, to set QoS to 2 use the setQoS method, as follows:"
Title,typescript
Title,const userProperties = { 'x-version': '1.0.0' };
Title,const record = new MqttRecordBuilder(':cat:')
Title,.setProperties({ userProperties })
Title,.setQoS(1)
Title,.build();
Title,"client.send('replace-emoji', record).subscribe(...);"
Title,
Title,info Hint MqttRecordBuilder class is exported from the @nestjs/microservices package.
Title,
Title,"And you can read these options on the server-side as well, by accessing the MqttContext."
Title,typescript
Title,@@filename()
Title,@MessagePattern('replace-emoji')
Title,"replaceEmoji(@Payload() data: string, @Ctx() context: MqttContext): string {"
Title,const { properties: { userProperties } } = context.getPacket();
Title,return userProperties['x-version'] === '1.0.0' ? '🐱' : '🐈';
Title,}
Title,@@switch
Title,"@Bind(Payload(), Ctx())"
Title,@MessagePattern('replace-emoji')
Title,"replaceEmoji(data, context) {"
Title,const { properties: { userProperties } } = context.getPacket();
Title,return userProperties['x-version'] === '1.0.0' ? '🐱' : '🐈';
Title,}
Title,"In some cases you might want to configure user properties for multiple requests, you can pass these options to the ClientProxyFactory."
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,"import { ClientProxyFactory, Transport } from '@nestjs/microservices';"
Title,@Module({
Title,providers: [
Title,{
Title,"provide: 'API_v1',"
Title,useFactory: () =>
Title,ClientProxyFactory.create({
Title,"transport: Transport.MQTT,"
Title,options: {
Title,"url: 'mqtt://localhost:1833',"
Title,"userProperties: { 'x-version': '1.0.0' },"
Title,"},"
Title,"}),"
Title,"},"
Title,"],"
Title,})
Title,export class ApiModule {}
Title,```
Title,
Title,NATS
Title,"NATS is a simple, secure and high performance open source messaging system for cloud native applications, IoT messaging, and microservices architectures. The NATS server is written in the Go programming language, but client libraries to interact with the server are available for dozens of major programming languages. NATS supports both At Most Once and At Least Once delivery. It can run anywhere, from large servers and cloud instances, through edge gateways and even Internet of Things devices."
Title,Installation
Title,"To start building NATS-based microservices, first install the required package:"
Title,bash
Title,$ npm i --save nats
Title,Overview
Title,"To use the NATS transporter, pass the following options object to the createMicroservice() method:"
Title,typescript
Title,@@filename(main)
Title,"const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {"
Title,"transport: Transport.NATS,"
Title,options: {
Title,"servers: ['nats://localhost:4222'],"
Title,"},"
Title,});
Title,@@switch
Title,"const app = await NestFactory.createMicroservice(AppModule, {"
Title,"transport: Transport.NATS,"
Title,options: {
Title,"servers: ['nats://localhost:4222'],"
Title,"},"
Title,});
Title,
Title,info Hint The Transport enum is imported from the @nestjs/microservices package.
Title,
Title,Options
Title,The options object is specific to the chosen transporter. The NATS transporter exposes the properties described here.
Title,"Additionally, there is a queue property which allows you to specify the name of the queue that your server should subscribe to (leave undefined to ignore this setting). Read more about NATS queue groups below."
Title,Client
Title,"Like other microservice transporters, you have several options for creating a NATS ClientProxy instance."
Title,"One method for creating an instance is to use the ClientsModule. To create a client instance with the ClientsModule, import it and use the register() method to pass an options object with the same properties shown above in the createMicroservice() method, as well as a name property to be used as the injection token. Read more about ClientsModule here."
Title,typescript
Title,@Module({
Title,imports: [
Title,ClientsModule.register([
Title,{
Title,"name: 'MATH_SERVICE',"
Title,"transport: Transport.NATS,"
Title,options: {
Title,"servers: ['nats://localhost:4222'],"
Title,}
Title,"},"
Title,"]),"
Title,]
Title,...
Title,})
Title,Other options to create a client (either ClientProxyFactory or @Client()) can be used as well. You can read about them here.
Title,Request-response
Title,"For the request-response message style (read more), the NATS transporter does not use the NATS built-in Request-Reply mechanism. Instead, a ""request"" is published on a given subject using the publish() method with a unique reply subject name, and responders listen on that subject and send responses to the reply subject. Reply subjects are directed back to the requestor dynamically, regardless of location of either party."
Title,Event-based
Title,"For the event-based message style (read more), the NATS transporter uses NATS built-in Publish-Subscribe mechanism. A publisher sends a message on a subject and any active subscriber listening on that subject receives the message. Subscribers can also register interest in wildcard subjects that work a bit like a regular expression. This one-to-many pattern is sometimes called fan-out."
Title,Queue groups
Title,"NATS provides a built-in load balancing feature called distributed queues. To create a queue subscription, use the queue property as follows:"
Title,typescript
Title,@@filename(main)
Title,"const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {"
Title,"transport: Transport.NATS,"
Title,options: {
Title,"servers: ['nats://localhost:4222'],"
Title,"queue: 'cats_queue',"
Title,"},"
Title,});
Title,Context
Title,"In more sophisticated scenarios, you may want to access more information about the incoming request. When using the NATS transporter, you can access the NatsContext object."
Title,typescript
Title,@@filename()
Title,@MessagePattern('notifications')
Title,"getNotifications(@Payload() data: number[], @Ctx() context: NatsContext) {"
Title,console.log(`Subject: ${context.getSubject()}`);
Title,}
Title,@@switch
Title,"@Bind(Payload(), Ctx())"
Title,@MessagePattern('notifications')
Title,"getNotifications(data, context) {"
Title,console.log(`Subject: ${context.getSubject()}`);
Title,}
Title,
Title,"info Hint @Payload(), @Ctx() and NatsContext are imported from the @nestjs/microservices package."
Title,
Title,Wildcards
Title,"A subscription may be to an explicit subject, or it may include wildcards."
Title,typescript
Title,@@filename()
Title,@MessagePattern('time.us.*')
Title,"getDate(@Payload() data: number[], @Ctx() context: NatsContext) {"
Title,"console.log(`Subject: ${context.getSubject()}`); // e.g. ""time.us.east"""
Title,return new Date().toLocaleTimeString(...);
Title,}
Title,@@switch
Title,"@Bind(Payload(), Ctx())"
Title,@MessagePattern('time.us.*')
Title,"getDate(data, context) {"
Title,"console.log(`Subject: ${context.getSubject()}`); // e.g. ""time.us.east"""
Title,return new Date().toLocaleTimeString(...);
Title,}
Title,Record builders
Title,"To configure message options, you can use the NatsRecordBuilder class (note: this is doable for event-based flows as well). For example, to add x-version header, use the setHeaders method, as follows:"
Title,```typescript
Title,import * as nats from 'nats';
Title,// somewhere in your code
Title,const headers = nats.headers();
Title,"headers.set('x-version', '1.0.0');"
Title,const record = new NatsRecordBuilder(':cat:').setHeaders(headers).build();
Title,"this.client.send('replace-emoji', record).subscribe(...);"
Title,```
Title,
Title,info Hint NatsRecordBuilder class is exported from the @nestjs/microservices package.
Title,
Title,"And you can read these headers on the server-side as well, by accessing the NatsContext, as follows:"
Title,typescript
Title,@@filename()
Title,@MessagePattern('replace-emoji')
Title,"replaceEmoji(@Payload() data: string, @Ctx() context: NatsContext): string {"
Title,const headers = context.getHeaders();
Title,return headers['x-version'] === '1.0.0' ? '🐱' : '🐈';
Title,}
Title,@@switch
Title,"@Bind(Payload(), Ctx())"
Title,@MessagePattern('replace-emoji')
Title,"replaceEmoji(data, context) {"
Title,const headers = context.getHeaders();
Title,return headers['x-version'] === '1.0.0' ? '🐱' : '🐈';
Title,}
Title,"In some cases you might want to configure headers for multiple requests, you can pass these as options to the ClientProxyFactory:"
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,"import { ClientProxyFactory, Transport } from '@nestjs/microservices';"
Title,@Module({
Title,providers: [
Title,{
Title,"provide: 'API_v1',"
Title,useFactory: () =>
Title,ClientProxyFactory.create({
Title,"transport: Transport.NATS,"
Title,options: {
Title,"servers: ['nats://localhost:4222'],"
Title,"headers: { 'x-version': '1.0.0' },"
Title,"},"
Title,"}),"
Title,"},"
Title,"],"
Title,})
Title,export class ApiModule {}
Title,```
Title,
Title,Pipes
Title,"There is no fundamental difference between regular pipes and microservices pipes. The only difference is that instead of throwing HttpException, you should use RpcException."
Title,
Title,info Hint The RpcException class is exposed from @nestjs/microservices package.
Title,
Title,Binding pipes
Title,"The following example uses a manually instantiated method-scoped pipe. Just as with HTTP based applications, you can also use controller-scoped pipes (i.e., prefix the controller class with a @UsePipes() decorator)."
Title,typescript
Title,@@filename()
Title,@UsePipes(new ValidationPipe({ exceptionFactory: (errors) => new RpcException(errors) }))
Title,@MessagePattern({ cmd: 'sum' })
Title,accumulate(data: number[]): number {
Title,"return (data || []).reduce((a, b) => a + b);"
Title,}
Title,@@switch
Title,@UsePipes(new ValidationPipe({ exceptionFactory: (errors) => new RpcException(errors) }))
Title,@MessagePattern({ cmd: 'sum' })
Title,accumulate(data) {
Title,"return (data || []).reduce((a, b) => a + b);"
Title,}
Title,
Title,RabbitMQ
Title,"RabbitMQ is an open-source and lightweight message broker which supports multiple messaging protocols. It can be deployed in distributed and federated configurations to meet high-scale, high-availability requirements. In addition, it's the most widely deployed message broker, used worldwide at small startups and large enterprises."
Title,Installation
Title,"To start building RabbitMQ-based microservices, first install the required packages:"
Title,bash
Title,$ npm i --save amqplib amqp-connection-manager
Title,Overview
Title,"To use the RabbitMQ transporter, pass the following options object to the createMicroservice() method:"
Title,typescript
Title,@@filename(main)
Title,"const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {"
Title,"transport: Transport.RMQ,"
Title,options: {
Title,"urls: ['amqp://localhost:5672'],"
Title,"queue: 'cats_queue',"
Title,queueOptions: {
Title,durable: false
Title,"},"
Title,"},"
Title,});
Title,@@switch
Title,"const app = await NestFactory.createMicroservice(AppModule, {"
Title,"transport: Transport.RMQ,"
Title,options: {
Title,"urls: ['amqp://localhost:5672'],"
Title,"queue: 'cats_queue',"
Title,queueOptions: {
Title,durable: false
Title,"},"
Title,"},"
Title,});
Title,
Title,info Hint The Transport enum is imported from the @nestjs/microservices package.
Title,
Title,Options
Title,The options property is specific to the chosen transporter. The RabbitMQ transporter exposes the properties described below.
Title,
Title,
Title,urls
Title,Connection urls
Title,
Title,
Title,queue
Title,Queue name which your server will listen to
Title,
Title,
Title,prefetchCount
Title,Sets the prefetch count for the channel
Title,
Title,
Title,isGlobalPrefetchCount
Title,Enables per channel prefetching
Title,
Title,
Title,noAck
Title,"If false, manual acknowledgment mode enabled"
Title,
Title,
Title,consumerTag
Title,Consumer Tag Identifier (read more here)
Title,
Title,
Title,queueOptions
Title,Additional queue options (read more here)
Title,
Title,
Title,socketOptions
Title,Additional socket options (read more here)
Title,
Title,
Title,headers
Title,Headers to be sent along with every message
Title,
Title,
Title,Client
Title,"Like other microservice transporters, you have several options for creating a RabbitMQ ClientProxy instance."
Title,"One method for creating an instance is to use the ClientsModule. To create a client instance with the ClientsModule, import it and use the register() method to pass an options object with the same properties shown above in the createMicroservice() method, as well as a name property to be used as the injection token. Read more about ClientsModule here."
Title,typescript
Title,@Module({
Title,imports: [
Title,ClientsModule.register([
Title,{
Title,"name: 'MATH_SERVICE',"
Title,"transport: Transport.RMQ,"
Title,options: {
Title,"urls: ['amqp://localhost:5672'],"
Title,"queue: 'cats_queue',"
Title,queueOptions: {
Title,durable: false
Title,"},"
Title,"},"
Title,"},"
Title,"]),"
Title,]
Title,...
Title,})
Title,Other options to create a client (either ClientProxyFactory or @Client()) can be used as well. You can read about them here.
Title,Context
Title,"In more sophisticated scenarios, you may want to access more information about the incoming request. When using the RabbitMQ transporter, you can access the RmqContext object."
Title,typescript
Title,@@filename()
Title,@MessagePattern('notifications')
Title,"getNotifications(@Payload() data: number[], @Ctx() context: RmqContext) {"
Title,console.log(`Pattern: ${context.getPattern()}`);
Title,}
Title,@@switch
Title,"@Bind(Payload(), Ctx())"
Title,@MessagePattern('notifications')
Title,"getNotifications(data, context) {"
Title,console.log(`Pattern: ${context.getPattern()}`);
Title,}
Title,
Title,"info Hint @Payload(), @Ctx() and RmqContext are imported from the @nestjs/microservices package."
Title,
Title,"To access the original RabbitMQ message (with the properties, fields, and content), use the getMessage() method of the RmqContext object, as follows:"
Title,typescript
Title,@@filename()
Title,@MessagePattern('notifications')
Title,"getNotifications(@Payload() data: number[], @Ctx() context: RmqContext) {"
Title,console.log(context.getMessage());
Title,}
Title,@@switch
Title,"@Bind(Payload(), Ctx())"
Title,@MessagePattern('notifications')
Title,"getNotifications(data, context) {"
Title,console.log(context.getMessage());
Title,}
Title,"To retrieve a reference to the RabbitMQ channel, use the getChannelRef method of the RmqContext object, as follows:"
Title,typescript
Title,@@filename()
Title,@MessagePattern('notifications')
Title,"getNotifications(@Payload() data: number[], @Ctx() context: RmqContext) {"
Title,console.log(context.getChannelRef());
Title,}
Title,@@switch
Title,"@Bind(Payload(), Ctx())"
Title,@MessagePattern('notifications')
Title,"getNotifications(data, context) {"
Title,console.log(context.getChannelRef());
Title,}
Title,Message acknowledgement
Title,"To make sure a message is never lost, RabbitMQ supports message acknowledgements. An acknowledgement is sent back by the consumer to tell RabbitMQ that a particular message has been received, processed and that RabbitMQ is free to delete it. If a consumer dies (its channel is closed, connection is closed, or TCP connection is lost) without sending an ack, RabbitMQ will understand that a message wasn't processed fully and will re-queue it."
Title,"To enable manual acknowledgment mode, set the noAck property to false:"
Title,typescript
Title,options: {
Title,"urls: ['amqp://localhost:5672'],"
Title,"queue: 'cats_queue',"
Title,"noAck: false,"
Title,queueOptions: {
Title,durable: false
Title,"},"
Title,"},"
Title,"When manual consumer acknowledgements are turned on, we must send a proper acknowledgement from the worker to signal that we are done with a task."
Title,```typescript
Title,@@filename()
Title,@MessagePattern('notifications')
Title,"getNotifications(@Payload() data: number[], @Ctx() context: RmqContext) {"
Title,const channel = context.getChannelRef();
Title,const originalMsg = context.getMessage();
Title,channel.ack(originalMsg);
Title,}
Title,@@switch
Title,"@Bind(Payload(), Ctx())"
Title,@MessagePattern('notifications')
Title,"getNotifications(data, context) {"
Title,const channel = context.getChannelRef();
Title,const originalMsg = context.getMessage();
Title,channel.ack(originalMsg);
Title,}
Title,```
Title,Record builders
Title,"To configure message options, you can use the RmqRecordBuilder class (note: this is doable for event-based flows as well). For example, to set headers and priority properties, use the setOptions method, as follows:"
Title,```typescript
Title,const message = ':cat:';
Title,const record = new RmqRecordBuilder(message)
Title,.setOptions({
Title,headers: {
Title,"['x-version']: '1.0.0',"
Title,"},"
Title,"priority: 3,"
Title,})
Title,.build();
Title,"this.client.send('replace-emoji', record).subscribe(...);"
Title,```
Title,
Title,info Hint RmqRecordBuilder class is exported from the @nestjs/microservices package.
Title,
Title,"And you can read these values on the server-side as well, by accessing the RmqContext, as follows:"
Title,typescript
Title,@@filename()
Title,@MessagePattern('replace-emoji')
Title,"replaceEmoji(@Payload() data: string, @Ctx() context: RmqContext): string {"
Title,const { properties: { headers } } = context.getMessage();
Title,return headers['x-version'] === '1.0.0' ? '🐱' : '🐈';
Title,}
Title,@@switch
Title,"@Bind(Payload(), Ctx())"
Title,@MessagePattern('replace-emoji')
Title,"replaceEmoji(data, context) {"
Title,const { properties: { headers } } = context.getMessage();
Title,return headers['x-version'] === '1.0.0' ? '🐱' : '🐈';
Title,}
Title,
Title,Redis
Title,"The Redis transporter implements the publish/subscribe messaging paradigm and leverages the Pub/Sub feature of Redis. Published messages are categorized in channels, without knowing what subscribers (if any) will eventually receive the message. Each microservice can subscribe to any number of channels. In addition, more than one channel can be subscribed to at a time. Messages exchanged through channels are fire-and-forget, which means that if a message is published and there are no subscribers interested in it, the message is removed and cannot be recovered. Thus, you don't have a guarantee that either messages or events will be handled by at least one service. A single message can be subscribed to (and received) by multiple subscribers."
Title,
Title,Installation
Title,"To start building Redis-based microservices, first install the required package:"
Title,bash
Title,$ npm i --save ioredis
Title,Overview
Title,"To use the Redis transporter, pass the following options object to the createMicroservice() method:"
Title,typescript
Title,@@filename(main)
Title,"const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {"
Title,"transport: Transport.REDIS,"
Title,options: {
Title,"host: 'localhost',"
Title,"port: 6379,"
Title,"},"
Title,});
Title,@@switch
Title,"const app = await NestFactory.createMicroservice(AppModule, {"
Title,"transport: Transport.REDIS,"
Title,options: {
Title,"host: 'localhost',"
Title,"port: 6379,"
Title,"},"
Title,});
Title,
Title,info Hint The Transport enum is imported from the @nestjs/microservices package.
Title,
Title,Options
Title,The options property is specific to the chosen transporter. The Redis transporter exposes the properties described below.
Title,
Title,
Title,host
Title,Connection url
Title,
Title,
Title,port
Title,Connection port
Title,
Title,
Title,retryAttempts
Title,Number of times to retry message (default: 0)
Title,
Title,
Title,retryDelay
Title,Delay between message retry attempts (ms) (default: 0)
Title,
Title,
Title,wildcards
Title,"Enables Redis wildcard subscriptions, instructing transporter to use psubscribe/pmessage under the hood. (default: false)"
Title,
Title,
Title,All the properties supported by the official ioredis client are also supported by this transporter.
Title,Client
Title,"Like other microservice transporters, you have several options for creating a Redis ClientProxy instance."
Title,"One method for creating an instance is to use the ClientsModule. To create a client instance with the ClientsModule, import it and use the register() method to pass an options object with the same properties shown above in the createMicroservice() method, as well as a name property to be used as the injection token. Read more about ClientsModule here."
Title,typescript
Title,@Module({
Title,imports: [
Title,ClientsModule.register([
Title,{
Title,"name: 'MATH_SERVICE',"
Title,"transport: Transport.REDIS,"
Title,options: {
Title,"host: 'localhost',"
Title,"port: 6379,"
Title,}
Title,"},"
Title,"]),"
Title,]
Title,...
Title,})
Title,Other options to create a client (either ClientProxyFactory or @Client()) can be used as well. You can read about them here.
Title,Context
Title,"In more sophisticated scenarios, you may want to access more information about the incoming request. When using the Redis transporter, you can access the RedisContext object."
Title,typescript
Title,@@filename()
Title,@MessagePattern('notifications')
Title,"getNotifications(@Payload() data: number[], @Ctx() context: RedisContext) {"
Title,console.log(`Channel: ${context.getChannel()}`);
Title,}
Title,@@switch
Title,"@Bind(Payload(), Ctx())"
Title,@MessagePattern('notifications')
Title,"getNotifications(data, context) {"
Title,console.log(`Channel: ${context.getChannel()}`);
Title,}
Title,
Title,"info Hint @Payload(), @Ctx() and RedisContext are imported from the @nestjs/microservices package."
Title,
Title,
Title,Middleware
Title,"Middleware is a function which is called before the route handler. Middleware functions have access to the request and response objects, and the next() middleware function in the application’s request-response cycle. The next middleware function is commonly denoted by a variable named next."
Title,
Title,"Nest middleware are, by default, equivalent to express middleware. The following description from the official express documentation describes the capabilities of middleware:"
Title,
Title,Middleware functions can perform the following tasks:
Title,
Title,execute any code.
Title,make changes to the request and the response objects.
Title,end the request-response cycle.
Title,call the next middleware function in the stack.
Title,"if the current middleware function does not end the request-response cycle, it must call next() to"
Title,"pass control to the next middleware function. Otherwise, the request will be left hanging."
Title,
Title,
Title,"You implement custom Nest middleware in either a function, or in a class with an @Injectable() decorator. The class should implement the NestMiddleware interface, while the function does not have any special requirements. Let's start by implementing a simple middleware feature using the class method."
Title,
Title,"warning Warning Express and fastify handle middleware differently and provide different method signatures, read more here."
Title,
Title,```typescript
Title,@@filename(logger.middleware)
Title,"import { Injectable, NestMiddleware } from '@nestjs/common';"
Title,"import { Request, Response, NextFunction } from 'express';"
Title,@Injectable()
Title,export class LoggerMiddleware implements NestMiddleware {
Title,"use(req: Request, res: Response, next: NextFunction) {"
Title,console.log('Request...');
Title,next();
Title,}
Title,}
Title,@@switch
Title,import { Injectable } from '@nestjs/common';
Title,@Injectable()
Title,export class LoggerMiddleware {
Title,"use(req, res, next) {"
Title,console.log('Request...');
Title,next();
Title,}
Title,}
Title,```
Title,Dependency injection
Title,"Nest middleware fully supports Dependency Injection. Just as with providers and controllers, they are able to inject dependencies that are available within the same module. As usual, this is done through the constructor."
Title,Applying middleware
Title,"There is no place for middleware in the @Module() decorator. Instead, we set them up using the configure() method of the module class. Modules that include middleware have to implement the NestModule interface. Let's set up the LoggerMiddleware at the AppModule level."
Title,```typescript
Title,@@filename(app.module)
Title,"import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';"
Title,import { LoggerMiddleware } from './common/middleware/logger.middleware';
Title,import { CatsModule } from './cats/cats.module';
Title,@Module({
Title,"imports: [CatsModule],"
Title,})
Title,export class AppModule implements NestModule {
Title,configure(consumer: MiddlewareConsumer) {
Title,consumer
Title,.apply(LoggerMiddleware)
Title,.forRoutes('cats');
Title,}
Title,}
Title,@@switch
Title,import { Module } from '@nestjs/common';
Title,import { LoggerMiddleware } from './common/middleware/logger.middleware';
Title,import { CatsModule } from './cats/cats.module';
Title,@Module({
Title,"imports: [CatsModule],"
Title,})
Title,export class AppModule {
Title,configure(consumer) {
Title,consumer
Title,.apply(LoggerMiddleware)
Title,.forRoutes('cats');
Title,}
Title,}
Title,```
Title,"In the above example we have set up the LoggerMiddleware for the /cats route handlers that were previously defined inside the CatsController. We may also further restrict a middleware to a particular request method by passing an object containing the route path and request method to the forRoutes() method when configuring the middleware. In the example below, notice that we import the RequestMethod enum to reference the desired request method type."
Title,```typescript
Title,@@filename(app.module)
Title,"import { Module, NestModule, RequestMethod, MiddlewareConsumer } from '@nestjs/common';"
Title,import { LoggerMiddleware } from './common/middleware/logger.middleware';
Title,import { CatsModule } from './cats/cats.module';
Title,@Module({
Title,"imports: [CatsModule],"
Title,})
Title,export class AppModule implements NestModule {
Title,configure(consumer: MiddlewareConsumer) {
Title,consumer
Title,.apply(LoggerMiddleware)
Title,".forRoutes({ path: 'cats', method: RequestMethod.GET });"
Title,}
Title,}
Title,@@switch
Title,"import { Module, RequestMethod } from '@nestjs/common';"
Title,import { LoggerMiddleware } from './common/middleware/logger.middleware';
Title,import { CatsModule } from './cats/cats.module';
Title,@Module({
Title,"imports: [CatsModule],"
Title,})
Title,export class AppModule {
Title,configure(consumer) {
Title,consumer
Title,.apply(LoggerMiddleware)
Title,".forRoutes({ path: 'cats', method: RequestMethod.GET });"
Title,}
Title,}
Title,```
Title,
Title,"info Hint The configure() method can be made asynchronous using async/await (e.g., you can await completion of an asynchronous operation inside the configure() method body)."
Title,"warning Warning When using the express adapter, the NestJS app will register json and urlencoded from the package body-parser by default. This means if you want to customize that middleware via the MiddlewareConsumer, you need to turn off the global middleware by setting the bodyParser flag to false when creating the application with NestFactory.create()."
Title,
Title,Route wildcards
Title,"Pattern based routes are supported as well. For instance, the asterisk is used as a wildcard, and will match any combination of characters:"
Title,typescript
Title,forRoutes({
Title,"path: 'ab*cd',"
Title,"method: RequestMethod.ALL,"
Title,});
Title,"The 'ab*cd' route path will match abcd, ab_cd, abecd, and so on. The characters ?, +, *, and () may be used in a route path, and are subsets of their regular expression counterparts. The hyphen ( -) and the dot (.) are interpreted literally by string-based paths."
Title,
Title,"warning Warning The fastify package uses the latest version of the path-to-regexp package, which no longer supports wildcard asterisks *. Instead, you must use parameters (e.g., (.*), :splat*)."
Title,
Title,Middleware consumer
Title,"The MiddlewareConsumer is a helper class. It provides several built-in methods to manage middleware. All of them can be simply chained in the fluent style. The forRoutes() method can take a single string, multiple strings, a RouteInfo object, a controller class and even multiple controller classes. In most cases you'll probably just pass a list of controllers separated by commas. Below is an example with a single controller:"
Title,```typescript
Title,@@filename(app.module)
Title,"import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';"
Title,import { LoggerMiddleware } from './common/middleware/logger.middleware';
Title,import { CatsModule } from './cats/cats.module';
Title,import { CatsController } from './cats/cats.controller';
Title,@Module({
Title,"imports: [CatsModule],"
Title,})
Title,export class AppModule implements NestModule {
Title,configure(consumer: MiddlewareConsumer) {
Title,consumer
Title,.apply(LoggerMiddleware)
Title,.forRoutes(CatsController);
Title,}
Title,}
Title,@@switch
Title,import { Module } from '@nestjs/common';
Title,import { LoggerMiddleware } from './common/middleware/logger.middleware';
Title,import { CatsModule } from './cats/cats.module';
Title,import { CatsController } from './cats/cats.controller';
Title,@Module({
Title,"imports: [CatsModule],"
Title,})
Title,export class AppModule {
Title,configure(consumer) {
Title,consumer
Title,.apply(LoggerMiddleware)
Title,.forRoutes(CatsController);
Title,}
Title,}
Title,```
Title,
Title,"info Hint The apply() method may either take a single middleware, or multiple arguments to specify multiple middlewares."
Title,
Title,Excluding routes
Title,"At times we want to exclude certain routes from having the middleware applied. We can easily exclude certain routes with the exclude() method. This method can take a single string, multiple strings, or a RouteInfo object identifying routes to be excluded, as shown below:"
Title,typescript
Title,consumer
Title,.apply(LoggerMiddleware)
Title,.exclude(
Title,"{ path: 'cats', method: RequestMethod.GET },"
Title,"{ path: 'cats', method: RequestMethod.POST },"
Title,"'cats/(.*)',"
Title,)
Title,.forRoutes(CatsController);
Title,
Title,info Hint The exclude() method supports wildcard parameters using the path-to-regexp package.
Title,
Title,"With the example above, LoggerMiddleware will be bound to all routes defined inside CatsController except the three passed to the exclude() method."
Title,Functional middleware
Title,"The LoggerMiddleware class we've been using is quite simple. It has no members, no additional methods, and no dependencies. Why can't we just define it in a simple function instead of a class? In fact, we can. This type of middleware is called functional middleware. Let's transform the logger middleware from class-based into functional middleware to illustrate the difference:"
Title,```typescript
Title,@@filename(logger.middleware)
Title,"import { Request, Response, NextFunction } from 'express';"
Title,"export function logger(req: Request, res: Response, next: NextFunction) {"
Title,console.log(Request...);
Title,next();
Title,};
Title,@@switch
Title,"export function logger(req, res, next) {"
Title,console.log(Request...);
Title,next();
Title,};
Title,```
Title,And use it within the AppModule:
Title,typescript
Title,@@filename(app.module)
Title,consumer
Title,.apply(logger)
Title,.forRoutes(CatsController);
Title,
Title,info Hint Consider using the simpler functional middleware alternative any time your middleware doesn't need any dependencies.
Title,
Title,Multiple middleware
Title,"As mentioned above, in order to bind multiple middleware that are executed sequentially, simply provide a comma separated list inside the apply() method:"
Title,typescript
Title,"consumer.apply(cors(), helmet(), logger).forRoutes(CatsController);"
Title,Global middleware
Title,"If we want to bind middleware to every registered route at once, we can use the use() method that is supplied by the INestApplication instance:"
Title,typescript
Title,@@filename(main)
Title,const app = await NestFactory.create(AppModule);
Title,app.use(logger);
Title,await app.listen(process.env.PORT ?? 3000);
Title,
Title,"info Hint Accessing the DI container in a global middleware is not possible. You can use a functional middleware instead when using app.use(). Alternatively, you can use a class middleware and consume it with .forRoutes('*') within the AppModule (or any other module)."
Title,
Title,
Title,Migration guide
Title,This article provides a set of guidelines for migrating from Nest version 9 to version 10.
Title,"To learn more about the new features we've added in v10, check out this article."
Title,There were some very minor breaking changes that shouldn't affect most users - you can find the full list of them here.
Title,Upgrading packages
Title,"While you can upgrade your packages manually, we recommend using ncu (npm check updates)."
Title,Cache module
Title,The CacheModule has been removed from the @nestjs/common package and is now available as a standalone package - @nestjs/cache-manager. This change was made to avoid unnecessary dependencies in the @nestjs/common package. You can learn more about the @nestjs/cache-manager package here.
Title,Deprecations
Title,All deprecated methods & modules have been removed.
Title,CLI Plugins and TypeScript >= 4.8
Title,NestJS CLI Plugins (available for @nestjs/swagger and @nestjs/graphql packages) will now require TypeScript >= v4.8 and so older versions of TypeScript will no longer be supported. The reason for this change is that in TypeScript v4.8 introduced several breaking changes in its Abstract Syntax Tree (AST) which we use to auto-generate OpenAPI and GraphQL schemas.
Title,Dropping support for Node.js v12
Title,"As of NestJS 10, we no longer support Node.js v12, as v12 went EOL on April 30, 2022. This means that NestJS 10 requires Node.js v16 or higher. This decision was made to allow us to finally set target to ES2021 in our TypeScript configuration, instead of shipping polyfills as we did in the past."
Title,"From now on, every official NestJS package will be compiled to ES2021 by default, which should result in a smaller library size and sometimes even (slightly) better performance."
Title,We also strongly recommend using the latest LTS version.
Title,
Title,Modules
Title,A module is a class annotated with a @Module() decorator. The @Module() decorator provides metadata that Nest makes use of to organize the application structure.
Title,
Title,"Each application has at least one module, a root module. The root module is the starting point Nest uses to build the application graph - the internal data structure Nest uses to resolve module and provider relationships and dependencies. While very small applications may theoretically have just the root module, this is not the typical case. We want to emphasize that modules are strongly recommended as an effective way to organize your components. Thus, for most applications, the resulting architecture will employ multiple modules, each encapsulating a closely related set of capabilities."
Title,The @Module() decorator takes a single object whose properties describe the module:
Title,|               |                                                                                                                                                                                                          |
Title,| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
Title,| providers   | the providers that will be instantiated by the Nest injector and that may be shared at least across this module                                                                                          |
Title,| controllers | the set of controllers defined in this module which have to be instantiated                                                                                                                              |
Title,| imports     | the list of imported modules that export the providers which are required in this module                                                                                                                 |
Title,| exports     | the subset of providers that are provided by this module and should be available in other modules which import this module. You can use either the provider itself or just its token (provide value) |
Title,"The module encapsulates providers by default. This means that it's impossible to inject providers that are neither directly part of the current module nor exported from the imported modules. Thus, you may consider the exported providers from a module as the module's public interface, or API."
Title,Feature modules
Title,"The CatsController and CatsService belong to the same application domain. As they are closely related, it makes sense to move them into a feature module. A feature module simply organizes code relevant for a specific feature, keeping code organized and establishing clear boundaries. This helps us manage complexity and develop with SOLID principles, especially as the size of the application and/or team grows."
Title,"To demonstrate this, we'll create the CatsModule."
Title,```typescript
Title,@@filename(cats/cats.module)
Title,import { Module } from '@nestjs/common';
Title,import { CatsController } from './cats.controller';
Title,import { CatsService } from './cats.service';
Title,@Module({
Title,"controllers: [CatsController],"
Title,"providers: [CatsService],"
Title,})
Title,export class CatsModule {}
Title,```
Title,
Title,"info Hint To create a module using the CLI, simply execute the $ nest g module cats command."
Title,
Title,"Above, we defined the CatsModule in the cats.module.ts file, and moved everything related to this module into the cats directory. The last thing we need to do is import this module into the root module (the AppModule, defined in the app.module.ts file)."
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { CatsModule } from './cats/cats.module';
Title,@Module({
Title,"imports: [CatsModule],"
Title,})
Title,export class AppModule {}
Title,```
Title,Here is how our directory structure looks now:
Title,
Title,src
Title,
Title,cats
Title,
Title,dto
Title,
Title,create-cat.dto.ts
Title,
Title,interfaces
Title,
Title,cat.interface.ts
Title,
Title,cats.controller.ts
Title,cats.module.ts
Title,cats.service.ts
Title,
Title,app.module.ts
Title,main.ts
Title,
Title,
Title,Shared modules
Title,"In Nest, modules are singletons by default, and thus you can share the same instance of any provider between multiple modules effortlessly."
Title,
Title,"Every module is automatically a shared module. Once created it can be reused by any module. Let's imagine that we want to share an instance of the CatsService between several other modules. In order to do that, we first need to export the CatsService provider by adding it to the module's exports array, as shown below:"
Title,```typescript
Title,@@filename(cats.module)
Title,import { Module } from '@nestjs/common';
Title,import { CatsController } from './cats.controller';
Title,import { CatsService } from './cats.service';
Title,@Module({
Title,"controllers: [CatsController],"
Title,"providers: [CatsService],"
Title,exports: [CatsService]
Title,})
Title,export class CatsModule {}
Title,```
Title,Now any module that imports the CatsModule has access to the CatsService and will share the same instance with all other modules that import it as well.
Title,"If we were to directly register the CatsService in every module that requires it, it would indeed work, but it would result in each module getting its own separate instance of the CatsService. This can lead to increased memory usage since multiple instances of the same service are created, and it could also cause unexpected behavior, such as state inconsistency if the service maintains any internal state."
Title,"By encapsulating the CatsService inside a module, such as the CatsModule, and exporting it, we ensure that the same instance of CatsService is reused across all modules that import CatsModule. This not only reduces memory consumption but also leads to more predictable behavior, as all modules share the same instance, making it easier to manage shared states or resources. This is one of the key benefits of modularity and dependency injection in frameworks like NestJS—allowing services to be efficiently shared throughout the application."
Title,
Title,Module re-exporting
Title,"As seen above, Modules can export their internal providers. In addition, they can re-export modules that they import. In the example below, the CommonModule is both imported into and exported from the CoreModule, making it available for other modules which import this one."
Title,typescript
Title,@Module({
Title,"imports: [CommonModule],"
Title,"exports: [CommonModule],"
Title,})
Title,export class CoreModule {}
Title,Dependency injection
Title,"A module class can inject providers as well (e.g., for configuration purposes):"
Title,```typescript
Title,@@filename(cats.module)
Title,import { Module } from '@nestjs/common';
Title,import { CatsController } from './cats.controller';
Title,import { CatsService } from './cats.service';
Title,@Module({
Title,"controllers: [CatsController],"
Title,"providers: [CatsService],"
Title,})
Title,export class CatsModule {
Title,constructor(private catsService: CatsService) {}
Title,}
Title,@@switch
Title,"import { Module, Dependencies } from '@nestjs/common';"
Title,import { CatsController } from './cats.controller';
Title,import { CatsService } from './cats.service';
Title,@Module({
Title,"controllers: [CatsController],"
Title,"providers: [CatsService],"
Title,})
Title,@Dependencies(CatsService)
Title,export class CatsModule {
Title,constructor(catsService) {
Title,this.catsService = catsService;
Title,}
Title,}
Title,```
Title,"However, module classes themselves cannot be injected as providers due to circular dependency ."
Title,Global modules
Title,"If you have to import the same set of modules everywhere, it can get tedious. Unlike in Nest, Angular providers are registered in the global scope. Once defined, they're available everywhere. Nest, however, encapsulates providers inside the module scope. You aren't able to use a module's providers elsewhere without first importing the encapsulating module."
Title,"When you want to provide a set of providers which should be available everywhere out-of-the-box (e.g., helpers, database connections, etc.), make the module global with the @Global() decorator."
Title,```typescript
Title,"import { Module, Global } from '@nestjs/common';"
Title,import { CatsController } from './cats.controller';
Title,import { CatsService } from './cats.service';
Title,@Global()
Title,@Module({
Title,"controllers: [CatsController],"
Title,"providers: [CatsService],"
Title,"exports: [CatsService],"
Title,})
Title,export class CatsModule {}
Title,```
Title,"The @Global() decorator makes the module global-scoped. Global modules should be registered only once, generally by the root or core module. In the above example, the CatsService provider will be ubiquitous, and modules that wish to inject the service will not need to import the CatsModule in their imports array."
Title,
Title,info Hint Making everything global is not a good design decision. Global modules are available to reduce the amount of necessary boilerplate. The imports array is generally the preferred way to make the module's API available to consumers.
Title,
Title,Dynamic modules
Title,"The Nest module system includes a powerful feature called dynamic modules. This feature enables you to easily create customizable modules that can register and configure providers dynamically. Dynamic modules are covered extensively here. In this chapter, we'll give a brief overview to complete the introduction to modules."
Title,Following is an example of a dynamic module definition for a DatabaseModule:
Title,```typescript
Title,@@filename()
Title,"import { Module, DynamicModule } from '@nestjs/common';"
Title,import { createDatabaseProviders } from './database.providers';
Title,import { Connection } from './connection.provider';
Title,@Module({
Title,"providers: [Connection],"
Title,"exports: [Connection],"
Title,})
Title,export class DatabaseModule {
Title,"static forRoot(entities = [], options?): DynamicModule {"
Title,"const providers = createDatabaseProviders(options, entities);"
Title,return {
Title,"module: DatabaseModule,"
Title,"providers: providers,"
Title,"exports: providers,"
Title,};
Title,}
Title,}
Title,@@switch
Title,import { Module } from '@nestjs/common';
Title,import { createDatabaseProviders } from './database.providers';
Title,import { Connection } from './connection.provider';
Title,@Module({
Title,"providers: [Connection],"
Title,"exports: [Connection],"
Title,})
Title,export class DatabaseModule {
Title,"static forRoot(entities = [], options) {"
Title,"const providers = createDatabaseProviders(options, entities);"
Title,return {
Title,"module: DatabaseModule,"
Title,"providers: providers,"
Title,"exports: providers,"
Title,};
Title,}
Title,}
Title,```
Title,
Title,"info Hint The forRoot() method may return a dynamic module either synchronously or asynchronously (i.e., via a Promise)."
Title,
Title,"This module defines the Connection provider by default (in the @Module() decorator metadata), but additionally - depending on the entities and options objects passed into the forRoot() method - exposes a collection of providers, for example, repositories. Note that the properties returned by the dynamic module extend (rather than override) the base module metadata defined in the @Module() decorator. That's how both the statically declared Connection provider and the dynamically generated repository providers are exported from the module."
Title,"If you want to register a dynamic module in the global scope, set the global property to true."
Title,typescript
Title,{
Title,"global: true,"
Title,"module: DatabaseModule,"
Title,"providers: providers,"
Title,"exports: providers,"
Title,}
Title,
Title,"warning Warning As mentioned above, making everything global is not a good design decision."
Title,
Title,The DatabaseModule can be imported and configured in the following manner:
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { DatabaseModule } from './database/database.module';
Title,import { User } from './users/entities/user.entity';
Title,@Module({
Title,"imports: [DatabaseModule.forRoot([User])],"
Title,})
Title,export class AppModule {}
Title,```
Title,"If you want to in turn re-export a dynamic module, you can omit the forRoot() method call in the exports array:"
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { DatabaseModule } from './database/database.module';
Title,import { User } from './users/entities/user.entity';
Title,@Module({
Title,"imports: [DatabaseModule.forRoot([User])],"
Title,"exports: [DatabaseModule],"
Title,})
Title,export class AppModule {}
Title,```
Title,"The Dynamic modules chapter covers this topic in greater detail, and includes a working example."
Title,
Title,info Hint Learn how to build highly customizable dynamic modules with the use of ConfigurableModuleBuilder here in this chapter.
Title,
Title,
Title,CLI Plugin
Title,"TypeScript's metadata reflection system has several limitations which make it impossible to, for instance, determine what properties a class consists of or recognize whether a given property is optional or required. However, some of these constraints can be addressed at compilation time. Nest provides a plugin that enhances the TypeScript compilation process to reduce the amount of boilerplate code required."
Title,
Title,"info Hint This plugin is opt-in. If you prefer, you can declare all decorators manually, or only specific decorators where you need them."
Title,
Title,Overview
Title,The Swagger plugin will automatically:
Title,
Title,annotate all DTO properties with @ApiProperty unless @ApiHideProperty is used
Title,set the required property depending on the question mark (e.g. name?: string will set required: false)
Title,set the type or enum property depending on the type (supports arrays as well)
Title,set the default property based on the assigned default value
Title,set several validation rules based on class-validator decorators (if classValidatorShim set to true)
Title,add a response decorator to every endpoint with a proper status and type (response model)
Title,generate descriptions for properties and endpoints based on comments (if introspectComments set to true)
Title,generate example values for properties based on comments (if introspectComments set to true)
Title,
Title,"Please, note that your filenames must have one of the following suffixes: ['.dto.ts', '.entity.ts'] (e.g., create-user.dto.ts) in order to be analysed by the plugin."
Title,"If you are using a different suffix, you can adjust the plugin's behavior by specifying the dtoFileNameSuffix option (see below)."
Title,"Previously, if you wanted to provide an interactive experience with the Swagger UI,"
Title,"you had to duplicate a lot of code to let the package know how your models/components should be declared in the specification. For example, you could define a simple CreateUserDto class as follows:"
Title,```typescript
Title,export class CreateUserDto {
Title,@ApiProperty()
Title,email: string;
Title,@ApiProperty()
Title,password: string;
Title,"@ApiProperty({ enum: RoleEnum, default: [], isArray: true })"
Title,roles: RoleEnum[] = [];
Title,"@ApiProperty({ required: false, default: true })"
Title,isEnabled?: boolean = true;
Title,}
Title,```
Title,"While not a significant issue with medium-sized projects, it becomes verbose & hard to maintain once you have a large set of classes."
Title,"By enabling the Swagger plugin, the above class definition can be declared simply:"
Title,typescript
Title,export class CreateUserDto {
Title,email: string;
Title,password: string;
Title,roles: RoleEnum[] = [];
Title,isEnabled?: boolean = true;
Title,}
Title,
Title,"info Note The Swagger plugin will derive the @ApiProperty() annotations from the TypeScript types and class-validator decorators. This helps in clearly describing your API for the generated Swagger UI documentation. However, the validation at runtime would still be handled by class-validator decorators. So, it is required to continue using validators like IsEmail(), IsNumber(), etc."
Title,
Title,"Hence, if you intend to rely on automatic annotations for generating documentations and still wish for runtime validations, then the class-validator decorators are still necessary."
Title,
Title,info Hint When using mapped types utilities (like PartialType) in DTOs import them from @nestjs/swagger instead of @nestjs/mapped-types for the plugin to pick up the schema.
Title,
Title,The plugin adds appropriate decorators on the fly based on the Abstract Syntax Tree. Thus you won't have to struggle with @ApiProperty decorators scattered throughout the code.
Title,
Title,"info Hint The plugin will automatically generate any missing swagger properties, but if you need to override them, you simply set them explicitly via @ApiProperty()."
Title,
Title,Comments introspection
Title,"With the comments introspection feature enabled, CLI plugin will generate descriptions and example values for properties based on comments."
Title,"For example, given an example roles property:"
Title,typescript
Title,/**
Title,* A list of user's roles
Title,* @example ['admin']
Title,*/
Title,@ApiProperty({
Title,"description: `A list of user's roles`,"
Title,"example: ['admin'],"
Title,})
Title,roles: RoleEnum[] = [];
Title,"You must duplicate both description and example values. With introspectComments enabled, the CLI plugin can extract these comments and automatically provide descriptions (and examples, if defined) for properties. Now, the above property can be declared simply as follows:"
Title,typescript
Title,/**
Title,* A list of user's roles
Title,* @example ['admin']
Title,*/
Title,roles: RoleEnum[] = [];
Title,"There are dtoKeyOfComment and controllerKeyOfComment plugin options available for customizing how the plugin assigns values to the ApiProperty and ApiOperation decorators, respectively. See the example below:"
Title,typescript
Title,export class SomeController {
Title,/**
Title,* Create some resource
Title,*/
Title,@Post()
Title,create() {}
Title,}
Title,This is equivalent to the following instruction:
Title,typescript
Title,"@ApiOperation({ summary: ""Create some resource"" })"
Title,
Title,"info Hint For models, the same logic applies but is used with the ApiProperty decorator instead."
Title,
Title,"For controllers, you can provide not only a summary but also a description (remarks), tags (such as@deprecated), and response examples, like this:"
Title,ts
Title,/**
Title,* Create a new cat
Title,*
Title,* @remarks This operation allows you to create a new cat.
Title,*
Title,* @deprecated
Title,* @throws {500} Something went wrong.
Title,* @throws {400} Bad Request.
Title,*/
Title,@Post()
Title,async create(): Promise<Cat> {}
Title,Using the CLI plugin
Title,"To enable the plugin, open nest-cli.json (if you use Nest CLI) and add the following plugins configuration:"
Title,javascript
Title,{
Title,"""collection"": ""@nestjs/schematics"","
Title,"""sourceRoot"": ""src"","
Title,"""compilerOptions"": {"
Title,"""plugins"": [""@nestjs/swagger""]"
Title,}
Title,}
Title,You can use the options property to customize the behavior of the plugin.
Title,javascript
Title,"""plugins"": ["
Title,{
Title,"""name"": ""@nestjs/swagger"","
Title,"""options"": {"
Title,"""classValidatorShim"": false,"
Title,"""introspectComments"": true"
Title,}
Title,}
Title,]
Title,The options property has to fulfill the following interface:
Title,typescript
Title,export interface PluginOptions {
Title,dtoFileNameSuffix?: string[];
Title,controllerFileNameSuffix?: string[];
Title,classValidatorShim?: boolean;
Title,dtoKeyOfComment?: string;
Title,controllerKeyOfComment?: string;
Title,introspectComments?: boolean;
Title,}
Title,
Title,
Title,Option
Title,Default
Title,Description
Title,
Title,
Title,dtoFileNameSuffix
Title,"['.dto.ts', '.entity.ts']"
Title,DTO (Data Transfer Object) files suffix
Title,
Title,
Title,controllerFileNameSuffix
Title,.controller.ts
Title,Controller files suffix
Title,
Title,
Title,classValidatorShim
Title,true
Title,"If set to true, the module will reuse class-validator validation decorators (e.g. @Max(10) will add max: 10 to schema definition)"
Title,
Title,
Title,dtoKeyOfComment
Title,'description'
Title,The property key to set the comment text to on ApiProperty.
Title,
Title,
Title,controllerKeyOfComment
Title,'summary'
Title,The property key to set the comment text to on ApiOperation.
Title,
Title,
Title,introspectComments
Title,false
Title,"If set to true, plugin will generate descriptions and example values for properties based on comments"
Title,
Title,
Title,Make sure to delete the /dist folder and rebuild your application whenever plugin options are updated.
Title,"If you don't use the CLI but instead have a custom webpack configuration, you can use this plugin in combination with ts-loader:"
Title,javascript
Title,getCustomTransformers: (program: any) => ({
Title,"before: [require('@nestjs/swagger/plugin').before({}, program)]"
Title,"}),"
Title,SWC builder
Title,"For standard setups (non-monorepo), to use CLI Plugins with the SWC builder, you need to enable type checking, as described here."
Title,bash
Title,$ nest start -b swc --type-check
Title,"For monorepo setups, follow the instructions here."
Title,```bash
Title,$ npx ts-node src/generate-metadata.ts
Title,OR npx ts-node apps/{YOUR_APP}/src/generate-metadata.ts
Title,```
Title,"Now, the serialized metadata file must be loaded by the SwaggerModule#loadPluginMetadata method, as shown below:"
Title,```typescript
Title,"import metadata from './metadata'; // <-- file auto-generated by the ""PluginMetadataGenerator"""
Title,await SwaggerModule.loadPluginMetadata(metadata); // <-- here
Title,"const document = SwaggerModule.createDocument(app, config);"
Title,```
Title,Integration with ts-jest (e2e tests)
Title,"To run e2e tests, ts-jest compiles your source code files on the fly, in memory. This means, it doesn't use Nest CLI compiler and does not apply any plugins or perform AST transformations."
Title,"To enable the plugin, create the following file in your e2e tests directory:"
Title,```javascript
Title,const transformer = require('@nestjs/swagger/plugin');
Title,module.exports.name = 'nestjs-swagger-transformer';
Title,"// you should change the version number anytime you change the configuration below - otherwise, jest will not detect changes"
Title,module.exports.version = 1;
Title,module.exports.factory = (cs) => {
Title,return transformer.before(
Title,{
Title,// @nestjs/swagger/plugin options (can be empty)
Title,"},"
Title,"cs.program, // ""cs.tsCompiler.program"" for older versions of Jest (<= v27)"
Title,);
Title,};
Title,```
Title,"With this in place, import AST transformer within your jest configuration file. By default (in the starter application), e2e tests configuration file is located under the test folder and is named jest-e2e.json."
Title,json
Title,{
Title,... // other configuration
Title,"""globals"": {"
Title,"""ts-jest"": {"
Title,"""astTransformers"": {"
Title,"""before"": [""<path to the file created above>""]"
Title,}
Title,}
Title,}
Title,}
Title,"If you use jest@^29, then use the snippet below, as the previous approach got deprecated."
Title,json
Title,{
Title,... // other configuration
Title,"""transform"": {"
Title,"""^.+\\.(t|j)s$"": ["
Title,"""ts-jest"","
Title,{
Title,"""astTransformers"": {"
Title,"""before"": [""<path to the file created above>""]"
Title,}
Title,}
Title,]
Title,}
Title,}
Title,Troubleshooting jest (e2e tests)
Title,"In case jest does not seem to pick up your configuration changes, it's possible that Jest has already cached the build result. To apply the new configuration, you need to clear Jest's cache directory."
Title,"To clear the cache directory, run the following command in your NestJS project folder:"
Title,bash
Title,$ npx jest --clearCache
Title,"In case the automatic cache clearance fails, you can still manually remove the cache folder with the following commands:"
Title,```bash
Title,Find jest cache directory (usually /tmp/jest_rs)
Title,by running the following command in your NestJS project root
Title,$ npx jest --showConfig | grep cache
Title,ex result:
Title,"""cache"": true,"
Title,"""cacheDirectory"": ""/tmp/jest_rs"""
Title,Remove or empty the Jest cache directory
Title,$ rm -rf
Title,ex:
Title,rm -rf /tmp/jest_rs
Title,```
Title,
Title,Decorators
Title,All of the available OpenAPI decorators have an Api prefix to distinguish them from the core decorators. Below is a full list of the exported decorators along with a designation of the level at which the decorator may be applied.
Title,|                           |                     |
Title,| ------------------------- | ------------------- |
Title,| @ApiBasicAuth()         | Method / Controller |
Title,| @ApiBearerAuth()        | Method / Controller |
Title,| @ApiBody()              | Method              |
Title,| @ApiConsumes()          | Method / Controller |
Title,| @ApiCookieAuth()        | Method / Controller |
Title,| @ApiExcludeController() | Controller          |
Title,| @ApiExcludeEndpoint()   | Method              |
Title,| @ApiExtension()         | Method              |
Title,| @ApiExtraModels()       | Method / Controller |
Title,| @ApiHeader()            | Method / Controller |
Title,| @ApiHideProperty()      | Model               |
Title,| @ApiOAuth2()            | Method / Controller |
Title,| @ApiOperation()         | Method              |
Title,| @ApiParam()             | Method / Controller |
Title,| @ApiProduces()          | Method / Controller |
Title,| @ApiSchema()            | Model               |
Title,| @ApiProperty()          | Model               |
Title,| @ApiPropertyOptional()  | Model               |
Title,| @ApiQuery()             | Method / Controller |
Title,| @ApiResponse()          | Method / Controller |
Title,| @ApiSecurity()          | Method / Controller |
Title,| @ApiTags()              | Method / Controller |
Title,| @ApiCallbacks()         | Method / Controller |
Title,
Title,Introduction
Title,The OpenAPI specification is a language-agnostic definition format used to describe RESTful APIs. Nest provides a dedicated module which allows generating such a specification by leveraging decorators.
Title,Installation
Title,"To begin using it, we first install the required dependency."
Title,bash
Title,$ npm install --save @nestjs/swagger
Title,Bootstrap
Title,"Once the installation process is complete, open the main.ts file and initialize Swagger using the SwaggerModule class:"
Title,```typescript
Title,@@filename(main)
Title,import { NestFactory } from '@nestjs/core';
Title,"import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';"
Title,import { AppModule } from './app.module';
Title,async function bootstrap() {
Title,const app = await NestFactory.create(AppModule);
Title,const config = new DocumentBuilder()
Title,.setTitle('Cats example')
Title,.setDescription('The cats API description')
Title,.setVersion('1.0')
Title,.addTag('cats')
Title,.build();
Title,"const documentFactory = () => SwaggerModule.createDocument(app, config);"
Title,"SwaggerModule.setup('api', app, documentFactory);"
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,bootstrap();
Title,```
Title,
Title,"info Hint The factory method SwaggerModule#createDocument() is used specifically to generate the Swagger document when you request it. This approach helps save some initialization time, and the resulting document is a serializable object that conforms to the OpenAPI Document specification. Instead of serving the document over HTTP, you can also save it as a JSON or YAML file and use it in various ways."
Title,
Title,"The DocumentBuilder helps to structure a base document that conforms to the OpenAPI Specification. It provides several methods that allow setting such properties as title, description, version, etc. In order to create a full document (with all HTTP routes defined) we use the createDocument() method of the SwaggerModule class. This method takes two arguments, an application instance and a Swagger options object. Alternatively, we can provide a third argument, which should be of type SwaggerDocumentOptions. More on this in the Document options section."
Title,"Once we create a document, we can call the setup() method. It accepts:"
Title,
Title,The path to mount the Swagger UI
Title,An application instance
Title,The document object instantiated above
Title,Optional configuration parameter (read more here)
Title,
Title,Now you can run the following command to start the HTTP server:
Title,bash
Title,$ npm run start
Title,"While the application is running, open your browser and navigate to http://localhost:3000/api. You should see the Swagger UI."
Title,
Title,"As you can see, the SwaggerModule automatically reflects all of your endpoints."
Title,
Title,"info Hint To generate and download a Swagger JSON file, navigate to http://localhost:3000/api-json (assuming that your Swagger documentation is available under http://localhost:3000/api)."
Title,"It is also possible to expose it on a route of your choice using only the setup method from @nestjs/swagger, like this:"
Title,typescript
Title,"SwaggerModule.setup('swagger', app, document, {"
Title,"jsonDocumentUrl: 'swagger/json',"
Title,});
Title,Which would expose it at http://localhost:3000/swagger/json
Title,"warning Warning When using fastify and helmet, there may be a problem with CSP, to solve this collision, configure the CSP as shown below:"
Title,``typescript
Title,"app.register(helmet, {"
Title,contentSecurityPolicy: {
Title,directives: {
Title,"defaultSrc: ['self'],"
Title,"styleSrc: ['self','unsafe-inline'],"
Title,"imgSrc: ['self', 'data:', 'validator.swagger.io'],"
Title,"scriptSrc: ['self',https: 'unsafe-inline'`],"
Title,"},"
Title,"},"
Title,});
Title,"// If you are not going to use CSP at all, you can use this:"
Title,"app.register(helmet, {"
Title,"contentSecurityPolicy: false,"
Title,});
Title,```
Title,
Title,Document options
Title,"When creating a document, it is possible to provide some extra options to fine tune the library's behavior. These options should be of type SwaggerDocumentOptions, which can be the following:"
Title,```TypeScript
Title,export interface SwaggerDocumentOptions {
Title,/*
Title,* List of modules to include in the specification
Title,/
Title,include?: Function[];
Title,/*
Title,"* Additional, extra models that should be inspected and included in the specification"
Title,/
Title,extraModels?: Function[];
Title,/*
Title,"* If true, swagger will ignore the global prefix set through setGlobalPrefix() method"
Title,/
Title,ignoreGlobalPrefix?: boolean;
Title,/*
Title,"* If true, swagger will also load routes from the modules imported by include modules"
Title,/
Title,deepScanRoutes?: boolean;
Title,/*
Title,* Custom operationIdFactory that will be used to generate the operationId
Title,"* based on the controllerKey, methodKey, and version."
Title,* @default () => controllerKey_methodKey_version
Title,/
Title,operationIdFactory?: OperationIdFactory;
Title,/*
Title,* Custom linkNameFactory that will be used to generate the name of links
Title,* in the links field of responses
Title,*
Title,* @see Link objects
Title,*
Title,* @default () => ${controllerKey}_${methodKey}_from_${fieldKey}
Title,/
Title,linkNameFactory?: (
Title,"controllerKey: string,"
Title,"methodKey: string,"
Title,fieldKey: string
Title,) => string;
Title,/
Title,* Generate tags automatically based on the controller name.
Title,"* If false, you must use the @ApiTags() decorator to define tags."
Title,"* Otherwise, the controller name without the suffix Controller will be used."
Title,* @default true
Title,/
Title,autoTagControllers?: boolean;
Title,}
Title,```
Title,"For example, if you want to make sure that the library generates operation names like createUser instead of UserController_createUser, you can set the following:"
Title,TypeScript
Title,const options: SwaggerDocumentOptions =  {
Title,operationIdFactory: (
Title,"controllerKey: string,"
Title,methodKey: string
Title,) => methodKey
Title,};
Title,"const documentFactory = () => SwaggerModule.createDocument(app, config, options);"
Title,Setup options
Title,You can configure Swagger UI by passing the options object which fulfills the SwaggerCustomOptions interface as a fourth argument of the SwaggerModule#setup method.
Title,``TypeScript
Title,export interface SwaggerCustomOptions {
Title,/**
Title,"* Iftrue, Swagger resources paths will be prefixed by the global prefix set throughsetGlobalPrefix()."
Title,* Default:false`.
Title,* @see https://docs.nestjs.com/faq/global-prefix
Title,*/
Title,useGlobalPrefix?: boolean;
Title,/*
Title,"* If false, only API definitions (JSON and YAML) will be served (on /{path}-json and /{path}-yaml)."
Title,* This is particularly useful if you are already hosting a Swagger UI somewhere else and just want to serve API definitions.
Title,* Default: true.
Title,/
Title,swaggerUiEnabled?: boolean;
Title,/*
Title,* Url point the API definition to load in Swagger UI.
Title,/
Title,swaggerUrl?: string;
Title,/*
Title,* Path of the JSON API definition to serve.
Title,* Default: <path>-json.
Title,/
Title,jsonDocumentUrl?: string;
Title,/*
Title,* Path of the YAML API definition to serve.
Title,* Default: <path>-yaml.
Title,/
Title,yamlDocumentUrl?: string;
Title,/*
Title,* Hook allowing to alter the OpenAPI document before being served.
Title,* It's called after the document is generated and before it is served as JSON & YAML.
Title,/
Title,patchDocumentOnRequest?: (
Title,"req: TRequest,"
Title,"res: TResponse,"
Title,document: OpenAPIObject
Title,) => OpenAPIObject;
Title,/*
Title,"* If true, the selector of OpenAPI definitions is displayed in the Swagger UI interface."
Title,* Default: false.
Title,/
Title,explorer?: boolean;
Title,/*
Title,* Additional Swagger UI options
Title,/
Title,swaggerOptions?: SwaggerUiOptions;
Title,/*
Title,* Custom CSS styles to inject in Swagger UI page.
Title,/
Title,customCss?: string;
Title,/*
Title,* URL(s) of a custom CSS stylesheet to load in Swagger UI page.
Title,/
Title,customCssUrl?: string | string[];
Title,/*
Title,* URL(s) of custom JavaScript files to load in Swagger UI page.
Title,/
Title,customJs?: string | string[];
Title,/*
Title,* Custom JavaScript scripts to load in Swagger UI page.
Title,/
Title,customJsStr?: string | string[];
Title,/*
Title,* Custom favicon for Swagger UI page.
Title,/
Title,customfavIcon?: string;
Title,/*
Title,* Custom title for Swagger UI page.
Title,/
Title,customSiteTitle?: string;
Title,/*
Title,* File system path (ex: ./node_modules/swagger-ui-dist) containing static Swagger UI assets.
Title,/
Title,customSwaggerUiPath?: string;
Title,/*
Title,* @deprecated This property has no effect.
Title,/
Title,validatorUrl?: string;
Title,/*
Title,* @deprecated This property has no effect.
Title,/
Title,url?: string;
Title,/*
Title,* @deprecated This property has no effect.
Title,/
Title,"urls?: Record<'url' | 'name', string>[];"
Title,}
Title,```
Title,Example
Title,A working example is available here.
Title,
Title,Mapped types
Title,As you build out features like CRUD (Create/Read/Update/Delete) it's often useful to construct variants on a base entity type. Nest provides several utility functions that perform type transformations to make this task more convenient.
Title,Partial
Title,"When building input validation types (also called DTOs), it's often useful to build create and update variations on the same type. For example, the create variant may require all fields, while the update variant may make all fields optional."
Title,Nest provides the PartialType() utility function to make this task easier and minimize boilerplate.
Title,"The PartialType() function returns a type (class) with all the properties of the input type set to optional. For example, suppose we have a create type as follows:"
Title,```typescript
Title,import { ApiProperty } from '@nestjs/swagger';
Title,export class CreateCatDto {
Title,@ApiProperty()
Title,name: string;
Title,@ApiProperty()
Title,age: number;
Title,@ApiProperty()
Title,breed: string;
Title,}
Title,```
Title,"By default, all of these fields are required. To create a type with the same fields, but with each one optional, use PartialType() passing the class reference (CreateCatDto) as an argument:"
Title,typescript
Title,export class UpdateCatDto extends PartialType(CreateCatDto) {}
Title,
Title,info Hint The PartialType() function is imported from the @nestjs/swagger package.
Title,
Title,Pick
Title,"The PickType() function constructs a new type (class) by picking a set of properties from an input type. For example, suppose we start with a type like:"
Title,```typescript
Title,import { ApiProperty } from '@nestjs/swagger';
Title,export class CreateCatDto {
Title,@ApiProperty()
Title,name: string;
Title,@ApiProperty()
Title,age: number;
Title,@ApiProperty()
Title,breed: string;
Title,}
Title,```
Title,We can pick a set of properties from this class using the PickType() utility function:
Title,typescript
Title,"export class UpdateCatAgeDto extends PickType(CreateCatDto, ['age'] as const) {}"
Title,
Title,info Hint The PickType() function is imported from the @nestjs/swagger package.
Title,
Title,Omit
Title,"The OmitType() function constructs a type by picking all properties from an input type and then removing a particular set of keys. For example, suppose we start with a type like:"
Title,```typescript
Title,import { ApiProperty } from '@nestjs/swagger';
Title,export class CreateCatDto {
Title,@ApiProperty()
Title,name: string;
Title,@ApiProperty()
Title,age: number;
Title,@ApiProperty()
Title,breed: string;
Title,}
Title,```
Title,"We can generate a derived type that has every property except name as shown below. In this construct, the second argument to OmitType is an array of property names."
Title,typescript
Title,"export class UpdateCatDto extends OmitType(CreateCatDto, ['name'] as const) {}"
Title,
Title,info Hint The OmitType() function is imported from the @nestjs/swagger package.
Title,
Title,Intersection
Title,"The IntersectionType() function combines two types into one new type (class). For example, suppose we start with two types like:"
Title,```typescript
Title,import { ApiProperty } from '@nestjs/swagger';
Title,export class CreateCatDto {
Title,@ApiProperty()
Title,name: string;
Title,@ApiProperty()
Title,breed: string;
Title,}
Title,export class AdditionalCatInfo {
Title,@ApiProperty()
Title,color: string;
Title,}
Title,```
Title,We can generate a new type that combines all properties in both types.
Title,typescript
Title,export class UpdateCatDto extends IntersectionType(
Title,"CreateCatDto,"
Title,"AdditionalCatInfo,"
Title,) {}
Title,
Title,info Hint The IntersectionType() function is imported from the @nestjs/swagger package.
Title,
Title,Composition
Title,"The type mapping utility functions are composable. For example, the following will produce a type (class) that has all of the properties of the CreateCatDto type except for name, and those properties will be set to optional:"
Title,typescript
Title,export class UpdateCatDto extends PartialType(
Title,"OmitType(CreateCatDto, ['name'] as const),"
Title,) {}
Title,
Title,Migration guide
Title,"If you're currently using @nestjs/swagger@3.*, note the following breaking/API changes in version 4.0."
Title,Breaking changes
Title,The following decorators have been changed/renamed:
Title,
Title,@ApiModelProperty is now @ApiProperty
Title,@ApiModelPropertyOptional is now @ApiPropertyOptional
Title,@ApiResponseModelProperty is now @ApiResponseProperty
Title,@ApiImplicitQuery is now @ApiQuery
Title,@ApiImplicitParam is now @ApiParam
Title,@ApiImplicitBody is now @ApiBody
Title,@ApiImplicitHeader is now @ApiHeader
Title,@ApiOperation({{ '{' }} title: 'test' {{ '}' }}) is now @ApiOperation({{ '{' }} summary: 'test' {{ '}' }})
Title,@ApiUseTags is now @ApiTags
Title,
Title,DocumentBuilder breaking changes (updated method signatures):
Title,
Title,addTag
Title,addBearerAuth
Title,addOAuth2
Title,setContactEmail is now setContact
Title,setHost has been removed
Title,"setSchemes has been removed (use the addServer instead, e.g., addServer('http://'))"
Title,
Title,New methods
Title,The following methods have been added:
Title,
Title,addServer
Title,addApiKey
Title,addBasicAuth
Title,addSecurity
Title,addSecurityRequirements
Title,
Title,
Title,
Title,Operations
Title,"In OpenAPI terms, paths are endpoints (resources), such as /users or /reports/summary, that your API exposes, and operations are the HTTP methods used to manipulate these paths, such as GET, POST or DELETE."
Title,Tags
Title,"To attach a controller to a specific tag, use the @ApiTags(...tags) decorator."
Title,typescript
Title,@ApiTags('cats')
Title,@Controller('cats')
Title,export class CatsController {}
Title,Headers
Title,"To define custom headers that are expected as part of the request, use @ApiHeader()."
Title,typescript
Title,@ApiHeader({
Title,"name: 'X-MyHeader',"
Title,"description: 'Custom header',"
Title,})
Title,@Controller('cats')
Title,export class CatsController {}
Title,Responses
Title,"To define a custom HTTP response, use the @ApiResponse() decorator."
Title,typescript
Title,@Post()
Title,"@ApiResponse({ status: 201, description: 'The record has been successfully created.'})"
Title,"@ApiResponse({ status: 403, description: 'Forbidden.'})"
Title,async create(@Body() createCatDto: CreateCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,Nest provides a set of short-hand API response decorators that inherit from the @ApiResponse decorator:
Title,
Title,@ApiOkResponse()
Title,@ApiCreatedResponse()
Title,@ApiAcceptedResponse()
Title,@ApiNoContentResponse()
Title,@ApiMovedPermanentlyResponse()
Title,@ApiFoundResponse()
Title,@ApiBadRequestResponse()
Title,@ApiUnauthorizedResponse()
Title,@ApiNotFoundResponse()
Title,@ApiForbiddenResponse()
Title,@ApiMethodNotAllowedResponse()
Title,@ApiNotAcceptableResponse()
Title,@ApiRequestTimeoutResponse()
Title,@ApiConflictResponse()
Title,@ApiPreconditionFailedResponse()
Title,@ApiTooManyRequestsResponse()
Title,@ApiGoneResponse()
Title,@ApiPayloadTooLargeResponse()
Title,@ApiUnsupportedMediaTypeResponse()
Title,@ApiUnprocessableEntityResponse()
Title,@ApiInternalServerErrorResponse()
Title,@ApiNotImplementedResponse()
Title,@ApiBadGatewayResponse()
Title,@ApiServiceUnavailableResponse()
Title,@ApiGatewayTimeoutResponse()
Title,@ApiDefaultResponse()
Title,
Title,typescript
Title,@Post()
Title,@ApiCreatedResponse({ description: 'The record has been successfully created.'})
Title,@ApiForbiddenResponse({ description: 'Forbidden.'})
Title,async create(@Body() createCatDto: CreateCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,"To specify a return model for a request, we must create a class and annotate all properties with the @ApiProperty() decorator."
Title,```typescript
Title,export class Cat {
Title,@ApiProperty()
Title,id: number;
Title,@ApiProperty()
Title,name: string;
Title,@ApiProperty()
Title,age: number;
Title,@ApiProperty()
Title,breed: string;
Title,}
Title,```
Title,Then the Cat model can be used in combination with the type property of the response decorator.
Title,typescript
Title,@ApiTags('cats')
Title,@Controller('cats')
Title,export class CatsController {
Title,@Post()
Title,@ApiCreatedResponse({
Title,"description: 'The record has been successfully created.',"
Title,"type: Cat,"
Title,})
Title,async create(@Body() createCatDto: CreateCatDto): Promise<Cat> {
Title,return this.catsService.create(createCatDto);
Title,}
Title,}
Title,Let's open the browser and verify the generated Cat model:
Title,
Title,File upload
Title,You can enable file upload for a specific method with the @ApiBody decorator together with @ApiConsumes(). Here's a full example using the File Upload technique:
Title,typescript
Title,@UseInterceptors(FileInterceptor('file'))
Title,@ApiConsumes('multipart/form-data')
Title,@ApiBody({
Title,"description: 'List of cats',"
Title,"type: FileUploadDto,"
Title,})
Title,uploadFile(@UploadedFile() file) {}
Title,Where FileUploadDto is defined as follows:
Title,typescript
Title,class FileUploadDto {
Title,"@ApiProperty({ type: 'string', format: 'binary' })"
Title,file: any;
Title,}
Title,"To handle multiple files uploading, you can define FilesUploadDto as follows:"
Title,typescript
Title,class FilesUploadDto {
Title,"@ApiProperty({ type: 'array', items: { type: 'string', format: 'binary' } })"
Title,files: any[];
Title,}
Title,Extensions
Title,To add an Extension to a request use the @ApiExtension() decorator. The extension name must be prefixed with x-.
Title,typescript
Title,"@ApiExtension('x-foo', { hello: 'world' })"
Title,Advanced: Generic ApiResponse
Title,"With the ability to provide Raw Definitions, we can define Generic schema for Swagger UI. Assume we have the following DTO:"
Title,```ts
Title,export class PaginatedDto {
Title,@ApiProperty()
Title,total: number;
Title,@ApiProperty()
Title,limit: number;
Title,@ApiProperty()
Title,offset: number;
Title,results: TData[];
Title,}
Title,```
Title,"We skip decorating results as we will be providing a raw definition for it later. Now, let's define another DTO and name it, for example, CatDto, as follows:"
Title,```ts
Title,export class CatDto {
Title,@ApiProperty()
Title,name: string;
Title,@ApiProperty()
Title,age: number;
Title,@ApiProperty()
Title,breed: string;
Title,}
Title,```
Title,"With this in place, we can define a PaginatedDto<CatDto> response, as follows:"
Title,ts
Title,@ApiOkResponse({
Title,schema: {
Title,allOf: [
Title,"{ $ref: getSchemaPath(PaginatedDto) },"
Title,{
Title,properties: {
Title,results: {
Title,"type: 'array',"
Title,"items: { $ref: getSchemaPath(CatDto) },"
Title,"},"
Title,"},"
Title,"},"
Title,"],"
Title,"},"
Title,})
Title,async findAll(): Promise<PaginatedDto<CatDto>> {}
Title,"In this example, we specify that the response will have allOf PaginatedDto and the results property will be of type Array<CatDto>."
Title,
Title,getSchemaPath() function that returns the OpenAPI Schema path from within the OpenAPI Spec File for a given model.
Title,allOf is a concept that OAS 3 provides to cover various Inheritance related use-cases.
Title,
Title,"Lastly, since PaginatedDto is not directly referenced by any controller, the SwaggerModule will not be able to generate a corresponding model definition just yet. In this case, we must add it as an Extra Model. For example, we can use the @ApiExtraModels() decorator on the controller level, as follows:"
Title,ts
Title,@Controller('cats')
Title,@ApiExtraModels(PaginatedDto)
Title,export class CatsController {}
Title,"If you run Swagger now, the generated swagger.json for this specific endpoint should have the following response defined:"
Title,json
Title,"""responses"": {"
Title,"""200"": {"
Title,"""description"": """","
Title,"""content"": {"
Title,"""application/json"": {"
Title,"""schema"": {"
Title,"""allOf"": ["
Title,{
Title,"""$ref"": ""#/components/schemas/PaginatedDto"""
Title,"},"
Title,{
Title,"""properties"": {"
Title,"""results"": {"
Title,"""$ref"": ""#/components/schemas/CatDto"""
Title,}
Title,}
Title,}
Title,]
Title,}
Title,}
Title,}
Title,}
Title,}
Title,"To make it reusable, we can create a custom decorator for PaginatedDto, as follows:"
Title,ts
Title,export const ApiPaginatedResponse = <TModel extends Type<any>>(
Title,"model: TModel,"
Title,) => {
Title,return applyDecorators(
Title,"ApiExtraModels(PaginatedDto, model),"
Title,ApiOkResponse({
Title,schema: {
Title,allOf: [
Title,"{ $ref: getSchemaPath(PaginatedDto) },"
Title,{
Title,properties: {
Title,results: {
Title,"type: 'array',"
Title,"items: { $ref: getSchemaPath(model) },"
Title,"},"
Title,"},"
Title,"},"
Title,"],"
Title,"},"
Title,"}),"
Title,);
Title,};
Title,
Title,info Hint Type<any> interface and applyDecorators function are imported from the @nestjs/common package.
Title,
Title,"To ensure that SwaggerModule will generate a definition for our model, we must add it as an extra model, like we did earlier with the PaginatedDto in the controller."
Title,"With this in place, we can use the custom @ApiPaginatedResponse() decorator on our endpoint:"
Title,ts
Title,@ApiPaginatedResponse(CatDto)
Title,async findAll(): Promise<PaginatedDto<CatDto>> {}
Title,"For client generation tools, this approach poses an ambiguity in how the PaginatedResponse<TModel> is being generated for the client. The following snippet is an example of a client generator result for the above GET / endpoint."
Title,typescript
Title,// Angular
Title,"findAll(): Observable<{ total: number, limit: number, offset: number, results: CatDto[] }>"
Title,"As you can see, the Return Type here is ambiguous. To workaround this issue, you can add a title property to the schema for ApiPaginatedResponse:"
Title,typescript
Title,export const ApiPaginatedResponse = <TModel extends Type<any>>(model: TModel) => {
Title,return applyDecorators(
Title,ApiOkResponse({
Title,schema: {
Title,"title: `PaginatedResponseOf${model.name}`,"
Title,allOf: [
Title,// ...
Title,"],"
Title,"},"
Title,"}),"
Title,);
Title,};
Title,Now the result of the client generator tool will become:
Title,ts
Title,// Angular
Title,findAll(): Observable<PaginatedResponseOfCatDto>
Title,
Title,Other features
Title,This page lists all the other available features that you may find useful.
Title,Global prefix
Title,"To ignore a global prefix for routes set through setGlobalPrefix(), use ignoreGlobalPrefix:"
Title,typescript
Title,"const document = SwaggerModule.createDocument(app, options, {"
Title,"ignoreGlobalPrefix: true,"
Title,});
Title,Global parameters
Title,You can add parameter definitions to all routes using DocumentBuilder:
Title,typescript
Title,const options = new DocumentBuilder().addGlobalParameters({
Title,"name: 'tenantId',"
Title,"in: 'header',"
Title,});
Title,Multiple specifications
Title,"The SwaggerModule provides a way to support multiple specifications. In other words, you can serve different documentation, with different UIs, on different endpoints."
Title,"To support multiple specifications, your application must be written with a modular approach. The createDocument() method takes a 3rd argument, extraOptions, which is an object with a property named include. The include property takes a value which is an array of modules."
Title,You can setup multiple specifications support as shown below:
Title,```typescript
Title,import { NestFactory } from '@nestjs/core';
Title,"import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';"
Title,import { AppModule } from './app.module';
Title,import { CatsModule } from './cats/cats.module';
Title,import { DogsModule } from './dogs/dogs.module';
Title,async function bootstrap() {
Title,const app = await NestFactory.create(AppModule);
Title,/*
Title,"* createDocument(application, configurationOptions, extraOptions);"
Title,*
Title,"* createDocument method takes an optional 3rd argument ""extraOptions"""
Title,"* which is an object with ""include"" property where you can pass an Array"
Title,* of Modules that you want to include in that Swagger Specification
Title,* E.g: CatsModule and DogsModule will have two separate Swagger Specifications which
Title,* will be exposed on two different SwaggerUI with two different endpoints.
Title,/
Title,const options = new DocumentBuilder()
Title,.setTitle('Cats example')
Title,.setDescription('The cats API description')
Title,.setVersion('1.0')
Title,.addTag('cats')
Title,.build();
Title,const catDocumentFactory = () =>
Title,"SwaggerModule.createDocument(app, options, {"
Title,"include: [CatsModule],"
Title,});
Title,"SwaggerModule.setup('api/cats', app, catDocumentFactory);"
Title,const secondOptions = new DocumentBuilder()
Title,.setTitle('Dogs example')
Title,.setDescription('The dogs API description')
Title,.setVersion('1.0')
Title,.addTag('dogs')
Title,.build();
Title,const dogDocumentFactory = () =>
Title,"SwaggerModule.createDocument(app, secondOptions, {"
Title,"include: [DogsModule],"
Title,});
Title,"SwaggerModule.setup('api/dogs', app, dogDocumentFactory);"
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,bootstrap();
Title,```
Title,Now you can start your server with the following command:
Title,bash
Title,$ npm run start
Title,Navigate to http://localhost:3000/api/cats to see the Swagger UI for cats:
Title,
Title,"In turn, http://localhost:3000/api/dogs will expose the Swagger UI for dogs:"
Title,
Title,Dropdown in the explorer bar
Title,"To enable support for multiple specifications in the dropdown menu of the explorer bar, you'll need to set explorer: true and configure swaggerOptions.urls in your SwaggerCustomOptions."
Title,
Title,"info Hint Ensure that swaggerOptions.urls points to the JSON format of your Swagger documents! To specify the JSON document, use jsonDocumentUrl within SwaggerCustomOptions. For more setup options, check here."
Title,
Title,Here’s how to set up multiple specifications from a dropdown in the explorer bar:
Title,```typescript
Title,import { NestFactory } from '@nestjs/core';
Title,"import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';"
Title,import { AppModule } from './app.module';
Title,import { CatsModule } from './cats/cats.module';
Title,import { DogsModule } from './dogs/dogs.module';
Title,async function bootstrap() {
Title,const app = await NestFactory.create(AppModule);
Title,// Main API options
Title,const options = new DocumentBuilder()
Title,.setTitle('Multiple Specifications Example')
Title,.setDescription('Description for multiple specifications')
Title,.setVersion('1.0')
Title,.build();
Title,// Create main API document
Title,"const document = SwaggerModule.createDocument(app, options);"
Title,// Setup main API Swagger UI with dropdown support
Title,"SwaggerModule.setup('api', app, document, {"
Title,"explorer: true,"
Title,swaggerOptions: {
Title,urls: [
Title,{
Title,"name: '1. API',"
Title,"url: 'api/swagger.json',"
Title,"},"
Title,{
Title,"name: '2. Cats API',"
Title,"url: 'api/cats/swagger.json',"
Title,"},"
Title,{
Title,"name: '3. Dogs API',"
Title,"url: 'api/dogs/swagger.json',"
Title,"},"
Title,"],"
Title,"},"
Title,"jsonDocumentUrl: '/api/swagger.json',"
Title,});
Title,// Cats API options
Title,const catOptions = new DocumentBuilder()
Title,.setTitle('Cats Example')
Title,.setDescription('Description for the Cats API')
Title,.setVersion('1.0')
Title,.addTag('cats')
Title,.build();
Title,// Create Cats API document
Title,"const catDocument = SwaggerModule.createDocument(app, catOptions, {"
Title,"include: [CatsModule],"
Title,});
Title,// Setup Cats API Swagger UI
Title,"SwaggerModule.setup('api/cats', app, catDocument, {"
Title,"jsonDocumentUrl: '/api/cats/swagger.json',"
Title,});
Title,// Dogs API options
Title,const dogOptions = new DocumentBuilder()
Title,.setTitle('Dogs Example')
Title,.setDescription('Description for the Dogs API')
Title,.setVersion('1.0')
Title,.addTag('dogs')
Title,.build();
Title,// Create Dogs API document
Title,"const dogDocument = SwaggerModule.createDocument(app, dogOptions, {"
Title,"include: [DogsModule],"
Title,});
Title,// Setup Dogs API Swagger UI
Title,"SwaggerModule.setup('api/dogs', app, dogDocument, {"
Title,"jsonDocumentUrl: '/api/dogs/swagger.json',"
Title,});
Title,await app.listen(3000);
Title,}
Title,bootstrap();
Title,```
Title,"In this example, we set up a main API along with separate specifications for Cats and Dogs, each accessible from the dropdown in the explorer bar."
Title,
Title,Security
Title,"To define which security mechanisms should be used for a specific operation, use the @ApiSecurity() decorator."
Title,typescript
Title,@ApiSecurity('basic')
Title,@Controller('cats')
Title,export class CatsController {}
Title,"Before you run your application, remember to add the security definition to your base document using DocumentBuilder:"
Title,typescript
Title,"const options = new DocumentBuilder().addSecurity('basic', {"
Title,"type: 'http',"
Title,"scheme: 'basic',"
Title,});
Title,"Some of the most popular authentication techniques are built-in (e.g., basic and bearer) and therefore you don't have to define security mechanisms manually as shown above."
Title,Basic authentication
Title,"To enable basic authentication, use @ApiBasicAuth()."
Title,typescript
Title,@ApiBasicAuth()
Title,@Controller('cats')
Title,export class CatsController {}
Title,"Before you run your application, remember to add the security definition to your base document using DocumentBuilder:"
Title,typescript
Title,const options = new DocumentBuilder().addBasicAuth();
Title,Bearer authentication
Title,"To enable bearer authentication, use @ApiBearerAuth()."
Title,typescript
Title,@ApiBearerAuth()
Title,@Controller('cats')
Title,export class CatsController {}
Title,"Before you run your application, remember to add the security definition to your base document using DocumentBuilder:"
Title,typescript
Title,const options = new DocumentBuilder().addBearerAuth();
Title,OAuth2 authentication
Title,"To enable OAuth2, use @ApiOAuth2()."
Title,typescript
Title,@ApiOAuth2(['pets:write'])
Title,@Controller('cats')
Title,export class CatsController {}
Title,"Before you run your application, remember to add the security definition to your base document using DocumentBuilder:"
Title,typescript
Title,const options = new DocumentBuilder().addOAuth2();
Title,Cookie authentication
Title,"To enable cookie authentication, use @ApiCookieAuth()."
Title,typescript
Title,@ApiCookieAuth()
Title,@Controller('cats')
Title,export class CatsController {}
Title,"Before you run your application, remember to add the security definition to your base document using DocumentBuilder:"
Title,typescript
Title,const options = new DocumentBuilder().addCookieAuth('optional-session-id');
Title,
Title,Types and parameters
Title,"The SwaggerModule searches for all @Body(), @Query(), and @Param() decorators in route handlers to generate the API document. It also creates corresponding model definitions by taking advantage of reflection. Consider the following code:"
Title,typescript
Title,@Post()
Title,async create(@Body() createCatDto: CreateCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,
Title,info Hint To explicitly set the body definition use the @ApiBody() decorator (imported from the @nestjs/swagger package).
Title,
Title,"Based on the CreateCatDto, the following model definition Swagger UI will be created:"
Title,
Title,"As you can see, the definition is empty although the class has a few declared properties. In order to make the class properties visible to the SwaggerModule, we have to either annotate them with the @ApiProperty() decorator or use the CLI plugin (read more in the Plugin section) which will do it automatically:"
Title,```typescript
Title,import { ApiProperty } from '@nestjs/swagger';
Title,export class CreateCatDto {
Title,@ApiProperty()
Title,name: string;
Title,@ApiProperty()
Title,age: number;
Title,@ApiProperty()
Title,breed: string;
Title,}
Title,```
Title,
Title,"info Hint Instead of manually annotating each property, consider using the Swagger plugin (see Plugin section) which will automatically provide this for you."
Title,
Title,Let's open the browser and verify the generated CreateCatDto model:
Title,
Title,"In addition, the @ApiProperty() decorator allows setting various Schema Object properties:"
Title,typescript
Title,@ApiProperty({
Title,"description: 'The age of a cat',"
Title,"minimum: 1,"
Title,"default: 1,"
Title,})
Title,age: number;
Title,
Title,"info Hint Instead of explicitly typing the {{""@ApiProperty({ required: false })""}} you can use the @ApiPropertyOptional() short-hand decorator."
Title,
Title,"In order to explicitly set the type of the property, use the type key:"
Title,typescript
Title,@ApiProperty({
Title,"type: Number,"
Title,})
Title,age: number;
Title,Arrays
Title,"When the property is an array, we must manually indicate the array type as shown below:"
Title,typescript
Title,@ApiProperty({ type: [String] })
Title,names: string[];
Title,
Title,info Hint Consider using the Swagger plugin (see Plugin section) which will automatically detect arrays.
Title,
Title,Either include the type as the first element of an array (as shown above) or set the isArray property to true.
Title,
Title,Circular dependencies
Title,"When you have circular dependencies between classes, use a lazy function to provide the SwaggerModule with type information:"
Title,typescript
Title,@ApiProperty({ type: () => Node })
Title,node: Node;
Title,
Title,info Hint Consider using the Swagger plugin (see Plugin section) which will automatically detect circular dependencies.
Title,
Title,Generics and interfaces
Title,"Since TypeScript does not store metadata about generics or interfaces, when you use them in your DTOs, SwaggerModule may not be able to properly generate model definitions at runtime. For instance, the following code won't be correctly inspected by the Swagger module:"
Title,typescript
Title,createBulk(@Body() usersDto: CreateUserDto[])
Title,"In order to overcome this limitation, you can set the type explicitly:"
Title,typescript
Title,@ApiBody({ type: [CreateUserDto] })
Title,createBulk(@Body() usersDto: CreateUserDto[])
Title,Enums
Title,"To identify an enum, we must manually set the enum property on the @ApiProperty with an array of values."
Title,typescript
Title,"@ApiProperty({ enum: ['Admin', 'Moderator', 'User']})"
Title,role: UserRole;
Title,"Alternatively, define an actual TypeScript enum as follows:"
Title,typescript
Title,export enum UserRole {
Title,"Admin = 'Admin',"
Title,"Moderator = 'Moderator',"
Title,"User = 'User',"
Title,}
Title,You can then use the enum directly with the @Query() parameter decorator in combination with the @ApiQuery() decorator.
Title,typescript
Title,"@ApiQuery({ name: 'role', enum: UserRole })"
Title,async filterByRole(@Query('role') role: UserRole = UserRole.User) {}
Title,
Title,"With isArray set to true, the enum can be selected as a multi-select:"
Title,
Title,Enums schema
Title,"By default, the enum property will add a raw definition of Enum on the parameter."
Title,yaml
Title,- breed:
Title,type: 'string'
Title,enum:
Title,- Persian
Title,- Tabby
Title,- Siamese
Title,"The above specification works fine for most cases. However, if you are utilizing a tool that takes the specification as input and generates client-side code, you might run into a problem with the generated code containing duplicated enums. Consider the following code snippet:"
Title,```typescript
Title,// generated client-side code
Title,export class CatDetail {
Title,breed: CatDetailEnum;
Title,}
Title,export class CatInformation {
Title,breed: CatInformationEnum;
Title,}
Title,export enum CatDetailEnum {
Title,"Persian = 'Persian',"
Title,"Tabby = 'Tabby',"
Title,"Siamese = 'Siamese',"
Title,}
Title,export enum CatInformationEnum {
Title,"Persian = 'Persian',"
Title,"Tabby = 'Tabby',"
Title,"Siamese = 'Siamese',"
Title,}
Title,```
Title,
Title,info Hint The above snippet is generated using a tool called NSwag.
Title,
Title,You can see that now you have two enums that are exactly the same.
Title,"To address this issue, you can pass an enumName along with the enum property in your decorator."
Title,typescript
Title,export class CatDetail {
Title,"@ApiProperty({ enum: CatBreed, enumName: 'CatBreed' })"
Title,breed: CatBreed;
Title,}
Title,The enumName property enables @nestjs/swagger to turn CatBreed into its own schema which in turns makes CatBreed enum reusable. The specification will look like the following:
Title,yaml
Title,CatDetail:
Title,type: 'object'
Title,properties:
Title,...
Title,- breed:
Title,schema:
Title,$ref: '#/components/schemas/CatBreed'
Title,CatBreed:
Title,type: string
Title,enum:
Title,- Persian
Title,- Tabby
Title,- Siamese
Title,
Title,info Hint Any decorator that takes enum as a property will also take enumName.
Title,
Title,Property value examples
Title,"You can set a single example for a property by using the example key, like this:"
Title,typescript
Title,@ApiProperty({
Title,"example: 'persian',"
Title,})
Title,breed: string;
Title,"If you want to provide multiple examples, you can use the examples key by passing in an object structured like this:"
Title,typescript
Title,@ApiProperty({
Title,examples: {
Title,"Persian: { value: 'persian' },"
Title,"Tabby: { value: 'tabby' },"
Title,"Siamese: { value: 'siamese' },"
Title,"'Scottish Fold': { value: 'scottish_fold' },"
Title,"},"
Title,})
Title,breed: string;
Title,Raw definitions
Title,"In certain cases, such as deeply nested arrays or matrices, you may need to manually define your type:"
Title,typescript
Title,@ApiProperty({
Title,"type: 'array',"
Title,items: {
Title,"type: 'array',"
Title,items: {
Title,"type: 'number',"
Title,"},"
Title,"},"
Title,})
Title,coords: number[][];
Title,"You can also specify raw object schemas, like this:"
Title,typescript
Title,@ApiProperty({
Title,"type: 'object',"
Title,properties: {
Title,name: {
Title,"type: 'string',"
Title,example: 'Error'
Title,"},"
Title,status: {
Title,"type: 'number',"
Title,example: 400
Title,}
Title,"},"
Title,"required: ['name', 'status']"
Title,})
Title,"rawDefinition: Record<string, any>;"
Title,"To manually define input/output content in controller classes, use the schema property:"
Title,typescript
Title,@ApiBody({
Title,schema: {
Title,"type: 'array',"
Title,items: {
Title,"type: 'array',"
Title,items: {
Title,"type: 'number',"
Title,"},"
Title,"},"
Title,"},"
Title,})
Title,async create(@Body() coords: number[][]) {}
Title,Extra models
Title,"To define additional models that are not directly referenced in your controllers but should be inspected by the Swagger module, use the @ApiExtraModels() decorator:"
Title,typescript
Title,@ApiExtraModels(ExtraModel)
Title,export class CreateCatDto {}
Title,
Title,info Hint You only need to use @ApiExtraModels() once for a specific model class.
Title,
Title,"Alternatively, you can pass an options object with the extraModels property specified to the SwaggerModule#createDocument() method, as follows:"
Title,typescript
Title,const documentFactory = () =>
Title,"SwaggerModule.createDocument(app, options, {"
Title,"extraModels: [ExtraModel],"
Title,});
Title,"To get a reference ($ref) to your model, use the getSchemaPath(ExtraModel) function:"
Title,typescript
Title,'application/vnd.api+json': {
Title,"schema: { $ref: getSchemaPath(ExtraModel) },"
Title,"},"
Title,"oneOf, anyOf, allOf"
Title,"To combine schemas, you can use the oneOf, anyOf or allOf keywords (read more)."
Title,typescript
Title,@ApiProperty({
Title,oneOf: [
Title,"{ $ref: getSchemaPath(Cat) },"
Title,"{ $ref: getSchemaPath(Dog) },"
Title,"],"
Title,})
Title,pet: Cat | Dog;
Title,"If you want to define a polymorphic array (i.e., an array whose members span multiple schemas), you should use a raw definition (see above) to define your type by hand."
Title,```typescript
Title,type Pet = Cat | Dog;
Title,@ApiProperty({
Title,"type: 'array',"
Title,items: {
Title,oneOf: [
Title,"{ $ref: getSchemaPath(Cat) },"
Title,"{ $ref: getSchemaPath(Dog) },"
Title,"],"
Title,"},"
Title,})
Title,pets: Pet[];
Title,```
Title,
Title,info Hint The getSchemaPath() function is imported from @nestjs/swagger.
Title,
Title,Both Cat and Dog must be defined as extra models using the @ApiExtraModels() decorator (at the class-level).
Title,Schema name
Title,"As you may have noticed, the name of the generated schema is based on the name of the original model class (for example, the CreateCatDto model generates a CreateCatDto schema). If you'd like to change the schema name, you can use the @ApiSchema() decorator."
Title,Here’s an example:
Title,typescript
Title,@ApiSchema({ name: 'CreateCatRequest' })
Title,class CreateCatDto {}
Title,The model above will be translated into the CreateCatRequest schema.
Title,
Title,Pipes
Title,"A pipe is a class annotated with the @Injectable() decorator, which implements the PipeTransform interface."
Title,
Title,
Title,
Title,Pipes have two typical use cases:
Title,
Title,"transformation: transform input data to the desired form (e.g., from string to integer)"
Title,"validation: evaluate input data and if valid, simply pass it through unchanged; otherwise, throw an exception"
Title,
Title,"In both cases, pipes operate on the arguments being processed by a controller route handler. Nest interposes a pipe just before a method is invoked, and the pipe receives the arguments destined for the method and operates on them. Any transformation or validation operation takes place at that time, after which the route handler is invoked with any (potentially) transformed arguments."
Title,"Nest comes with a number of built-in pipes that you can use out-of-the-box. You can also build your own custom pipes. In this chapter, we'll introduce the built-in pipes and show how to bind them to route handlers. We'll then examine several custom-built pipes to show how you can build one from scratch."
Title,
Title,"info Hint Pipes run inside the exceptions zone. This means that when a Pipe throws an exception it is handled by the exceptions layer (global exceptions filter and any exceptions filters that are applied to the current context). Given the above, it should be clear that when an exception is thrown in a Pipe, no controller method is subsequently executed. This gives you a best-practice technique for validating data coming into the application from external sources at the system boundary."
Title,
Title,Built-in pipes
Title,Nest comes with nine pipes available out-of-the-box:
Title,
Title,ValidationPipe
Title,ParseIntPipe
Title,ParseFloatPipe
Title,ParseBoolPipe
Title,ParseArrayPipe
Title,ParseUUIDPipe
Title,ParseEnumPipe
Title,DefaultValuePipe
Title,ParseFilePipe
Title,
Title,They're exported from the @nestjs/common package.
Title,"Let's take a quick look at using ParseIntPipe. This is an example of the transformation use case, where the pipe ensures that a method handler parameter is converted to a JavaScript integer (or throws an exception if the conversion fails). Later in this chapter, we'll show a simple custom implementation for a ParseIntPipe. The example techniques below also apply to the other built-in transformation pipes (ParseBoolPipe, ParseFloatPipe, ParseEnumPipe, ParseArrayPipe and ParseUUIDPipe, which we'll refer to as the Parse* pipes in this chapter)."
Title,Binding pipes
Title,"To use a pipe, we need to bind an instance of the pipe class to the appropriate context. In our ParseIntPipe example, we want to associate the pipe with a particular route handler method, and make sure it runs before the method is called. We do so with the following construct, which we'll refer to as binding the pipe at the method parameter level:"
Title,typescript
Title,@Get(':id')
Title,"async findOne(@Param('id', ParseIntPipe) id: number) {"
Title,return this.catsService.findOne(id);
Title,}
Title,"This ensures that one of the following two conditions is true: either the parameter we receive in the findOne() method is a number (as expected in our call to this.catsService.findOne()), or an exception is thrown before the route handler is called."
Title,"For example, assume the route is called like:"
Title,bash
Title,GET localhost:3000/abc
Title,Nest will throw an exception like this:
Title,json
Title,{
Title,"""statusCode"": 400,"
Title,"""message"": ""Validation failed (numeric string is expected)"","
Title,"""error"": ""Bad Request"""
Title,}
Title,The exception will prevent the body of the findOne() method from executing.
Title,"In the example above, we pass a class (ParseIntPipe), not an instance, leaving responsibility for instantiation to the framework and enabling dependency injection. As with pipes and guards, we can instead pass an in-place instance. Passing an in-place instance is useful if we want to customize the built-in pipe's behavior by passing options:"
Title,typescript
Title,@Get(':id')
Title,async findOne(
Title,"@Param('id', new ParseIntPipe({ errorHttpStatusCode: HttpStatus.NOT_ACCEPTABLE }))"
Title,"id: number,"
Title,) {
Title,return this.catsService.findOne(id);
Title,}
Title,"Binding the other transformation pipes (all of the Parse* pipes) works similarly. These pipes all work in the context of validating route parameters, query string parameters and request body values."
Title,For example with a query string parameter:
Title,typescript
Title,@Get()
Title,"async findOne(@Query('id', ParseIntPipe) id: number) {"
Title,return this.catsService.findOne(id);
Title,}
Title,Here's an example of using the ParseUUIDPipe to parse a string parameter and validate if it is a UUID.
Title,typescript
Title,@@filename()
Title,@Get(':uuid')
Title,"async findOne(@Param('uuid', new ParseUUIDPipe()) uuid: string) {"
Title,return this.catsService.findOne(uuid);
Title,}
Title,@@switch
Title,@Get(':uuid')
Title,"@Bind(Param('uuid', new ParseUUIDPipe()))"
Title,async findOne(uuid) {
Title,return this.catsService.findOne(uuid);
Title,}
Title,
Title,"info Hint When using ParseUUIDPipe() you are parsing UUID in version 3, 4 or 5, if you only require a specific version of UUID you can pass a version in the pipe options."
Title,
Title,Above we've seen examples of binding the various Parse* family of built-in pipes. Binding validation pipes is a little bit different; we'll discuss that in the following section.
Title,
Title,"info Hint Also, see Validation techniques for extensive examples of validation pipes."
Title,
Title,Custom pipes
Title,"As mentioned, you can build your own custom pipes. While Nest provides a robust built-in ParseIntPipe and ValidationPipe, let's build simple custom versions of each from scratch to see how custom pipes are constructed."
Title,"We start with a simple ValidationPipe. Initially, we'll have it simply take an input value and immediately return the same value, behaving like an identity function."
Title,```typescript
Title,@@filename(validation.pipe)
Title,"import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';"
Title,@Injectable()
Title,export class ValidationPipe implements PipeTransform {
Title,"transform(value: any, metadata: ArgumentMetadata) {"
Title,return value;
Title,}
Title,}
Title,@@switch
Title,import { Injectable } from '@nestjs/common';
Title,@Injectable()
Title,export class ValidationPipe {
Title,"transform(value, metadata) {"
Title,return value;
Title,}
Title,}
Title,```
Title,
Title,"info Hint PipeTransform<T, R> is a generic interface that must be implemented by any pipe. The generic interface uses T to indicate the type of the input value, and R to indicate the return type of the transform() method."
Title,
Title,Every pipe must implement the transform() method to fulfill the PipeTransform interface contract. This method has two parameters:
Title,
Title,value
Title,metadata
Title,
Title,"The value parameter is the currently processed method argument (before it is received by the route handling method), and metadata is the currently processed method argument's metadata. The metadata object has these properties:"
Title,typescript
Title,export interface ArgumentMetadata {
Title,type: 'body' | 'query' | 'param' | 'custom';
Title,metatype?: Type<unknown>;
Title,data?: string;
Title,}
Title,These properties describe the currently processed argument.
Title,
Title,
Title,
Title,type
Title,
Title,Indicates whether the argument is a body
Title,"@Body(), query"
Title,"@Query(), param"
Title,"@Param(), or a custom parameter (read more"
Title,here).
Title,
Title,
Title,
Title,metatype
Title,
Title,
Title,"Provides the metatype of the argument, for example,"
Title,String. Note: the value is
Title,"undefined if you either omit a type declaration in the route handler method signature, or use vanilla JavaScript."
Title,
Title,
Title,
Title,
Title,data
Title,
Title,"The string passed to the decorator, for example"
Title,@Body('string'). It's
Title,undefined if you leave the decorator parenthesis empty.
Title,
Title,
Title,
Title,"warning Warning TypeScript interfaces disappear during transpilation. Thus, if a method parameter's type is declared as an interface instead of a class, the metatype value will be Object."
Title,
Title,Schema based validation
Title,"Let's make our validation pipe a little more useful. Take a closer look at the create() method of the CatsController, where we probably would like to ensure that the post body object is valid before attempting to run our service method."
Title,typescript
Title,@@filename()
Title,@Post()
Title,async create(@Body() createCatDto: CreateCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,@@switch
Title,@Post()
Title,async create(@Body() createCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,Let's focus in on the createCatDto body parameter. Its type is CreateCatDto:
Title,typescript
Title,@@filename(create-cat.dto)
Title,export class CreateCatDto {
Title,name: string;
Title,age: number;
Title,breed: string;
Title,}
Title,"We want to ensure that any incoming request to the create method contains a valid body. So we have to validate the three members of the createCatDto object. We could do this inside the route handler method, but doing so is not ideal as it would break the single responsibility principle (SRP)."
Title,Another approach could be to create a validator class and delegate the task there. This has the disadvantage that we would have to remember to call this validator at the beginning of each method.
Title,"How about creating validation middleware? This could work, but unfortunately, it's not possible to create generic middleware which can be used across all contexts across the whole application. This is because middleware is unaware of the execution context, including the handler that will be called and any of its parameters."
Title,"This is, of course, exactly the use case for which pipes are designed. So let's go ahead and refine our validation pipe."
Title,
Title,Object schema validation
Title,"There are several approaches available for doing object validation in a clean, DRY way. One common approach is to use schema-based validation. Let's go ahead and try that approach."
Title,"The Zod library allows you to create schemas in a straightforward way, with a readable API. Let's build a validation pipe that makes use of Zod-based schemas."
Title,Start by installing the required package:
Title,bash
Title,$ npm install --save zod
Title,"In the code sample below, we create a simple class that takes a schema as a constructor argument. We then apply the schema.parse() method, which validates our incoming argument against the provided schema."
Title,"As noted earlier, a validation pipe either returns the value unchanged or throws an exception."
Title,"In the next section, you'll see how we supply the appropriate schema for a given controller method using the @UsePipes() decorator. Doing so makes our validation pipe reusable across contexts, just as we set out to do."
Title,```typescript
Title,@@filename()
Title,"import { PipeTransform, ArgumentMetadata, BadRequestException } from '@nestjs/common';"
Title,import { ZodSchema  } from 'zod';
Title,export class ZodValidationPipe implements PipeTransform {
Title,constructor(private schema: ZodSchema) {}
Title,"transform(value: unknown, metadata: ArgumentMetadata) {"
Title,try {
Title,const parsedValue = this.schema.parse(value);
Title,return parsedValue;
Title,} catch (error) {
Title,throw new BadRequestException('Validation failed');
Title,}
Title,}
Title,}
Title,@@switch
Title,import { BadRequestException } from '@nestjs/common';
Title,export class ZodValidationPipe {
Title,constructor(private schema) {}
Title,"transform(value, metadata) {"
Title,try {
Title,const parsedValue = this.schema.parse(value);
Title,return parsedValue;
Title,} catch (error) {
Title,throw new BadRequestException('Validation failed');
Title,}
Title,}
Title,}
Title,```
Title,Binding validation pipes
Title,"Earlier, we saw how to bind transformation pipes (like ParseIntPipe and the rest of the Parse* pipes)."
Title,Binding validation pipes is also very straightforward.
Title,"In this case, we want to bind the pipe at the method call level. In our current example, we need to do the following to use the ZodValidationPipe:"
Title,
Title,Create an instance of the ZodValidationPipe
Title,Pass the context-specific Zod schema in the class constructor of the pipe
Title,Bind the pipe to the method
Title,
Title,Zod schema example:
Title,```typescript
Title,import { z } from 'zod';
Title,export const createCatSchema = z
Title,.object({
Title,"name: z.string(),"
Title,"age: z.number(),"
Title,"breed: z.string(),"
Title,})
Title,.required();
Title,export type CreateCatDto = z.infer;
Title,```
Title,We do that using the @UsePipes() decorator as shown below:
Title,typescript
Title,@@filename(cats.controller)
Title,@Post()
Title,@UsePipes(new ZodValidationPipe(createCatSchema))
Title,async create(@Body() createCatDto: CreateCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,@@switch
Title,@Post()
Title,@Bind(Body())
Title,@UsePipes(new ZodValidationPipe(createCatSchema))
Title,async create(createCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,
Title,info Hint The @UsePipes() decorator is imported from the @nestjs/common package.
Title,warning Warning zod library requires the strictNullChecks configuration to be enabled in your tsconfig.json file.
Title,
Title,Class validator
Title,
Title,warning Warning The techniques in this section require TypeScript and are not available if your app is written using vanilla JavaScript.
Title,
Title,Let's look at an alternate implementation for our validation technique.
Title,"Nest works well with the class-validator library. This powerful library allows you to use decorator-based validation. Decorator-based validation is extremely powerful, especially when combined with Nest's Pipe capabilities since we have access to the metatype of the processed property. Before we start, we need to install the required packages:"
Title,bash
Title,$ npm i --save class-validator class-transformer
Title,"Once these are installed, we can add a few decorators to the CreateCatDto class. Here we see a significant advantage of this technique: the CreateCatDto class remains the single source of truth for our Post body object (rather than having to create a separate validation class)."
Title,```typescript
Title,@@filename(create-cat.dto)
Title,"import { IsString, IsInt } from 'class-validator';"
Title,export class CreateCatDto {
Title,@IsString()
Title,name: string;
Title,@IsInt()
Title,age: number;
Title,@IsString()
Title,breed: string;
Title,}
Title,```
Title,
Title,info Hint Read more about the class-validator decorators here.
Title,
Title,Now we can create a ValidationPipe class that uses these annotations.
Title,```typescript
Title,@@filename(validation.pipe)
Title,"import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';"
Title,import { validate } from 'class-validator';
Title,import { plainToInstance } from 'class-transformer';
Title,@Injectable()
Title,export class ValidationPipe implements PipeTransform {
Title,"async transform(value: any, { metatype }: ArgumentMetadata) {"
Title,if (!metatype || !this.toValidate(metatype)) {
Title,return value;
Title,}
Title,"const object = plainToInstance(metatype, value);"
Title,const errors = await validate(object);
Title,if (errors.length > 0) {
Title,throw new BadRequestException('Validation failed');
Title,}
Title,return value;
Title,}
Title,private toValidate(metatype: Function): boolean {
Title,"const types: Function[] = [String, Boolean, Number, Array, Object];"
Title,return !types.includes(metatype);
Title,}
Title,}
Title,```
Title,
Title,"info Hint As a reminder, you don't have to build a generic validation pipe on your own since the ValidationPipe is provided by Nest out-of-the-box. The built-in ValidationPipe offers more options than the sample we built in this chapter, which has been kept basic for the sake of illustrating the mechanics of a custom-built pipe. You can find full details, along with lots of examples here."
Title,"warning Notice We used the class-transformer library above which is made by the same author as the class-validator library, and as a result, they play very well together."
Title,
Title,"Let's go through this code. First, note that the transform() method is marked as async. This is possible because Nest supports both synchronous and asynchronous pipes. We make this method async because some of the class-validator validations can be async (utilize Promises)."
Title,Next note that we are using destructuring to extract the metatype field (extracting just this member from an ArgumentMetadata) into our metatype parameter. This is just shorthand for getting the full ArgumentMetadata and then having an additional statement to assign the metatype variable.
Title,"Next, note the helper function toValidate(). It's responsible for bypassing the validation step when the current argument being processed is a native JavaScript type (these can't have validation decorators attached, so there's no reason to run them through the validation step)."
Title,"Next, we use the class-transformer function plainToInstance() to transform our plain JavaScript argument object into a typed object so that we can apply validation. The reason we must do this is that the incoming post body object, when deserialized from the network request, does not have any type information (this is the way the underlying platform, such as Express, works). Class-validator needs to use the validation decorators we defined for our DTO earlier, so we need to perform this transformation to treat the incoming body as an appropriately decorated object, not just a plain vanilla object."
Title,"Finally, as noted earlier, since this is a validation pipe it either returns the value unchanged, or throws an exception."
Title,"The last step is to bind the ValidationPipe. Pipes can be parameter-scoped, method-scoped, controller-scoped, or global-scoped. Earlier, with our Zod-based validation pipe, we saw an example of binding the pipe at the method level."
Title,"In the example below, we'll bind the pipe instance to the route handler @Body() decorator so that our pipe is called to validate the post body."
Title,typescript
Title,@@filename(cats.controller)
Title,@Post()
Title,async create(
Title,"@Body(new ValidationPipe()) createCatDto: CreateCatDto,"
Title,) {
Title,this.catsService.create(createCatDto);
Title,}
Title,Parameter-scoped pipes are useful when the validation logic concerns only one specified parameter.
Title,Global scoped pipes
Title,"Since the ValidationPipe was created to be as generic as possible, we can realize its full utility by setting it up as a global-scoped pipe so that it is applied to every route handler across the entire application."
Title,typescript
Title,@@filename(main)
Title,async function bootstrap() {
Title,const app = await NestFactory.create(AppModule);
Title,app.useGlobalPipes(new ValidationPipe());
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,bootstrap();
Title,
Title,"warning Notice In the case of hybrid apps the useGlobalPipes() method doesn't set up pipes for gateways and microservices. For ""standard"" (non-hybrid) microservice apps, useGlobalPipes() does mount pipes globally."
Title,
Title,"Global pipes are used across the whole application, for every controller and every route handler."
Title,"Note that in terms of dependency injection, global pipes registered from outside of any module (with useGlobalPipes() as in the example above) cannot inject dependencies since the binding has been done outside the context of any module. In order to solve this issue, you can set up a global pipe directly from any module using the following construction:"
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { APP_PIPE } from '@nestjs/core';
Title,@Module({
Title,providers: [
Title,{
Title,"provide: APP_PIPE,"
Title,"useClass: ValidationPipe,"
Title,"},"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,
Title,"info Hint When using this approach to perform dependency injection for the pipe, note that regardless of the module where this construction is employed, the pipe is, in fact, global. Where should this be done? Choose the module where the pipe (ValidationPipe in the example above) is defined. Also, useClass is not the only way of dealing with custom provider registration. Learn more here."
Title,
Title,The built-in ValidationPipe
Title,"As a reminder, you don't have to build a generic validation pipe on your own since the ValidationPipe is provided by Nest out-of-the-box. The built-in ValidationPipe offers more options than the sample we built in this chapter, which has been kept basic for the sake of illustrating the mechanics of a custom-built pipe. You can find full details, along with lots of examples here."
Title,Transformation use case
Title,"Validation isn't the only use case for custom pipes. At the beginning of this chapter, we mentioned that a pipe can also transform the input data to the desired format. This is possible because the value returned from the transform function completely overrides the previous value of the argument."
Title,"When is this useful? Consider that sometimes the data passed from the client needs to undergo some change - for example converting a string to an integer - before it can be properly handled by the route handler method. Furthermore, some required data fields may be missing, and we would like to apply default values. Transformation pipes can perform these functions by interposing a processing function between the client request and the request handler."
Title,"Here's a simple ParseIntPipe which is responsible for parsing a string into an integer value. (As noted above, Nest has a built-in ParseIntPipe that is more sophisticated; we include this as a simple example of a custom transformation pipe)."
Title,```typescript
Title,@@filename(parse-int.pipe)
Title,"import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';"
Title,@Injectable()
Title,export class ParseIntPipe implements PipeTransform {
Title,"transform(value: string, metadata: ArgumentMetadata): number {"
Title,"const val = parseInt(value, 10);"
Title,if (isNaN(val)) {
Title,throw new BadRequestException('Validation failed');
Title,}
Title,return val;
Title,}
Title,}
Title,@@switch
Title,"import { Injectable, BadRequestException } from '@nestjs/common';"
Title,@Injectable()
Title,export class ParseIntPipe {
Title,"transform(value, metadata) {"
Title,"const val = parseInt(value, 10);"
Title,if (isNaN(val)) {
Title,throw new BadRequestException('Validation failed');
Title,}
Title,return val;
Title,}
Title,}
Title,```
Title,We can then bind this pipe to the selected param as shown below:
Title,typescript
Title,@@filename()
Title,@Get(':id')
Title,"async findOne(@Param('id', new ParseIntPipe()) id) {"
Title,return this.catsService.findOne(id);
Title,}
Title,@@switch
Title,@Get(':id')
Title,"@Bind(Param('id', new ParseIntPipe()))"
Title,async findOne(id) {
Title,return this.catsService.findOne(id);
Title,}
Title,Another useful transformation case would be to select an existing user entity from the database using an id supplied in the request:
Title,typescript
Title,@@filename()
Title,@Get(':id')
Title,"findOne(@Param('id', UserByIdPipe) userEntity: UserEntity) {"
Title,return userEntity;
Title,}
Title,@@switch
Title,@Get(':id')
Title,"@Bind(Param('id', UserByIdPipe))"
Title,findOne(userEntity) {
Title,return userEntity;
Title,}
Title,"We leave the implementation of this pipe to the reader, but note that like all other transformation pipes, it receives an input value (an id) and returns an output value (a UserEntity object). This can make your code more declarative and DRY by abstracting boilerplate code out of your handler and into a common pipe."
Title,Providing defaults
Title,"Parse* pipes expect a parameter's value to be defined. They throw an exception upon receiving null or undefined values. To allow an endpoint to handle missing querystring parameter values, we have to provide a default value to be injected before the Parse* pipes operate on these values. The DefaultValuePipe serves that purpose. Simply instantiate a DefaultValuePipe in the @Query() decorator before the relevant Parse* pipe, as shown below:"
Title,typescript
Title,@@filename()
Title,@Get()
Title,async findAll(
Title,"@Query('activeOnly', new DefaultValuePipe(false), ParseBoolPipe) activeOnly: boolean,"
Title,"@Query('page', new DefaultValuePipe(0), ParseIntPipe) page: number,"
Title,) {
Title,"return this.catsService.findAll({ activeOnly, page });"
Title,}
Title,
Title,Async Local Storage
Title,AsyncLocalStorage is a Node.js API (based on the async_hooks API) that provides an alternative way of propagating local state through the application without the need to explicitly pass it as a function parameter. It is similar to a thread-local storage in other languages.
Title,"The main idea of Async Local Storage is that we can wrap some function call with the AsyncLocalStorage#run call. All code that is invoked within the wrapped call gets access to the same store, which will be unique to each call chain."
Title,"In the context of NestJS, that means if we can find a place within the request's lifecycle where we can wrap the rest of the request's code, we will be able to access and modify state visible only to that request, which may serve as an alternative to REQUEST-scoped providers and some of their limitations."
Title,"Alternatively, we can use ALS to propagate context for only a part of the system (for example the transaction object) without passing it around explicitly across services, which can increase isolation and encapsulation."
Title,Custom implementation
Title,"NestJS itself does not provide any built-in abstraction for AsyncLocalStorage, so let's walk through how we could implement it ourselves for the simplest HTTP case to get a better understanding of the whole concept:"
Title,
Title,"info info For a ready-made dedicated package, continue reading below."
Title,
Title,
Title,"First, create a new instance of the AsyncLocalStorage in some shared source file. Since we're using NestJS, let's also turn it into a module with a custom provider."
Title,
Title,ts
Title,@@filename(als.module)
Title,@Module({
Title,providers: [
Title,{
Title,"provide: AsyncLocalStorage,"
Title,"useValue: new AsyncLocalStorage(),"
Title,"},"
Title,"],"
Title,"exports: [AsyncLocalStorage],"
Title,})
Title,export class AlsModule {}
Title,
Title,info Hint AsyncLocalStorage is imported from async_hooks.
Title,
Title,
Title,"We're only concerned with HTTP, so let's use a middleware to wrap the next function with AsyncLocalStorage#run. Since a middleware is the first thing that the request hits, this will make the store available in all enhancers and the rest of the system."
Title,
Title,```ts
Title,@@filename(app.module)
Title,@Module({
Title,imports: [AlsModule]
Title,"providers: [CatService],"
Title,"controllers: [CatController],"
Title,})
Title,export class AppModule implements NestModule {
Title,constructor(
Title,"// inject the AsyncLocalStorage in the module constructor,"
Title,private readonly als: AsyncLocalStorage
Title,) {}
Title,configure(consumer: MiddlewareConsumer) {
Title,"// bind the middleware,"
Title,consumer
Title,".apply((req, res, next) => {"
Title,// populate the store with some default values
Title,"// based on the request,"
Title,const store = {
Title,"userId: req.headers['x-user-id'],"
Title,};
Title,"// and pass the ""next"" function as callback"
Title,"// to the ""als.run"" method together with the store."
Title,"this.als.run(store, () => next());"
Title,})
Title,// and register it for all routes (in case of Fastify use '(.)')
Title,.forRoutes('');
Title,}
Title,}
Title,@@switch
Title,@Module({
Title,imports: [AlsModule]
Title,"providers: [CatService],"
Title,"controllers: [CatController],"
Title,})
Title,@Dependencies(AsyncLocalStorage)
Title,export class AppModule {
Title,constructor(als) {
Title,"// inject the AsyncLocalStorage in the module constructor,"
Title,this.als = als
Title,}
Title,configure(consumer) {
Title,"// bind the middleware,"
Title,consumer
Title,".apply((req, res, next) => {"
Title,// populate the store with some default values
Title,"// based on the request,"
Title,const store = {
Title,"userId: req.headers['x-user-id'],"
Title,};
Title,"// and pass the ""next"" function as callback"
Title,"// to the ""als.run"" method together with the store."
Title,"this.als.run(store, () => next());"
Title,})
Title,// and register it for all routes (in case of Fastify use '(.)')
Title,.forRoutes('');
Title,}
Title,}
Title,```
Title,
Title,"Now, anywhere within the lifecycle of a request, we can access the local store instance."
Title,
Title,```ts
Title,@@filename(cat.service)
Title,@Injectable()
Title,export class CatService {
Title,constructor(
Title,// We can inject the provided ALS instance.
Title,"private readonly als: AsyncLocalStorage,"
Title,"private readonly catRepository: CatRepository,"
Title,) {}
Title,getCatForUser() {
Title,"// The ""getStore"" method will always return the"
Title,// store instance associated with the given request.
Title,"const userId = this.als.getStore()[""userId""] as number;"
Title,return this.catRepository.getForUser(userId);
Title,}
Title,}
Title,@@switch
Title,@Injectable()
Title,"@Dependencies(AsyncLocalStorage, CatRepository)"
Title,export class CatService {
Title,"constructor(als, catRepository) {"
Title,// We can inject the provided ALS instance.
Title,this.als = als
Title,this.catRepository = catRepository
Title,}
Title,getCatForUser() {
Title,"// The ""getStore"" method will always return the"
Title,// store instance associated with the given request.
Title,"const userId = this.als.getStore()[""userId""] as number;"
Title,return this.catRepository.getForUser(userId);
Title,}
Title,}
Title,```
Title,
Title,That's it. Now we have a way to share request related state without needing to inject the whole REQUEST object.
Title,
Title,
Title,"warning warning Please be aware that while the technique is useful for many use-cases, it inherently obfuscates the code flow (creating implicit context), so use it responsibly and especially avoid creating contextual ""God objects""."
Title,
Title,NestJS CLS
Title,"The nestjs-cls package provides several DX improvements over using plain AsyncLocalStorage (CLS is an abbreviation of the term continuation-local storage). It abstracts the implementation into a ClsModule that offers various ways of initializing the store for different transports (not only HTTP), as well as a strong-typing support."
Title,"The store can then be accessed with an injectable ClsService, or entirely abstracted away from the business logic by using Proxy Providers."
Title,
Title,"info info nestjs-cls is a third party package and is not managed by the NestJS core team. Please, report any issues found with the library in the appropriate repository."
Title,
Title,Installation
Title,"Apart from a peer dependency on the @nestjs libs, it only uses the built-in Node.js API. Install it as any other package."
Title,bash
Title,npm i nestjs-cls
Title,Usage
Title,A similar functionality as described above can be implemented using nestjs-cls as follows:
Title,
Title,Import the ClsModule in the root module.
Title,
Title,ts
Title,@@filename(app.module)
Title,@Module({
Title,imports: [
Title,"// Register the ClsModule,"
Title,ClsModule.forRoot({
Title,middleware: {
Title,// automatically mount the
Title,// ClsMiddleware for all routes
Title,"mount: true,"
Title,// and use the setup method to
Title,// provide default store values.
Title,"setup: (cls, req) => {"
Title,"cls.set('userId', req.headers['x-user-id']);"
Title,"},"
Title,"},"
Title,"}),"
Title,"],"
Title,"providers: [CatService],"
Title,"controllers: [CatController],"
Title,})
Title,export class AppModule {}
Title,
Title,And then can use the ClsService to access the store values.
Title,
Title,```ts
Title,@@filename(cat.service)
Title,@Injectable()
Title,export class CatService {
Title,constructor(
Title,"// We can inject the provided ClsService instance,"
Title,"private readonly cls: ClsService,"
Title,"private readonly catRepository: CatRepository,"
Title,) {}
Title,getCatForUser() {
Title,"// and use the ""get"" method to retrieve any stored value."
Title,const userId = this.cls.get('userId');
Title,return this.catRepository.getForUser(userId);
Title,}
Title,}
Title,@@switch
Title,@Injectable()
Title,"@Dependencies(AsyncLocalStorage, CatRepository)"
Title,export class CatService {
Title,"constructor(cls, catRepository) {"
Title,"// We can inject the provided ClsService instance,"
Title,this.cls = cls
Title,this.catRepository = catRepository
Title,}
Title,getCatForUser() {
Title,"// and use the ""get"" method to retrieve any stored value."
Title,const userId = this.cls.get('userId');
Title,return this.catRepository.getForUser(userId);
Title,}
Title,}
Title,```
Title,
Title,"To get strong typing of the store values managed by the ClsService (and also get auto-suggestions of the string keys), we can use an optional type parameter ClsService<MyClsStore> when injecting it."
Title,
Title,ts
Title,export interface MyClsStore extends ClsStore {
Title,userId: number;
Title,}
Title,
Title,"info hint It it also possible to let the package automatically generate a Request ID and access it later with cls.getId(), or to get the whole Request object using cls.get(CLS_REQ)."
Title,
Title,Testing
Title,"Since the ClsService is just another injectable provider, it can be entirely mocked out in unit tests."
Title,"However, in certain integration tests, we might still want to use the real ClsService implementation. In that case, we will need to wrap the context-aware piece of code with a call to ClsService#run or ClsService#runWith."
Title,```ts
Title,"describe('CatService', () => {"
Title,let service: CatService
Title,let cls: ClsService
Title,const mockCatRepository = createMock()
Title,beforeEach(async () => {
Title,const module = await Test.createTestingModule({
Title,// Set up most of the testing module as we normally would.
Title,providers: [
Title,"CatService,"
Title,{
Title,provide: CatRepository
Title,useValue: mockCatRepository
Title,}
Title,"],"
Title,imports: [
Title,// Import the static version of ClsModule which only provides
Title,"// the ClsService, but does not set up the store in any way."
Title,ClsModule
Title,"],"
Title,}).compile()
Title,service = module.get(CatService)
Title,
Title,// Also retrieve the ClsService for later use.
Title,cls = module.get(ClsService)
Title,
Title,})
Title,"describe('getCatForUser', () => {"
Title,"it('retrieves cat based on user id', async () => {"
Title,const expectedUserId = 42
Title,mockCatRepository.getForUser.mockImplementationOnce(
Title,(id) => ({ userId: id })
Title,)
Title,// Wrap the test call in the `runWith` method
Title,// in which we can pass hand-crafted store values.
Title,const cat = await cls.runWith(
Title,"{ userId: expectedUserId },"
Title,() => service.getCatForUser()
Title,)
Title,
Title,expect(cat.userId).toEqual(expectedUserId)
Title,})
Title,
Title,})
Title,})
Title,```
Title,More information
Title,Visit the NestJS CLS GitHub Page for the full API documentation and more code examples.
Title,
Title,CQRS
Title,"The flow of simple CRUD (Create, Read, Update and Delete) applications can be described as follows:"
Title,
Title,The controllers layer handles HTTP requests and delegates tasks to the services layer.
Title,The services layer is where most of the business logic lives.
Title,Services use repositories / DAOs to change / persist entities.
Title,"Entities act as containers for the values, with setters and getters."
Title,
Title,"While this pattern is usually sufficient for small and medium-sized applications, it may not be the best choice for larger, more complex applications. In such cases, the CQRS (Command and Query Responsibility Segregation) model may be more appropriate and scalable (depending on the application's requirements). Benefits of this model include:"
Title,
Title,Separation of concerns. The model separates the read and write operations into separate models.
Title,Scalability. The read and write operations can be scaled independently.
Title,Flexibility. The model allows for the use of different data stores for read and write operations.
Title,Performance. The model allows for the use of different data stores optimized for read and write operations.
Title,
Title,"To facilitate that model, Nest provides a lightweight CQRS module. This chapter describes how to use it."
Title,Installation
Title,First install the required package:
Title,bash
Title,$ npm install --save @nestjs/cqrs
Title,Commands
Title,"Commands are used to change the application state. They should be task-based, rather than data centric. When a command is dispatched, it is handled by a corresponding Command Handler. The handler is responsible for updating the application state."
Title,```typescript
Title,@@filename(heroes-game.service)
Title,@Injectable()
Title,export class HeroesGameService {
Title,constructor(private commandBus: CommandBus) {}
Title,"async killDragon(heroId: string, killDragonDto: KillDragonDto) {"
Title,return this.commandBus.execute(
Title,"new KillDragonCommand(heroId, killDragonDto.dragonId)"
Title,);
Title,}
Title,}
Title,@@switch
Title,@Injectable()
Title,@Dependencies(CommandBus)
Title,export class HeroesGameService {
Title,constructor(commandBus) {
Title,this.commandBus = commandBus;
Title,}
Title,"async killDragon(heroId, killDragonDto) {"
Title,return this.commandBus.execute(
Title,"new KillDragonCommand(heroId, killDragonDto.dragonId)"
Title,);
Title,}
Title,}
Title,```
Title,"In the code snippet above, we instantiate the KillDragonCommand class and pass it to the CommandBus's execute() method. This is the demonstrated command class:"
Title,typescript
Title,@@filename(kill-dragon.command)
Title,export class KillDragonCommand {
Title,constructor(
Title,"public readonly heroId: string,"
Title,"public readonly dragonId: string,"
Title,) {}
Title,}
Title,@@switch
Title,export class KillDragonCommand {
Title,"constructor(heroId, dragonId) {"
Title,this.heroId = heroId;
Title,this.dragonId = dragonId;
Title,}
Title,}
Title,"The CommandBus represents a stream of commands. It is responsible for dispatching commands to the appropriate handlers. The execute() method returns a promise, which resolves to the value returned by the handler."
Title,Let's create a handler for the KillDragonCommand command.
Title,```typescript
Title,@@filename(kill-dragon.handler)
Title,@CommandHandler(KillDragonCommand)
Title,export class KillDragonHandler implements ICommandHandler {
Title,constructor(private repository: HeroRepository) {}
Title,async execute(command: KillDragonCommand) {
Title,"const { heroId, dragonId } = command;"
Title,const hero = this.repository.findOneById(+heroId);
Title,hero.killEnemy(dragonId);
Title,await this.repository.persist(hero);
Title,
Title,}
Title,}
Title,@@switch
Title,@CommandHandler(KillDragonCommand)
Title,@Dependencies(HeroRepository)
Title,export class KillDragonHandler {
Title,constructor(repository) {
Title,this.repository = repository;
Title,}
Title,async execute(command) {
Title,"const { heroId, dragonId } = command;"
Title,const hero = this.repository.findOneById(+heroId);
Title,hero.killEnemy(dragonId);
Title,await this.repository.persist(hero);
Title,
Title,}
Title,}
Title,```
Title,"This handler retrieves the Hero entity from the repository, calls the killEnemy() method, and then persists the changes. The KillDragonHandler class implements the ICommandHandler interface, which requires the implementation of the execute() method. The execute() method receives the command object as an argument."
Title,Queries
Title,"Queries are used to retrieve data from the application state. They should be data centric, rather than task-based. When a query is dispatched, it is handled by a corresponding Query Handler. The handler is responsible for retrieving the data."
Title,The QueryBus follows the same pattern as the CommandBus. Query handlers should implement the IQueryHandler interface and be annotated with the @QueryHandler() decorator.
Title,Events
Title,"Events are used to notify other parts of the application about changes in the application state. They are dispatched by models or directly using the EventBus. When an event is dispatched, it is handled by corresponding Event Handlers. Handlers can then, for example, update the read model."
Title,"For demonstration purposes, let's create an event class:"
Title,typescript
Title,@@filename(hero-killed-dragon.event)
Title,export class HeroKilledDragonEvent {
Title,constructor(
Title,"public readonly heroId: string,"
Title,"public readonly dragonId: string,"
Title,) {}
Title,}
Title,@@switch
Title,export class HeroKilledDragonEvent {
Title,"constructor(heroId, dragonId) {"
Title,this.heroId = heroId;
Title,this.dragonId = dragonId;
Title,}
Title,}
Title,"Now while events can be dispatched directly using the EventBus.publish() method, we can also dispatch them from the model. Let's update the Hero model to dispatch the HeroKilledDragonEvent event when the killEnemy() method is called."
Title,```typescript
Title,@@filename(hero.model)
Title,export class Hero extends AggregateRoot {
Title,constructor(private id: string) {
Title,super();
Title,}
Title,killEnemy(enemyId: string) {
Title,// Business logic
Title,"this.apply(new HeroKilledDragonEvent(this.id, enemyId));"
Title,}
Title,}
Title,@@switch
Title,export class Hero extends AggregateRoot {
Title,constructor(id) {
Title,super();
Title,this.id = id;
Title,}
Title,killEnemy(enemyId) {
Title,// Business logic
Title,"this.apply(new HeroKilledDragonEvent(this.id, enemyId));"
Title,}
Title,}
Title,```
Title,"The apply() method is used to dispatch events. It accepts an event object as an argument. However, since our model is not aware of the EventBus, we need to associate it with the model. We can do that by using the EventPublisher class."
Title,```typescript
Title,@@filename(kill-dragon.handler)
Title,@CommandHandler(KillDragonCommand)
Title,export class KillDragonHandler implements ICommandHandler {
Title,constructor(
Title,"private repository: HeroRepository,"
Title,"private publisher: EventPublisher,"
Title,) {}
Title,async execute(command: KillDragonCommand) {
Title,"const { heroId, dragonId } = command;"
Title,const hero = this.publisher.mergeObjectContext(
Title,"await this.repository.findOneById(+heroId),"
Title,);
Title,hero.killEnemy(dragonId);
Title,hero.commit();
Title,}
Title,}
Title,@@switch
Title,@CommandHandler(KillDragonCommand)
Title,"@Dependencies(HeroRepository, EventPublisher)"
Title,export class KillDragonHandler {
Title,"constructor(repository, publisher) {"
Title,this.repository = repository;
Title,this.publisher = publisher;
Title,}
Title,async execute(command) {
Title,"const { heroId, dragonId } = command;"
Title,const hero = this.publisher.mergeObjectContext(
Title,"await this.repository.findOneById(+heroId),"
Title,);
Title,hero.killEnemy(dragonId);
Title,hero.commit();
Title,}
Title,}
Title,```
Title,"The EventPublisher#mergeObjectContext method merges the event publisher into the provided object, which means that the object will now be able to publish events to the events stream."
Title,"Notice that in this example we also call the commit() method on the model. This method is used to dispatch any outstanding events. To automatically dispatch events, we can set the autoCommit property to true:"
Title,typescript
Title,export class Hero extends AggregateRoot {
Title,constructor(private id: string) {
Title,super();
Title,this.autoCommit = true;
Title,}
Title,}
Title,"In case we want to merge the event publisher into a non-existing object, but rather into a class, we can use the EventPublisher#mergeClassContext method:"
Title,typescript
Title,const HeroModel = this.publisher.mergeClassContext(Hero);
Title,const hero = new HeroModel('id'); // <-- HeroModel is a class
Title,Now every instance of the HeroModel class will be able to publish events without using mergeObjectContext() method.
Title,"Additionally, we can emit events manually using EventBus:"
Title,typescript
Title,this.eventBus.publish(new HeroKilledDragonEvent());
Title,
Title,info Hint The EventBus is an injectable class.
Title,
Title,Each event can have multiple Event Handlers.
Title,```typescript
Title,@@filename(hero-killed-dragon.handler)
Title,@EventsHandler(HeroKilledDragonEvent)
Title,export class HeroKilledDragonHandler implements IEventHandler {
Title,constructor(private repository: HeroRepository) {}
Title,handle(event: HeroKilledDragonEvent) {
Title,// Business logic
Title,}
Title,}
Title,```
Title,
Title,info Hint Be aware that when you start using event handlers you get out of the traditional HTTP web context.
Title,
Title,Errors in CommandHandlers can still be caught by built-in Exception filters.
Title,"Errors in EventHandlers can't be caught by Exception filters: you will have to handle them manually. Either by a simple try/catch, using Sagas by triggering a compensating event, or whatever other solution you choose."
Title,HTTP Responses in CommandHandlers can still be sent back to the client.
Title,"HTTP Responses in EventHandlers cannot. If you want to send information to the client you could use WebSocket, SSE, or whatever other solution you choose."
Title,
Title,
Title,Sagas
Title,"Saga is a long-running process that listens to events and may trigger new commands. It is usually used to manage complex workflows in the application. For example, when a user signs up, a saga may listen to the UserRegisteredEvent and send a welcome email to the user."
Title,"Sagas are an extremely powerful feature. A single saga may listen for 1..* events. Using the RxJS library, we can filter, map, fork, and merge event streams to create sophisticated workflows. Each saga returns an Observable which produces a command instance. This command is then dispatched asynchronously by the CommandBus."
Title,Let's create a saga that listens to the HeroKilledDragonEvent and dispatches the DropAncientItemCommand command.
Title,typescript
Title,@@filename(heroes-game.saga)
Title,@Injectable()
Title,export class HeroesGameSagas {
Title,@Saga()
Title,dragonKilled = (events$: Observable<any>): Observable<ICommand> => {
Title,return events$.pipe(
Title,"ofType(HeroKilledDragonEvent),"
Title,"map((event) => new DropAncientItemCommand(event.heroId, fakeItemID)),"
Title,);
Title,}
Title,}
Title,@@switch
Title,@Injectable()
Title,export class HeroesGameSagas {
Title,@Saga()
Title,dragonKilled = (events$) => {
Title,return events$.pipe(
Title,"ofType(HeroKilledDragonEvent),"
Title,"map((event) => new DropAncientItemCommand(event.heroId, fakeItemID)),"
Title,);
Title,}
Title,}
Title,
Title,info Hint The ofType operator and the @Saga() decorator are exported from the @nestjs/cqrs package.
Title,
Title,The @Saga() decorator marks the method as a saga. The events$ argument is an Observable stream of all events. The ofType operator filters the stream by the specified event type. The map operator maps the event to a new command instance.
Title,"In this example, we map the HeroKilledDragonEvent to the DropAncientItemCommand command. The DropAncientItemCommand command is then auto-dispatched by the CommandBus."
Title,Setup
Title,"To wrap up, we need to register all command handlers, event handlers, and sagas in the HeroesGameModule:"
Title,```typescript
Title,@@filename(heroes-game.module)
Title,"export const CommandHandlers = [KillDragonHandler, DropAncientItemHandler];"
Title,"export const EventHandlers =  [HeroKilledDragonHandler, HeroFoundItemHandler];"
Title,@Module({
Title,"imports: [CqrsModule],"
Title,"controllers: [HeroesGameController],"
Title,providers: [
Title,"HeroesGameService,"
Title,"HeroesGameSagas,"
Title,"...CommandHandlers,"
Title,"...EventHandlers,"
Title,"HeroRepository,"
Title,]
Title,})
Title,export class HeroesGameModule {}
Title,```
Title,Unhandled exceptions
Title,"Event handlers are executed in the asynchronous manner. This means they should always handle all exceptions to prevent application from entering the inconsistent state. However, if an exception is not handled, the EventBus will create the UnhandledExceptionInfo object and push it to the UnhandledExceptionBus stream. This stream is an Observable which can be used to process unhandled exceptions."
Title,```typescript
Title,private destroy$ = new Subject();
Title,constructor(private unhandledExceptionsBus: UnhandledExceptionBus) {
Title,this.unhandledExceptionsBus
Title,.pipe(takeUntil(this.destroy$))
Title,.subscribe((exceptionInfo) => {
Title,// Handle exception here
Title,"// e.g. send it to external service, terminate process, or publish a new event"
Title,});
Title,}
Title,onModuleDestroy() {
Title,this.destroy$.next();
Title,this.destroy$.complete();
Title,}
Title,```
Title,"To filter out exceptions, we can use the ofType operator, as follows:"
Title,typescript
Title,"this.unhandledExceptionsBus.pipe(takeUntil(this.destroy$), UnhandledExceptionBus.ofType(TransactionNotAllowedException)).subscribe((exceptionInfo) => {"
Title,// Handle exception here
Title,});
Title,Where TransactionNotAllowedException is the exception we want to filter out.
Title,The UnhandledExceptionInfo object contains the following properties:
Title,typescript
Title,"export interface UnhandledExceptionInfo<Cause = IEvent | ICommand, Exception = any> {"
Title,/**
Title,* The exception that was thrown.
Title,*/
Title,exception: Exception;
Title,/**
Title,* The cause of the exception (event or command reference).
Title,*/
Title,cause: Cause;
Title,}
Title,Subscribing to all events
Title,"CommandBus, QueryBus and EventBus are all Observables. This means that we can subscribe to the entire stream and, for example, process all events. For example, we can log all events to the console, or save them to the event store."
Title,```typescript
Title,private destroy$ = new Subject();
Title,constructor(private eventBus: EventBus) {
Title,this.eventBus
Title,.pipe(takeUntil(this.destroy$))
Title,.subscribe((event) => {
Title,// Save events to database
Title,});
Title,}
Title,onModuleDestroy() {
Title,this.destroy$.next();
Title,this.destroy$.complete();
Title,}
Title,```
Title,Example
Title,A working example is available here.
Title,
Title,CRUD generator (TypeScript only)
Title,"Throughout the life span of a project, when we build new features, we often need to add new resources to our application. These resources typically require multiple, repetitive operations that we have to repeat each time we define a new resource."
Title,Introduction
Title,"Let's imagine a real-world scenario, where we need to expose CRUD endpoints for 2 entities, let's say User and Product entities."
Title,"Following the best practices, for each entity we would have to perform several operations, as follows:"
Title,
Title,Generate a module (nest g mo) to keep code organized and establish clear boundaries (grouping related components)
Title,Generate a controller (nest g co) to define CRUD routes (or queries/mutations for GraphQL applications)
Title,Generate a service (nest g s) to implement & isolate business logic
Title,Generate an entity class/interface to represent the resource data shape
Title,Generate Data Transfer Objects (or inputs for GraphQL applications) to define how the data will be sent over the network
Title,
Title,That's a lot of steps!
Title,"To help speed up this repetitive process, Nest CLI provides a generator (schematic) that automatically generates all the boilerplate code to help us avoid doing all of this, and make the developer experience much simpler."
Title,
Title,"info Note The schematic supports generating HTTP controllers, Microservice controllers, GraphQL resolvers (both code first and schema first), and WebSocket Gateways."
Title,
Title,Generating a new resource
Title,"To create a new resource, simply run the following command in the root directory of your project:"
Title,shell
Title,$ nest g resource
Title,"nest g resource command not only generates all the NestJS building blocks (module, service, controller classes) but also an entity class, DTO classes as well as the testing (.spec) files."
Title,Below you can see the generated controller file (for REST API):
Title,```typescript
Title,@Controller('users')
Title,export class UsersController {
Title,constructor(private readonly usersService: UsersService) {}
Title,@Post()
Title,create(@Body() createUserDto: CreateUserDto) {
Title,return this.usersService.create(createUserDto);
Title,}
Title,@Get()
Title,findAll() {
Title,return this.usersService.findAll();
Title,}
Title,@Get(':id')
Title,findOne(@Param('id') id: string) {
Title,return this.usersService.findOne(+id);
Title,}
Title,@Patch(':id')
Title,"update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {"
Title,"return this.usersService.update(+id, updateUserDto);"
Title,}
Title,@Delete(':id')
Title,remove(@Param('id') id: string) {
Title,return this.usersService.remove(+id);
Title,}
Title,}
Title,```
Title,"Also, it automatically creates placeholders for all the CRUD endpoints (routes for REST APIs, queries and mutations for GraphQL, message subscribes for both Microservices and WebSocket Gateways) - all without having to lift a finger."
Title,
Title,"warning Note Generated service classes are not tied to any specific ORM (or data source). This makes the generator generic enough to meet the needs of any project. By default, all methods will contain placeholders, allowing you to populate it with the data sources specific to your project."
Title,
Title,"Likewise, if you want to generate resolvers for a GraphQL application, simply select the GraphQL (code first) (or GraphQL (schema first)) as your transport layer."
Title,"In this case, NestJS will generate a resolver class instead of a REST API controller:"
Title,```shell
Title,$ nest g resource users
Title,
Title,? What transport layer do you use? GraphQL (code first)
Title,? Would you like to generate CRUD entry points? Yes
Title,CREATE src/users/users.module.ts (224 bytes)
Title,CREATE src/users/users.resolver.spec.ts (525 bytes)
Title,CREATE src/users/users.resolver.ts (1109 bytes)
Title,CREATE src/users/users.service.spec.ts (453 bytes)
Title,CREATE src/users/users.service.ts (625 bytes)
Title,CREATE src/users/dto/create-user.input.ts (195 bytes)
Title,CREATE src/users/dto/update-user.input.ts (281 bytes)
Title,CREATE src/users/entities/user.entity.ts (187 bytes)
Title,UPDATE src/app.module.ts (312 bytes)
Title,```
Title,"info Hint To avoid generating test files, you can pass the --no-spec flag, as follows: nest g resource users --no-spec"
Title,
Title,"We can see below, that not only were all boilerplate mutations and queries created, but everything is all tied together. We're utilizing the UsersService, User Entity, and our DTO's."
Title,```typescript
Title,"import { Resolver, Query, Mutation, Args, Int } from '@nestjs/graphql';"
Title,import { UsersService } from './users.service';
Title,import { User } from './entities/user.entity';
Title,import { CreateUserInput } from './dto/create-user.input';
Title,import { UpdateUserInput } from './dto/update-user.input';
Title,@Resolver(() => User)
Title,export class UsersResolver {
Title,constructor(private readonly usersService: UsersService) {}
Title,@Mutation(() => User)
Title,createUser(@Args('createUserInput') createUserInput: CreateUserInput) {
Title,return this.usersService.create(createUserInput);
Title,}
Title,"@Query(() => [User], { name: 'users' })"
Title,findAll() {
Title,return this.usersService.findAll();
Title,}
Title,"@Query(() => User, { name: 'user' })"
Title,"findOne(@Args('id', { type: () => Int }) id: number) {"
Title,return this.usersService.findOne(id);
Title,}
Title,@Mutation(() => User)
Title,updateUser(@Args('updateUserInput') updateUserInput: UpdateUserInput) {
Title,"return this.usersService.update(updateUserInput.id, updateUserInput);"
Title,}
Title,@Mutation(() => User)
Title,"removeUser(@Args('id', { type: () => Int }) id: number) {"
Title,return this.usersService.remove(id);
Title,}
Title,}
Title,```
Title,
Title,Documentation
Title,"Compodoc is a documentation tool for Angular applications. Since Nest and Angular share similar project and code structures, Compodoc works with Nest applications as well."
Title,Setup
Title,Setting up Compodoc inside an existing Nest project is very simple. Start by adding the dev-dependency with the following command in your OS terminal:
Title,bash
Title,$ npm i -D @compodoc/compodoc
Title,Generation
Title,Generate project documentation using the following command (npm 6 is required for npx support). See the official documentation for more options.
Title,bash
Title,$ npx @compodoc/compodoc -p tsconfig.json -s
Title,Open your browser and navigate to http://localhost:8080. You should see an initial Nest CLI project:
Title,
Title,
Title,Contribute
Title,You can participate and contribute to the Compodoc project here.
Title,
Title,Hot Reload
Title,"The highest impact on your application's bootstrapping process is TypeScript compilation. Fortunately, with webpack HMR (Hot-Module Replacement), we don't need to recompile the entire project each time a change occurs. This significantly decreases the amount of time necessary to instantiate your application, and makes iterative development a lot easier."
Title,
Title,"warning Warning Note that webpack won't automatically copy your assets (e.g. graphql files) to the dist folder. Similarly, webpack is not compatible with glob static paths (e.g., the entities property in TypeOrmModule)."
Title,
Title,With CLI
Title,"If you are using the Nest CLI, the configuration process is pretty straightforward. The CLI wraps webpack, which allows use of the HotModuleReplacementPlugin."
Title,Installation
Title,First install the required packages:
Title,bash
Title,$ npm i --save-dev webpack-node-externals run-script-webpack-plugin webpack
Title,
Title,"info Hint If you use Yarn Berry (not classic Yarn), install the webpack-pnp-externals package instead of the webpack-node-externals."
Title,
Title,Configuration
Title,"Once the installation is complete, create a webpack-hmr.config.js file in the root directory of your application."
Title,```typescript
Title,const nodeExternals = require('webpack-node-externals');
Title,const { RunScriptWebpackPlugin } = require('run-script-webpack-plugin');
Title,"module.exports = function (options, webpack) {"
Title,return {
Title,"...options,"
Title,"entry: ['webpack/hot/poll?100', options.entry],"
Title,externals: [
Title,nodeExternals({
Title,"allowlist: ['webpack/hot/poll?100'],"
Title,"}),"
Title,"],"
Title,plugins: [
Title,"...options.plugins,"
Title,"new webpack.HotModuleReplacementPlugin(),"
Title,new webpack.WatchIgnorePlugin({
Title,"paths: [/.js$/, /.d.ts$/],"
Title,"}),"
Title,"new RunScriptWebpackPlugin({ name: options.output.filename, autoRestart: false }),"
Title,"],"
Title,};
Title,};
Title,```
Title,
Title,"info Hint With Yarn Berry (not classic Yarn), instead of using the nodeExternals in the externals configuration property, use the WebpackPnpExternals from webpack-pnp-externals package: WebpackPnpExternals({{ '{' }} exclude: ['webpack/hot/poll?100'] {{ '}' }})."
Title,
Title,"This function takes the original object containing the default webpack configuration as a first argument, and the reference to the underlying webpack package used by the Nest CLI as the second one. Also, it returns a modified webpack configuration with the HotModuleReplacementPlugin, WatchIgnorePlugin, and RunScriptWebpackPlugin plugins."
Title,Hot-Module Replacement
Title,"To enable HMR, open the application entry file (main.ts) and add the following webpack-related instructions:"
Title,```typescript
Title,declare const module: any;
Title,async function bootstrap() {
Title,const app = await NestFactory.create(AppModule);
Title,await app.listen(process.env.PORT ?? 3000);
Title,if (module.hot) {
Title,module.hot.accept();
Title,module.hot.dispose(() => app.close());
Title,}
Title,}
Title,bootstrap();
Title,```
Title,"To simplify the execution process, add a script to your package.json file."
Title,json
Title,"""start:dev"": ""nest build --webpack --webpackPath webpack-hmr.config.js --watch"""
Title,Now simply open your command line and run the following command:
Title,bash
Title,$ npm run start:dev
Title,Without CLI
Title,"If you are not using the Nest CLI, the configuration will be slightly more complex (will require more manual steps)."
Title,Installation
Title,First install the required packages:
Title,bash
Title,$ npm i --save-dev webpack webpack-cli webpack-node-externals ts-loader run-script-webpack-plugin
Title,
Title,"info Hint If you use Yarn Berry (not classic Yarn), install the webpack-pnp-externals package instead of the webpack-node-externals."
Title,
Title,Configuration
Title,"Once the installation is complete, create a webpack.config.js file in the root directory of your application."
Title,```typescript
Title,const webpack = require('webpack');
Title,const path = require('path');
Title,const nodeExternals = require('webpack-node-externals');
Title,const { RunScriptWebpackPlugin } = require('run-script-webpack-plugin');
Title,module.exports = {
Title,"entry: ['webpack/hot/poll?100', './src/main.ts'],"
Title,"target: 'node',"
Title,externals: [
Title,nodeExternals({
Title,"allowlist: ['webpack/hot/poll?100'],"
Title,"}),"
Title,"],"
Title,module: {
Title,rules: [
Title,{
Title,"test: /.tsx?$/,"
Title,"use: 'ts-loader',"
Title,"exclude: /node_modules/,"
Title,"},"
Title,"],"
Title,"},"
Title,"mode: 'development',"
Title,resolve: {
Title,"extensions: ['.tsx', '.ts', '.js'],"
Title,"},"
Title,"plugins: [new webpack.HotModuleReplacementPlugin(), new RunScriptWebpackPlugin({ name: 'server.js', autoRestart: false })],"
Title,output: {
Title,"path: path.join(__dirname, 'dist'),"
Title,"filename: 'server.js',"
Title,"},"
Title,};
Title,```
Title,
Title,"info Hint With Yarn Berry (not classic Yarn), instead of using the nodeExternals in the externals configuration property, use the WebpackPnpExternals from webpack-pnp-externals package: WebpackPnpExternals({{ '{' }} exclude: ['webpack/hot/poll?100'] {{ '}' }})."
Title,
Title,"This configuration tells webpack a few essential things about your application: location of the entry file, which directory should be used to hold compiled files, and what kind of loader we want to use to compile source files. Generally, you should be able to use this file as-is, even if you don't fully understand all of the options."
Title,Hot-Module Replacement
Title,"To enable HMR, open the application entry file (main.ts) and add the following webpack-related instructions:"
Title,```typescript
Title,declare const module: any;
Title,async function bootstrap() {
Title,const app = await NestFactory.create(AppModule);
Title,await app.listen(process.env.PORT ?? 3000);
Title,if (module.hot) {
Title,module.hot.accept();
Title,module.hot.dispose(() => app.close());
Title,}
Title,}
Title,bootstrap();
Title,```
Title,"To simplify the execution process, add a script to your package.json file."
Title,json
Title,"""start:dev"": ""webpack --config webpack.config.js --watch"""
Title,Now simply open your command line and run the following command:
Title,bash
Title,$ npm run start:dev
Title,Example
Title,A working example is available here.
Title,
Title,MikroORM
Title,"This recipe is here to help users get started with MikroORM in Nest. MikroORM is the TypeScript ORM for Node.js based on Data Mapper, Unit of Work and Identity Map patterns. It is a great alternative to TypeORM and migration from TypeORM should be fairly easy. The complete documentation on MikroORM can be found here."
Title,
Title,info info @mikro-orm/nestjs is a third party package and is not managed by the NestJS core team. Please report any issues found with the library in the appropriate repository.
Title,
Title,Installation
Title,Easiest way to integrate MikroORM to Nest is via @mikro-orm/nestjs module.
Title,"Simply install it next to Nest, MikroORM and underlying driver:"
Title,bash
Title,$ npm i @mikro-orm/core @mikro-orm/nestjs @mikro-orm/sqlite
Title,"MikroORM also supports postgres, sqlite, and mongo. See the official docs for all drivers."
Title,"Once the installation process is completed, we can import the MikroOrmModule into the root AppModule."
Title,```typescript
Title,import { SqliteDriver } from '@mikro-orm/sqlite';
Title,@Module({
Title,imports: [
Title,MikroOrmModule.forRoot({
Title,"entities: ['./dist/entities'],"
Title,"entitiesTs: ['./src/entities'],"
Title,"dbName: 'my-db-name.sqlite3',"
Title,"driver: SqliteDriver,"
Title,"}),"
Title,"],"
Title,"controllers: [AppController],"
Title,"providers: [AppService],"
Title,})
Title,export class AppModule {
Title,}
Title,```
Title,The forRoot() method accepts the same configuration object as init() from the MikroORM package. Check this page for the complete configuration documentation.
Title,Alternatively we can configure the CLI by creating a configuration file mikro-orm.config.ts and then call the forRoot() without any arguments.
Title,typescript
Title,@Module({
Title,imports: [
Title,"MikroOrmModule.forRoot(),"
Title,"],"
Title,...
Title,})
Title,export class AppModule {}
Title,"But this won't work when you use a build tools that use tree shaking, for that it is better to provide the config explicitly:"
Title,```typescript
Title,import config from './mikro-orm.config'; // your ORM config
Title,@Module({
Title,imports: [
Title,"MikroOrmModule.forRoot(config),"
Title,"],"
Title,...
Title,})
Title,export class AppModule {}
Title,```
Title,"Afterward, the EntityManager will be available to inject across the entire project (without importing any module elsewhere)."
Title,``ts
Title,// Import everytyhing from your driver package or@mikro-orm/knex`
Title,"import { EntityManager, MikroORM } from '@mikro-orm/sqlite';"
Title,@Injectable()
Title,export class MyService {
Title,constructor(
Title,"private readonly orm: MikroORM,"
Title,"private readonly em: EntityManager,"
Title,) {}
Title,}
Title,```
Title,
Title,"info info Notice that the EntityManager is imported from the @mikro-orm/driver package, where driver is mysql, sqlite, postgres or what driver you are using. In case you have @mikro-orm/knex installed as a dependency, you can also import the EntityManager from there."
Title,
Title,Repositories
Title,"MikroORM supports the repository design pattern. For every entity, we can create a repository. Read the complete documentation on repositories here. To define which repositories should be registered in the current scope you can use the forFeature() method. For example, in this way:"
Title,
Title,"info info You should not register your base entities via forFeature(), as there are no"
Title,"repositories for those. On the other hand, base entities need to be part of the list in forRoot() (or in the ORM config in general)."
Title,
Title,typescript
Title,// photo.module.ts
Title,@Module({
Title,"imports: [MikroOrmModule.forFeature([Photo])],"
Title,"providers: [PhotoService],"
Title,"controllers: [PhotoController],"
Title,})
Title,export class PhotoModule {}
Title,and import it into the root AppModule:
Title,typescript
Title,// app.module.ts
Title,@Module({
Title,"imports: [MikroOrmModule.forRoot(...), PhotoModule],"
Title,})
Title,export class AppModule {}
Title,In this way we can inject the PhotoRepository to the PhotoService using the @InjectRepository() decorator:
Title,typescript
Title,@Injectable()
Title,export class PhotoService {
Title,constructor(
Title,@InjectRepository(Photo)
Title,"private readonly photoRepository: EntityRepository<Photo>,"
Title,) {}
Title,}
Title,Using custom repositories
Title,"When using custom repositories, we no longer need the @InjectRepository()"
Title,"decorator, as Nest DI resolved based on the class references."
Title,``ts
Title,//./author.entity.ts@Entity({ repository: () => AuthorRepository })
Title,export class Author {
Title,// to allow inference inem.getRepository()`
Title,[EntityRepositoryType]?: AuthorRepository;
Title,}
Title,// **./author.repository.ts**
Title,export class AuthorRepository extends EntityRepository {
Title,// your custom methods...
Title,}
Title,```
Title,As the custom repository name is the same as what getRepositoryToken() would
Title,"return, we do not need the @InjectRepository() decorator anymore:"
Title,ts
Title,@Injectable()
Title,export class MyService {
Title,constructor(private readonly repo: AuthorRepository) {}
Title,}
Title,Load entities automatically
Title,Manually adding entities to the entities array of the connection options can be
Title,"tedious. In addition, referencing entities from the root module breaks application"
Title,domain boundaries and causes leaking implementation details to other parts of the
Title,"application. To solve this issue, static glob paths can be used."
Title,"Note, however, that glob paths are not supported by webpack, so if you are building"
Title,"your application within a monorepo, you won't be able to use them. To address this"
Title,"issue, an alternative solution is provided. To automatically load entities, set the"
Title,autoLoadEntities property of the configuration object (passed into the forRoot()
Title,"method) to true, as shown below:"
Title,ts
Title,@Module({
Title,imports: [
Title,MikroOrmModule.forRoot({
Title,...
Title,"autoLoadEntities: true,"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,"With that option specified, every entity registered through the forFeature()"
Title,method will be automatically added to the entities array of the configuration
Title,object.
Title,
Title,"info info Note that entities that aren't registered through the forFeature() method, but"
Title,"are only referenced from the entity (via a relationship), won't be included by"
Title,way of the autoLoadEntities setting.
Title,info info Using autoLoadEntities also has no effect on the MikroORM CLI - for that we
Title,"still need CLI config with the full list of entities. On the other hand, we can"
Title,"use globs there, as the CLI won't go thru webpack."
Title,
Title,Serialization
Title,
Title,"warning Note MikroORM wraps every single entity relation in a Reference<T> or a Collection<T> object, in order to provide better type-safety. This will make Nest's built-in serializer blind to any wrapped relations. In other words, if you return MikroORM entities from your HTTP or WebSocket handlers, all of their relations will NOT be serialized."
Title,
Title,"Luckily, MikroORM provides a serialization API which can be used in lieu of ClassSerializerInterceptor."
Title,``typescript
Title,@Entity()
Title,export class Book {
Title,@Property({ hidden: true }) // Equivalent of class-transformer's@Exclude`
Title,hiddenField = Date.now();
Title,"@Property({ persist: false }) // Similar to class-transformer's @Expose(). Will only exist in memory, and will be serialized."
Title,count?: number;
Title,@ManyToOne({
Title,"serializer: (value) => value.name,"
Title,"serializedName: 'authorName',"
Title,}) // Equivalent of class-transformer's @Transform()
Title,author: Author;
Title,}
Title,```
Title,Request scoped handlers in queues
Title,"As mentioned in the docs, we need a clean state for each request. That is handled automatically thanks to the RequestContext helper registered via middleware."
Title,"But middlewares are executed only for regular HTTP request handles, what if we need"
Title,a request scoped method outside of that? One example of that is queue handlers or
Title,scheduled tasks.
Title,We can use the @CreateRequestContext() decorator. It requires you to first inject the
Title,"MikroORM instance to current context, it will be then used to create the context"
Title,"for you. Under the hood, the decorator will register new request context for your"
Title,method and execute it inside the context.
Title,```ts
Title,@Injectable()
Title,export class MyService {
Title,constructor(private readonly orm: MikroORM) {}
Title,@CreateRequestContext()
Title,async doSomething() {
Title,// this will be executed in a separate context
Title,}
Title,}
Title,```
Title,
Title,"warning Note As the name suggests, this decorator always creates new context, as opposed to its alternative @EnsureRequestContext that only creates it if it's already not inside another one."
Title,
Title,Testing
Title,The @mikro-orm/nestjs package exposes getRepositoryToken() function that returns prepared token based on a given entity to allow mocking the repository.
Title,typescript
Title,@Module({
Title,providers: [
Title,"PhotoService,"
Title,{
Title,// or when you have a custom repository: `provide: PhotoRepository`
Title,"provide: getRepositoryToken(Photo),"
Title,"useValue: mockedRepository,"
Title,"},"
Title,"],"
Title,})
Title,export class PhotoModule {}
Title,Example
Title,A real world example of NestJS with MikroORM can be found here
Title,
Title,MongoDB (Mongoose)
Title,
Title,"Warning In this article, you'll learn how to create a DatabaseModule based on the Mongoose package from scratch using custom components. As a consequence, this solution contains a lot of overhead that you can omit using ready to use and available out-of-the-box dedicated @nestjs/mongoose package. To learn more, see here."
Title,
Title,Mongoose is the most popular MongoDB object modeling tool.
Title,Getting started
Title,To start the adventure with this library we have to install all required dependencies:
Title,typescript
Title,$ npm install --save mongoose
Title,"The first step we need to do is to establish the connection with our database using connect() function. The connect() function returns a Promise, and therefore we have to create an async provider."
Title,```typescript
Title,@@filename(database.providers)
Title,import * as mongoose from 'mongoose';
Title,export const databaseProviders = [
Title,{
Title,"provide: 'DATABASE_CONNECTION',"
Title,useFactory: (): Promise =>
Title,"mongoose.connect('mongodb://localhost/nest'),"
Title,"},"
Title,];
Title,@@switch
Title,import * as mongoose from 'mongoose';
Title,export const databaseProviders = [
Title,{
Title,"provide: 'DATABASE_CONNECTION',"
Title,"useFactory: () => mongoose.connect('mongodb://localhost/nest'),"
Title,"},"
Title,];
Title,```
Title,
Title,"info Hint Following best practices, we declared the custom provider in the separated file which has a *.providers.ts suffix."
Title,
Title,"Then, we need to export these providers to make them accessible for the rest part of the application."
Title,```typescript
Title,@@filename(database.module)
Title,import { Module } from '@nestjs/common';
Title,import { databaseProviders } from './database.providers';
Title,@Module({
Title,"providers: [...databaseProviders],"
Title,"exports: [...databaseProviders],"
Title,})
Title,export class DatabaseModule {}
Title,```
Title,Now we can inject the Connection object using @Inject() decorator. Each class that would depend on the Connection async provider will wait until a Promise is resolved.
Title,Model injection
Title,"With Mongoose, everything is derived from a Schema. Let's define the CatSchema:"
Title,```typescript
Title,@@filename(schemas/cat.schema)
Title,import * as mongoose from 'mongoose';
Title,export const CatSchema = new mongoose.Schema({
Title,"name: String,"
Title,"age: Number,"
Title,"breed: String,"
Title,});
Title,```
Title,The CatsSchema belongs to the cats directory. This directory represents the CatsModule.
Title,Now it's time to create a Model provider:
Title,```typescript
Title,@@filename(cats.providers)
Title,import { Connection } from 'mongoose';
Title,import { CatSchema } from './schemas/cat.schema';
Title,export const catsProviders = [
Title,{
Title,"provide: 'CAT_MODEL',"
Title,"useFactory: (connection: Connection) => connection.model('Cat', CatSchema),"
Title,"inject: ['DATABASE_CONNECTION'],"
Title,"},"
Title,];
Title,@@switch
Title,import { CatSchema } from './schemas/cat.schema';
Title,export const catsProviders = [
Title,{
Title,"provide: 'CAT_MODEL',"
Title,"useFactory: (connection) => connection.model('Cat', CatSchema),"
Title,"inject: ['DATABASE_CONNECTION'],"
Title,"},"
Title,];
Title,```
Title,
Title,warning Warning In the real-world applications you should avoid magic strings. Both CAT_MODEL and DATABASE_CONNECTION should be kept in the separated constants.ts file.
Title,
Title,Now we can inject the CAT_MODEL to the CatsService using the @Inject() decorator:
Title,```typescript
Title,@@filename(cats.service)
Title,import { Model } from 'mongoose';
Title,"import { Injectable, Inject } from '@nestjs/common';"
Title,import { Cat } from './interfaces/cat.interface';
Title,import { CreateCatDto } from './dto/create-cat.dto';
Title,@Injectable()
Title,export class CatsService {
Title,constructor(
Title,@Inject('CAT_MODEL')
Title,"private catModel: Model,"
Title,) {}
Title,async create(createCatDto: CreateCatDto): Promise {
Title,const createdCat = new this.catModel(createCatDto);
Title,return createdCat.save();
Title,}
Title,async findAll(): Promise {
Title,return this.catModel.find().exec();
Title,}
Title,}
Title,@@switch
Title,"import { Injectable, Dependencies } from '@nestjs/common';"
Title,@Injectable()
Title,@Dependencies('CAT_MODEL')
Title,export class CatsService {
Title,constructor(catModel) {
Title,this.catModel = catModel;
Title,}
Title,async create(createCatDto) {
Title,const createdCat = new this.catModel(createCatDto);
Title,return createdCat.save();
Title,}
Title,async findAll() {
Title,return this.catModel.find().exec();
Title,}
Title,}
Title,```
Title,In the above example we have used the Cat interface. This interface extends the Document from the mongoose package:
Title,```typescript
Title,import { Document } from 'mongoose';
Title,export interface Cat extends Document {
Title,readonly name: string;
Title,readonly age: number;
Title,readonly breed: string;
Title,}
Title,```
Title,"The database connection is asynchronous, but Nest makes this process completely invisible for the end-user. The CatModel class is waiting for the db connection, and the CatsService is delayed until model is ready to use. The entire application can start when each class is instantiated."
Title,Here is a final CatsModule:
Title,```typescript
Title,@@filename(cats.module)
Title,import { Module } from '@nestjs/common';
Title,import { CatsController } from './cats.controller';
Title,import { CatsService } from './cats.service';
Title,import { catsProviders } from './cats.providers';
Title,import { DatabaseModule } from '../database/database.module';
Title,@Module({
Title,"imports: [DatabaseModule],"
Title,"controllers: [CatsController],"
Title,providers: [
Title,"CatsService,"
Title,"...catsProviders,"
Title,"],"
Title,})
Title,export class CatsModule {}
Title,```
Title,
Title,info Hint Do not forget to import the CatsModule into the root AppModule.
Title,
Title,Example
Title,A working example is available here.
Title,
Title,Necord
Title,"Necord is a powerful module that simplifies the creation of Discord bots, allowing for seamless integration with your NestJS application."
Title,
Title,"info Note Necord is a third-party package and is not officially maintained by the NestJS core team. If you encounter any issues, please report them in the official repository."
Title,
Title,Installation
Title,"To get started, you need to install Necord alongside its dependency, Discord.js."
Title,bash
Title,$ npm install necord discord.js
Title,Usage
Title,"To utilize Necord in your project, import the NecordModule and configure it with the necessary options."
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { NecordModule } from 'necord';
Title,import { IntentsBitField } from 'discord.js';
Title,import { AppService } from './app.service';
Title,@Module({
Title,imports: [
Title,NecordModule.forRoot({
Title,"token: process.env.DISCORD_TOKEN,"
Title,"intents: [IntentsBitField.Guilds],"
Title,"development: [process.env.DISCORD_DEVELOPMENT_GUILD_ID],"
Title,"}),"
Title,"],"
Title,"providers: [AppService],"
Title,})
Title,export class AppModule {}
Title,```
Title,
Title,info Hint You can find a comprehensive list of available intents here.
Title,
Title,"With this setup, you can inject the AppService into your providers to easily register commands, events, and more."
Title,```typescript
Title,@@filename(app.service)
Title,"import { Injectable, Logger } from '@nestjs/common';"
Title,"import { Context, On, Once, ContextOf } from 'necord';"
Title,import { Client } from 'discord.js';
Title,@Injectable()
Title,export class AppService {
Title,private readonly logger = new Logger(AppService.name);
Title,@Once('ready')
Title,public onReady(@Context() [client]: ContextOf<'ready'>) {
Title,this.logger.log(Bot logged in as ${client.user.username});
Title,}
Title,@On('warn')
Title,public onWarn(@Context() [message]: ContextOf<'warn'>) {
Title,this.logger.warn(message);
Title,}
Title,}
Title,```
Title,Understanding context
Title,"You may have noticed the @Context decorator in the examples above. This decorator injects the event context into your method, allowing you to access various event-specific data. Since there are multiple types of events, the context type is inferred using the ContextOf<type: string> type. You can easily access context variables by using the @Context() decorator, which fills the variable with an array of arguments relevant to the event."
Title,Text commands
Title,
Title,"warning Caution Text commands rely on message content, which is set to be deprecated for verified bots and applications with over 100 servers. This means that if your bot is unable to access message content, text commands will not function. Read more about this change here."
Title,
Title,Here's how to create a simple command handler for messages using the @TextCommand decorator.
Title,```typescript
Title,@@filename(app.commands)
Title,import { Injectable } from '@nestjs/common';
Title,"import { Context, TextCommand, TextCommandContext, Arguments } from 'necord';"
Title,@Injectable()
Title,export class AppCommands {
Title,@TextCommand({
Title,"name: 'ping',"
Title,"description: 'Responds with pong!',"
Title,})
Title,public onPing(
Title,"@Context() [message]: TextCommandContext,"
Title,"@Arguments() args: string[],"
Title,) {
Title,return message.reply('pong!');
Title,}
Title,}
Title,```
Title,Application commands
Title,"Application commands provide a native way for users to interact with your app within the Discord client. There are three types of application commands that can be accessed through different interfaces: chat input, message context menu (accessed by right-clicking a message), and user context menu (accessed by right-clicking a user)."
Title,
Title,Slash commands
Title,"Slash commands are an excellent way to engage with users in a structured manner. They allow you to create commands with precise arguments and options, enhancing the user experience significantly."
Title,"To define a slash command using Necord, you can use the SlashCommand decorator."
Title,```typescript
Title,@@filename(app.commands)
Title,import { Injectable } from '@nestjs/common';
Title,"import { Context, SlashCommand, SlashCommandContext } from 'necord';"
Title,@Injectable()
Title,export class AppCommands {
Title,@SlashCommand({
Title,"name: 'ping',"
Title,"description: 'Responds with pong!',"
Title,})
Title,public async onPing(@Context() [interaction]: SlashCommandContext) {
Title,return interaction.reply({ content: 'Pong!' });
Title,}
Title,}
Title,```
Title,
Title,"info Hint When your bot client logs in, it will automatically register all defined commands. Note that global commands are cached for up to an hour. To avoid issues with the global cache, utilize the development argument in the Necord module, which restricts command visibility to a single guild."
Title,
Title,Options
Title,You can define parameters for your slash commands using option decorators. Let's create a TextDto class for this purpose:
Title,```typescript
Title,@@filename(text.dto)
Title,import { StringOption } from 'necord';
Title,export class TextDto {
Title,@StringOption({
Title,"name: 'text',"
Title,"description: 'Input your text here',"
Title,"required: true,"
Title,})
Title,text: string;
Title,}
Title,```
Title,You can then use this DTO in the AppCommands class:
Title,```typescript
Title,@@filename(app.commands)
Title,import { Injectable } from '@nestjs/common';
Title,"import { Context, SlashCommand, Options, SlashCommandContext } from 'necord';"
Title,import { TextDto } from './length.dto';
Title,@Injectable()
Title,export class AppCommands {
Title,@SlashCommand({
Title,"name: 'length',"
Title,"description: 'Calculate the length of your text',"
Title,})
Title,public async onLength(
Title,"@Context() [interaction]: SlashCommandContext,"
Title,"@Options() { text }: TextDto,"
Title,) {
Title,return interaction.reply({
Title,"content: The length of your text is: ${text.length},"
Title,});
Title,}
Title,}
Title,```
Title,"For a complete list of built-in option decorators, check out this documentation."
Title,Autocomplete
Title,"To implement autocomplete functionality for your slash commands, you'll need to create an interceptor. This interceptor will handle requests as users type in the autocomplete field."
Title,```typescript
Title,@@filename(cats-autocomplete.interceptor)
Title,import { Injectable } from '@nestjs/common';
Title,import { AutocompleteInteraction } from 'discord.js';
Title,import { AutocompleteInterceptor } from 'necord';
Title,@Injectable()
Title,class CatsAutocompleteInterceptor extends AutocompleteInterceptor {
Title,public transformOptions(interaction: AutocompleteInteraction) {
Title,const focused = interaction.options.getFocused(true);
Title,let choices: string[];
Title,if (focused.name === 'cat') {
Title,"choices = ['Siamese', 'Persian', 'Maine Coon'];"
Title,}
Title,
Title,return interaction.respond(
Title,choices
Title,.filter((choice) => choice.startsWith(focused.value.toString()))
Title,".map((choice) => ({ name: choice, value: choice })),"
Title,);
Title,
Title,}
Title,}
Title,```
Title,You will also need to mark your options class with autocomplete: true:
Title,```typescript
Title,@@filename(cat.dto)
Title,import { StringOption } from 'necord';
Title,export class CatDto {
Title,@StringOption({
Title,"name: 'cat',"
Title,"description: 'Choose a cat breed',"
Title,"autocomplete: true,"
Title,"required: true,"
Title,})
Title,cat: string;
Title,}
Title,```
Title,"Finally, apply the interceptor to your slash command:"
Title,```typescript
Title,@@filename(cats.commands)
Title,"import { Injectable, UseInterceptors } from '@nestjs/common';"
Title,"import { Context, SlashCommand, Options, SlashCommandContext } from 'necord';"
Title,import { CatDto } from '/cat.dto';
Title,import { CatsAutocompleteInterceptor } from './cats-autocomplete.interceptor';
Title,@Injectable()
Title,export class CatsCommands {
Title,@UseInterceptors(CatsAutocompleteInterceptor)
Title,@SlashCommand({
Title,"name: 'cat',"
Title,"description: 'Retrieve information about a specific cat breed',"
Title,})
Title,public async onSearch(
Title,"@Context() [interaction]: SlashCommandContext,"
Title,"@Options() { cat }: CatDto,"
Title,) {
Title,return interaction.reply({
Title,"content: I found information on the breed of ${cat} cat!,"
Title,});
Title,}
Title,}
Title,```
Title,User context menu
Title,User commands appear on the context menu that appears when right-clicking (or tapping) on users. These commands provide quick actions that target users directly.
Title,```typescript
Title,@@filename(app.commands)
Title,import { Injectable } from '@nestjs/common';
Title,"import { Context, UserCommand, UserCommandContext, TargetUser } from 'necord';"
Title,import { User } from 'discord.js';
Title,@Injectable()
Title,export class AppCommands {
Title,@UserCommand({ name: 'Get avatar' })
Title,public async getUserAvatar(
Title,"@Context() [interaction]: UserCommandContext,"
Title,"@TargetUser() user: User,"
Title,) {
Title,return interaction.reply({
Title,embeds: [
Title,new MessageEmbed()
Title,.setTitle(Avatar of ${user.username})
Title,".setImage(user.displayAvatarURL({ size: 4096, dynamic: true })),"
Title,"],"
Title,});
Title,}
Title,}
Title,```
Title,Message context menu
Title,"Message commands show up in the context menu when right-clicking on messages, allowing for quick actions relevant to those messages."
Title,```typescript
Title,@@filename(app.commands)
Title,import { Injectable } from '@nestjs/common';
Title,"import { Context, MessageCommand, MessageCommandContext, TargetMessage } from 'necord';"
Title,import { Message } from 'discord.js';
Title,@Injectable()
Title,export class AppCommands {
Title,@MessageCommand({ name: 'Copy Message' })
Title,public async copyMessage(
Title,"@Context() [interaction]: MessageCommandContext,"
Title,"@TargetMessage() message: Message,"
Title,) {
Title,return interaction.reply({ content: message.content });
Title,}
Title,}
Title,```
Title,Buttons
Title,"Buttons are interactive elements that can be included in messages. When clicked, they send an interaction to your application."
Title,```typescript
Title,@@filename(app.components)
Title,import { Injectable } from '@nestjs/common';
Title,"import { Context, Button, ButtonContext } from 'necord';"
Title,@Injectable()
Title,export class AppComponents {
Title,@Button('BUTTON')
Title,public onButtonClick(@Context() [interaction]: ButtonContext) {
Title,return interaction.reply({ content: 'Button clicked!' });
Title,}
Title,}
Title,```
Title,Select menus
Title,Select menus are another type of interactive component that appears on messages. They provide a dropdown-like UI for users to select options.
Title,```typescript
Title,@@filename(app.components)
Title,import { Injectable } from '@nestjs/common';
Title,"import { Context, StringSelect, StringSelectContext, SelectedStrings } from 'necord';"
Title,@Injectable()
Title,export class AppComponents {
Title,@StringSelect('SELECT_MENU')
Title,public onSelectMenu(
Title,"@Context() [interaction]: StringSelectContext,"
Title,"@SelectedStrings() values: string[],"
Title,) {
Title,"return interaction.reply({ content: You selected: ${values.join(', ')} });"
Title,}
Title,}
Title,```
Title,"For a full list of built-in select menu components, visit this link."
Title,Modals
Title,Modals are pop-up forms that allow users to submit formatted input. Here's how to create and handle modals using Necord:
Title,```typescript
Title,@@filename(app.modals)
Title,import { Injectable } from '@nestjs/common';
Title,"import { Context, Modal, ModalContext } from 'necord';"
Title,@Injectable()
Title,export class AppModals {
Title,@Modal('pizza')
Title,public onModal(@Context() [interaction]: ModalContext) {
Title,return interaction.reply({
Title,content: Your fav pizza : ${interaction.fields.getTextInputValue('pizza')}
Title,});
Title,}
Title,}
Title,```
Title,More information
Title,Visit the Necord website for more information.
Title,
Title,Nest Commander
Title,Expanding on the standalone application docs there's also the nest-commander package for writing command line applications in a structure similar to your typical Nest application.
Title,
Title,"info info nest-commander is a third party package and is not managed by the entirety of the NestJS core team. Please, report any issues found with the library in the appropriate repository"
Title,
Title,Installation
Title,"Just like any other package, you've got to install it before you can use it."
Title,bash
Title,$ npm i nest-commander
Title,A Command file
Title,nest-commander makes it easy to write new command-line applications with decorators via the @Command() decorator for classes and the @Option() decorator for methods of that class. Every command file should implement the CommandRunner abstract class and should be decorated with a @Command() decorator.
Title,"Every command is seen as an @Injectable() by Nest, so your normal Dependency Injection still works as you would expect it to. The only thing to take note of is the abstract class CommandRunner, which should be implemented by each command. The CommandRunner abstract class ensures that all commands have a run method that returns a Promise<void> and takes in the parameters string[], Record<string, any>. The run command is where you can kick all of your logic off from, it will take in whatever parameters did not match option flags and pass them in as an array, just in case you are really meaning to work with multiple parameters. As for the options, the Record<string, any>, the names of these properties match the name property given to the @Option() decorators, while their value matches the return of the option handler. If you'd like better type safety, you are welcome to create an interface for your options as well."
Title,Running the Command
Title,"Similar to how in a NestJS application we can use the NestFactory to create a server for us, and run it using listen, the nest-commander package exposes a simple to use API to run your server. Import the CommandFactory and use the static method run and pass in the root module of your application. This would probably look like below"
Title,```ts
Title,import { CommandFactory } from 'nest-commander';
Title,import { AppModule } from './app.module';
Title,async function bootstrap() {
Title,await CommandFactory.run(AppModule);
Title,}
Title,bootstrap();
Title,```
Title,"By default, Nest's logger is disabled when using the CommandFactory. It's possible to provide it though, as the second argument to the run function. You can either provide a custom NestJS logger, or an array of log levels you want to keep - it might be useful to at least provide ['error'] here, if you only want to print out Nest's error logs."
Title,```ts
Title,import { CommandFactory } from 'nest-commander';
Title,import { AppModule } from './app.module';
Title,import { LogService } './log.service';
Title,async function bootstrap() {
Title,"await CommandFactory.run(AppModule, new LogService());"
Title,"// or, if you only want to print Nest's warnings and errors"
Title,"await CommandFactory.run(AppModule, ['warn', 'error']);"
Title,}
Title,bootstrap();
Title,```
Title,"And that's it. Under the hood, CommandFactory will worry about calling NestFactory for you and calling app.close() when necessary, so you shouldn't need to worry about memory leaks there. If you need to add in some error handling, there's always try/catch wrapping the run command, or you can chain on some .catch() method to the bootstrap() call."
Title,Testing
Title,"So what's the use of writing a super awesome command line script if you can't test it super easily, right? Fortunately, nest-commander has some utilities you can make use of that fits in perfectly with the NestJS ecosystem, it'll feel right at home to any Nestlings out there. Instead of using the CommandFactory for building the command in test mode, you can use CommandTestFactory and pass in your metadata, very similarly to how Test.createTestingModule from @nestjs/testing works. In fact, it uses this package under the hood. You're also still able to chain on the overrideProvider methods before calling compile() so you can swap out DI pieces right in the test."
Title,Putting it all together
Title,"The following class would equate to having a CLI command that can take in the subcommand basic or be called directly, with -n, -s, and -b (along with their long flags) all being supported and with custom parsers for each option. The --help flag is also supported, as is customary with commander."
Title,```ts
Title,"import { Command, CommandRunner, Option } from 'nest-commander';"
Title,import { LogService } from './log.service';
Title,interface BasicCommandOptions {
Title,string?: string;
Title,boolean?: boolean;
Title,number?: number;
Title,}
Title,"@Command({ name: 'basic', description: 'A parameter parse' })"
Title,export class BasicCommand extends CommandRunner {
Title,constructor(private readonly logService: LogService) {
Title,super()
Title,}
Title,async run(
Title,"passedParam: string[],"
Title,"options?: BasicCommandOptions,"
Title,): Promise {
Title,if (options?.boolean !== undefined && options?.boolean !== null) {
Title,"this.runWithBoolean(passedParam, options.boolean);"
Title,} else if (options?.number) {
Title,"this.runWithNumber(passedParam, options.number);"
Title,} else if (options?.string) {
Title,"this.runWithString(passedParam, options.string);"
Title,} else {
Title,this.runWithNone(passedParam);
Title,}
Title,}
Title,@Option({
Title,"flags: '-n, --number [number]',"
Title,"description: 'A basic number parser',"
Title,})
Title,parseNumber(val: string): number {
Title,return Number(val);
Title,}
Title,@Option({
Title,"flags: '-s, --string [string]',"
Title,"description: 'A string return',"
Title,})
Title,parseString(val: string): string {
Title,return val;
Title,}
Title,@Option({
Title,"flags: '-b, --boolean [boolean]',"
Title,"description: 'A boolean parser',"
Title,})
Title,parseBoolean(val: string): boolean {
Title,return JSON.parse(val);
Title,}
Title,"runWithString(param: string[], option: string): void {"
Title,"this.logService.log({ param, string: option });"
Title,}
Title,"runWithNumber(param: string[], option: number): void {"
Title,"this.logService.log({ param, number: option });"
Title,}
Title,"runWithBoolean(param: string[], option: boolean): void {"
Title,"this.logService.log({ param, boolean: option });"
Title,}
Title,runWithNone(param: string[]): void {
Title,this.logService.log({ param });
Title,}
Title,}
Title,```
Title,Make sure the command class is added to a module
Title,ts
Title,@Module({
Title,"providers: [LogService, BasicCommand],"
Title,})
Title,export class AppModule {}
Title,And now to be able to run the CLI in your main.ts you can do the following
Title,```ts
Title,async function bootstrap() {
Title,await CommandFactory.run(AppModule);
Title,}
Title,bootstrap();
Title,```
Title,"And just like that, you've got a command line application."
Title,More Information
Title,"Visit the nest-commander docs site for more information, examples, and API documentation."
Title,
Title,Passport (authentication)
Title,"Passport is the most popular node.js authentication library, well-known by the community and successfully used in many production applications. It's straightforward to integrate this library with a Nest application using the @nestjs/passport module. At a high level, Passport executes a series of steps to:"
Title,
Title,"Authenticate a user by verifying their ""credentials"" (such as username/password, JSON Web Token (JWT), or identity token from an Identity Provider)"
Title,"Manage authenticated state (by issuing a portable token, such as a JWT, or creating an Express session)"
Title,Attach information about the authenticated user to the Request object for further use in route handlers
Title,
Title,"Passport has a rich ecosystem of strategies that implement various authentication mechanisms. While simple in concept, the set of Passport strategies you can choose from is large and presents a lot of variety. Passport abstracts these varied steps into a standard pattern, and the @nestjs/passport module wraps and standardizes this pattern into familiar Nest constructs."
Title,"In this chapter, we'll implement a complete end-to-end authentication solution for a RESTful API server using these powerful and flexible modules. You can use the concepts described here to implement any Passport strategy to customize your authentication scheme. You can follow the steps in this chapter to build this complete example."
Title,Authentication requirements
Title,"Let's flesh out our requirements. For this use case, clients will start by authenticating with a username and password. Once authenticated, the server will issue a JWT that can be sent as a bearer token in an authorization header on subsequent requests to prove authentication. We'll also create a protected route that is accessible only to requests that contain a valid JWT."
Title,"We'll start with the first requirement: authenticating a user. We'll then extend that by issuing a JWT. Finally, we'll create a protected route that checks for a valid JWT on the request."
Title,"First we need to install the required packages. Passport provides a strategy called passport-local that implements a username/password authentication mechanism, which suits our needs for this portion of our use case."
Title,bash
Title,$ npm install --save @nestjs/passport passport passport-local
Title,$ npm install --save-dev @types/passport-local
Title,
Title,"warning Notice For any Passport strategy you choose, you'll always need the @nestjs/passport and passport packages. Then, you'll need to install the strategy-specific package (e.g., passport-jwt or passport-local) that implements the particular authentication strategy you are building. In addition, you can also install the type definitions for any Passport strategy, as shown above with @types/passport-local, which provides assistance while writing TypeScript code."
Title,
Title,Implementing Passport strategies
Title,"We're now ready to implement the authentication feature. We'll start with an overview of the process used for any Passport strategy. It's helpful to think of Passport as a mini framework in itself. The elegance of the framework is that it abstracts the authentication process into a few basic steps that you customize based on the strategy you're implementing. It's like a framework because you configure it by supplying customization parameters (as plain JSON objects) and custom code in the form of callback functions, which Passport calls at the appropriate time. The @nestjs/passport module wraps this framework in a Nest style package, making it easy to integrate into a Nest application. We'll use @nestjs/passport below, but first let's consider how vanilla Passport works."
Title,"In vanilla Passport, you configure a strategy by providing two things:"
Title,
Title,"A set of options that are specific to that strategy. For example, in a JWT strategy, you might provide a secret to sign tokens."
Title,"A ""verify callback"", which is where you tell Passport how to interact with your user store (where you manage user accounts). Here, you verify whether a user exists (and/or create a new user), and whether their credentials are valid. The Passport library expects this callback to return a full user if the validation succeeds, or a null if it fails (failure is defined as either the user is not found, or, in the case of passport-local, the password does not match)."
Title,
Title,"With @nestjs/passport, you configure a Passport strategy by extending the PassportStrategy class. You pass the strategy options (item 1 above) by calling the super() method in your subclass, optionally passing in an options object. You provide the verify callback (item 2 above) by implementing a validate() method in your subclass."
Title,"We'll start by generating an AuthModule and in it, an AuthService:"
Title,bash
Title,$ nest g module auth
Title,$ nest g service auth
Title,"As we implement the AuthService, we'll find it useful to encapsulate user operations in a UsersService, so let's generate that module and service now:"
Title,bash
Title,$ nest g module users
Title,$ nest g service users
Title,"Replace the default contents of these generated files as shown below. For our sample app, the UsersService simply maintains a hard-coded in-memory list of users, and a find method to retrieve one by username. In a real app, this is where you'd build your user model and persistence layer, using your library of choice (e.g., TypeORM, Sequelize, Mongoose, etc.)."
Title,```typescript
Title,@@filename(users/users.service)
Title,import { Injectable } from '@nestjs/common';
Title,// This should be a real class/interface representing a user entity
Title,export type User = any;
Title,@Injectable()
Title,export class UsersService {
Title,private readonly users = [
Title,{
Title,"userId: 1,"
Title,"username: 'john',"
Title,"password: 'changeme',"
Title,"},"
Title,{
Title,"userId: 2,"
Title,"username: 'maria',"
Title,"password: 'guess',"
Title,"},"
Title,];
Title,async findOne(username: string): Promise {
Title,return this.users.find(user => user.username === username);
Title,}
Title,}
Title,@@switch
Title,import { Injectable } from '@nestjs/common';
Title,@Injectable()
Title,export class UsersService {
Title,constructor() {
Title,this.users = [
Title,{
Title,"userId: 1,"
Title,"username: 'john',"
Title,"password: 'changeme',"
Title,"},"
Title,{
Title,"userId: 2,"
Title,"username: 'maria',"
Title,"password: 'guess',"
Title,"},"
Title,];
Title,}
Title,async findOne(username) {
Title,return this.users.find(user => user.username === username);
Title,}
Title,}
Title,```
Title,"In the UsersModule, the only change needed is to add the UsersService to the exports array of the @Module decorator so that it is visible outside this module (we'll soon use it in our AuthService)."
Title,```typescript
Title,@@filename(users/users.module)
Title,import { Module } from '@nestjs/common';
Title,import { UsersService } from './users.service';
Title,@Module({
Title,"providers: [UsersService],"
Title,"exports: [UsersService],"
Title,})
Title,export class UsersModule {}
Title,@@switch
Title,import { Module } from '@nestjs/common';
Title,import { UsersService } from './users.service';
Title,@Module({
Title,"providers: [UsersService],"
Title,"exports: [UsersService],"
Title,})
Title,export class UsersModule {}
Title,```
Title,"Our AuthService has the job of retrieving a user and verifying the password. We create a validateUser() method for this purpose. In the code below, we use a convenient ES6 spread operator to strip the password property from the user object before returning it. We'll be calling into the validateUser() method from our Passport local strategy in a moment."
Title,```typescript
Title,@@filename(auth/auth.service)
Title,import { Injectable } from '@nestjs/common';
Title,import { UsersService } from '../users/users.service';
Title,@Injectable()
Title,export class AuthService {
Title,constructor(private usersService: UsersService) {}
Title,"async validateUser(username: string, pass: string): Promise {"
Title,const user = await this.usersService.findOne(username);
Title,if (user && user.password === pass) {
Title,"const { password, ...result } = user;"
Title,return result;
Title,}
Title,return null;
Title,}
Title,}
Title,@@switch
Title,"import { Injectable, Dependencies } from '@nestjs/common';"
Title,import { UsersService } from '../users/users.service';
Title,@Injectable()
Title,@Dependencies(UsersService)
Title,export class AuthService {
Title,constructor(usersService) {
Title,this.usersService = usersService;
Title,}
Title,"async validateUser(username, pass) {"
Title,const user = await this.usersService.findOne(username);
Title,if (user && user.password === pass) {
Title,"const { password, ...result } = user;"
Title,return result;
Title,}
Title,return null;
Title,}
Title,}
Title,```
Title,
Title,"Warning Warning Of course in a real application, you wouldn't store a password in plain text. You'd instead use a library like bcrypt, with a salted one-way hash algorithm. With that approach, you'd only store hashed passwords, and then compare the stored password to a hashed version of the incoming password, thus never storing or exposing user passwords in plain text. To keep our sample app simple, we violate that absolute mandate and use plain text. Don't do this in your real app!"
Title,
Title,"Now, we update our AuthModule to import the UsersModule."
Title,```typescript
Title,@@filename(auth/auth.module)
Title,import { Module } from '@nestjs/common';
Title,import { AuthService } from './auth.service';
Title,import { UsersModule } from '../users/users.module';
Title,@Module({
Title,"imports: [UsersModule],"
Title,"providers: [AuthService],"
Title,})
Title,export class AuthModule {}
Title,@@switch
Title,import { Module } from '@nestjs/common';
Title,import { AuthService } from './auth.service';
Title,import { UsersModule } from '../users/users.module';
Title,@Module({
Title,"imports: [UsersModule],"
Title,"providers: [AuthService],"
Title,})
Title,export class AuthModule {}
Title,```
Title,Implementing Passport local
Title,"Now we can implement our Passport local authentication strategy. Create a file called local.strategy.ts in the auth folder, and add the following code:"
Title,```typescript
Title,@@filename(auth/local.strategy)
Title,import { Strategy } from 'passport-local';
Title,import { PassportStrategy } from '@nestjs/passport';
Title,"import { Injectable, UnauthorizedException } from '@nestjs/common';"
Title,import { AuthService } from './auth.service';
Title,@Injectable()
Title,export class LocalStrategy extends PassportStrategy(Strategy) {
Title,constructor(private authService: AuthService) {
Title,super();
Title,}
Title,"async validate(username: string, password: string): Promise {"
Title,"const user = await this.authService.validateUser(username, password);"
Title,if (!user) {
Title,throw new UnauthorizedException();
Title,}
Title,return user;
Title,}
Title,}
Title,@@switch
Title,import { Strategy } from 'passport-local';
Title,import { PassportStrategy } from '@nestjs/passport';
Title,"import { Injectable, UnauthorizedException, Dependencies } from '@nestjs/common';"
Title,import { AuthService } from './auth.service';
Title,@Injectable()
Title,@Dependencies(AuthService)
Title,export class LocalStrategy extends PassportStrategy(Strategy) {
Title,constructor(authService) {
Title,super();
Title,this.authService = authService;
Title,}
Title,"async validate(username, password) {"
Title,"const user = await this.authService.validateUser(username, password);"
Title,if (!user) {
Title,throw new UnauthorizedException();
Title,}
Title,return user;
Title,}
Title,}
Title,```
Title,"We've followed the recipe described earlier for all Passport strategies. In our use case with passport-local, there are no configuration options, so our constructor simply calls super(), without an options object."
Title,
Title,"info Hint We can pass an options object in the call to super() to customize the behavior of the passport strategy. In this example, the passport-local strategy by default expects properties called username and password in the request body. Pass an options object to specify different property names, for example: super({{ '{' }} usernameField: 'email' {{ '}' }}). See the Passport documentation for more information."
Title,
Title,"We've also implemented the validate() method. For each strategy, Passport will call the verify function (implemented with the validate() method in @nestjs/passport) using an appropriate strategy-specific set of parameters. For the local-strategy, Passport expects a validate() method with the following signature: validate(username: string, password:string): any."
Title,"Most of the validation work is done in our AuthService (with the help of our UsersService), so this method is quite straightforward. The validate() method for any Passport strategy will follow a similar pattern, varying only in the details of how credentials are represented. If a user is found and the credentials are valid, the user is returned so Passport can complete its tasks (e.g., creating the user property on the Request object), and the request handling pipeline can continue. If it's not found, we throw an exception and let our exceptions layer handle it."
Title,"Typically, the only significant difference in the validate() method for each strategy is how you determine if a user exists and is valid. For example, in a JWT strategy, depending on requirements, we may evaluate whether the userId carried in the decoded token matches a record in our user database, or matches a list of revoked tokens. Hence, this pattern of sub-classing and implementing strategy-specific validation is consistent, elegant and extensible."
Title,We need to configure our AuthModule to use the Passport features we just defined. Update auth.module.ts to look like this:
Title,```typescript
Title,@@filename(auth/auth.module)
Title,import { Module } from '@nestjs/common';
Title,import { AuthService } from './auth.service';
Title,import { UsersModule } from '../users/users.module';
Title,import { PassportModule } from '@nestjs/passport';
Title,import { LocalStrategy } from './local.strategy';
Title,@Module({
Title,"imports: [UsersModule, PassportModule],"
Title,"providers: [AuthService, LocalStrategy],"
Title,})
Title,export class AuthModule {}
Title,@@switch
Title,import { Module } from '@nestjs/common';
Title,import { AuthService } from './auth.service';
Title,import { UsersModule } from '../users/users.module';
Title,import { PassportModule } from '@nestjs/passport';
Title,import { LocalStrategy } from './local.strategy';
Title,@Module({
Title,"imports: [UsersModule, PassportModule],"
Title,"providers: [AuthService, LocalStrategy],"
Title,})
Title,export class AuthModule {}
Title,```
Title,Built-in Passport Guards
Title,"The Guards chapter describes the primary function of Guards: to determine whether a request will be handled by the route handler or not. That remains true, and we'll use that standard capability soon. However, in the context of using the @nestjs/passport module, we will also introduce a slight new wrinkle that may at first be confusing, so let's discuss that now. Consider that your app can exist in two states, from an authentication perspective:"
Title,
Title,the user/client is not logged in (is not authenticated)
Title,the user/client is logged in (is authenticated)
Title,
Title,"In the first case (user is not logged in), we need to perform two distinct functions:"
Title,
Title,
Title,"Restrict the routes an unauthenticated user can access (i.e., deny access to restricted routes). We'll use Guards in their familiar capacity to handle this function, by placing a Guard on the protected routes. As you may anticipate, we'll be checking for the presence of a valid JWT in this Guard, so we'll work on this Guard later, once we are successfully issuing JWTs."
Title,
Title,
Title,"Initiate the authentication step itself when a previously unauthenticated user attempts to login. This is the step where we'll issue a JWT to a valid user. Thinking about this for a moment, we know we'll need to POST username/password credentials to initiate authentication, so we'll set up a POST /auth/login route to handle that. This raises the question: how exactly do we invoke the passport-local strategy in that route?"
Title,
Title,
Title,"The answer is straightforward: by using another, slightly different type of Guard. The @nestjs/passport module provides us with a built-in Guard that does this for us. This Guard invokes the Passport strategy and kicks off the steps described above (retrieving credentials, running the verify function, creating the user property, etc)."
Title,The second case enumerated above (logged in user) simply relies on the standard type of Guard we already discussed to enable access to protected routes for logged in users.
Title,
Title,Login route
Title,"With the strategy in place, we can now implement a bare-bones /auth/login route, and apply the built-in Guard to initiate the passport-local flow."
Title,Open the app.controller.ts file and replace its contents with the following:
Title,```typescript
Title,@@filename(app.controller)
Title,"import { Controller, Request, Post, UseGuards } from '@nestjs/common';"
Title,import { AuthGuard } from '@nestjs/passport';
Title,@Controller()
Title,export class AppController {
Title,@UseGuards(AuthGuard('local'))
Title,@Post('auth/login')
Title,async login(@Request() req) {
Title,return req.user;
Title,}
Title,}
Title,@@switch
Title,"import { Controller, Bind, Request, Post, UseGuards } from '@nestjs/common';"
Title,import { AuthGuard } from '@nestjs/passport';
Title,@Controller()
Title,export class AppController {
Title,@UseGuards(AuthGuard('local'))
Title,@Post('auth/login')
Title,@Bind(Request())
Title,async login(req) {
Title,return req.user;
Title,}
Title,}
Title,```
Title,"With @UseGuards(AuthGuard('local')) we are using an AuthGuard that @nestjs/passport automatically provisioned for us when we extended the passport-local strategy. Let's break that down. Our Passport local strategy has a default name of 'local'. We reference that name in the @UseGuards() decorator to associate it with code supplied by the passport-local package. This is used to disambiguate which strategy to invoke in case we have multiple Passport strategies in our app (each of which may provision a strategy-specific AuthGuard). While we only have one such strategy so far, we'll shortly add a second, so this is needed for disambiguation."
Title,"In order to test our route we'll have our /auth/login route simply return the user for now. This also lets us demonstrate another Passport feature: Passport automatically creates a user object, based on the value we return from the validate() method, and assigns it to the Request object as req.user. Later, we'll replace this with code to create and return a JWT instead."
Title,"Since these are API routes, we'll test them using the commonly available cURL library. You can test with any of the user objects hard-coded in the UsersService."
Title,bash
Title,$ # POST to /auth/login
Title,"$ curl -X POST http://localhost:3000/auth/login -d '{""username"": ""john"", ""password"": ""changeme""}' -H ""Content-Type: application/json"""
Title,"$ # result -> {""userId"":1,""username"":""john""}"
Title,"While this works, passing the strategy name directly to the AuthGuard() introduces magic strings in the codebase. Instead, we recommend creating your own class, as shown below:"
Title,```typescript
Title,@@filename(auth/local-auth.guard)
Title,import { Injectable } from '@nestjs/common';
Title,import { AuthGuard } from '@nestjs/passport';
Title,@Injectable()
Title,export class LocalAuthGuard extends AuthGuard('local') {}
Title,```
Title,"Now, we can update the /auth/login route handler and use the LocalAuthGuard instead:"
Title,typescript
Title,@UseGuards(LocalAuthGuard)
Title,@Post('auth/login')
Title,async login(@Request() req) {
Title,return req.user;
Title,}
Title,Logout route
Title,"To log out, we can create an additional route that invokes res.logout() to clear the user's session. This is a typical approach used in session-based authentication, but it does not apply to JWTs."
Title,typescript
Title,@UseGuards(LocalAuthGuard)
Title,@Post('auth/logout')
Title,async logout(@Request() req) {
Title,return req.logout();
Title,}
Title,JWT functionality
Title,We're ready to move on to the JWT portion of our auth system. Let's review and refine our requirements:
Title,
Title,"Allow users to authenticate with username/password, returning a JWT for use in subsequent calls to protected API endpoints. We're well on our way to meeting this requirement. To complete it, we'll need to write the code that issues a JWT."
Title,Create API routes which are protected based on the presence of a valid JWT as a bearer token
Title,
Title,We'll need to install a couple more packages to support our JWT requirements:
Title,bash
Title,$ npm install --save @nestjs/jwt passport-jwt
Title,$ npm install --save-dev @types/passport-jwt
Title,The @nestjs/jwt package (see more here) is a utility package that helps with JWT manipulation. The passport-jwt package is the Passport package that implements the JWT strategy and @types/passport-jwt provides the TypeScript type definitions.
Title,Let's take a closer look at how a POST /auth/login request is handled. We've decorated the route using the built-in AuthGuard provided by the passport-local strategy. This means that:
Title,
Title,The route handler will only be invoked if the user has been validated
Title,The req parameter will contain a user property (populated by Passport during the passport-local authentication flow)
Title,
Title,"With this in mind, we can now finally generate a real JWT, and return it in this route. To keep our services cleanly modularized, we'll handle generating the JWT in the authService. Open the auth.service.ts file in the auth folder, and add the login() method, and import the JwtService as shown:"
Title,```typescript
Title,@@filename(auth/auth.service)
Title,import { Injectable } from '@nestjs/common';
Title,import { UsersService } from '../users/users.service';
Title,import { JwtService } from '@nestjs/jwt';
Title,@Injectable()
Title,export class AuthService {
Title,constructor(
Title,"private usersService: UsersService,"
Title,private jwtService: JwtService
Title,) {}
Title,"async validateUser(username: string, pass: string): Promise {"
Title,const user = await this.usersService.findOne(username);
Title,if (user && user.password === pass) {
Title,"const { password, ...result } = user;"
Title,return result;
Title,}
Title,return null;
Title,}
Title,async login(user: any) {
Title,"const payload = { username: user.username, sub: user.userId };"
Title,return {
Title,"access_token: this.jwtService.sign(payload),"
Title,};
Title,}
Title,}
Title,@@switch
Title,"import { Injectable, Dependencies } from '@nestjs/common';"
Title,import { UsersService } from '../users/users.service';
Title,import { JwtService } from '@nestjs/jwt';
Title,"@Dependencies(UsersService, JwtService)"
Title,@Injectable()
Title,export class AuthService {
Title,"constructor(usersService, jwtService) {"
Title,this.usersService = usersService;
Title,this.jwtService = jwtService;
Title,}
Title,"async validateUser(username, pass) {"
Title,const user = await this.usersService.findOne(username);
Title,if (user && user.password === pass) {
Title,"const { password, ...result } = user;"
Title,return result;
Title,}
Title,return null;
Title,}
Title,async login(user) {
Title,"const payload = { username: user.username, sub: user.userId };"
Title,return {
Title,"access_token: this.jwtService.sign(payload),"
Title,};
Title,}
Title,}
Title,```
Title,"We're using the @nestjs/jwt library, which supplies a sign() function to generate our JWT from a subset of the user object properties, which we then return as a simple object with a single access_token property. Note: we choose a property name of sub to hold our userId value to be consistent with JWT standards. Don't forget to inject the JwtService provider into the AuthService."
Title,We now need to update the AuthModule to import the new dependencies and configure the JwtModule.
Title,"First, create constants.ts in the auth folder, and add the following code:"
Title,typescript
Title,@@filename(auth/constants)
Title,export const jwtConstants = {
Title,"secret: 'DO NOT USE THIS VALUE. INSTEAD, CREATE A COMPLEX SECRET AND KEEP IT SAFE OUTSIDE OF THE SOURCE CODE.',"
Title,};
Title,@@switch
Title,export const jwtConstants = {
Title,"secret: 'DO NOT USE THIS VALUE. INSTEAD, CREATE A COMPLEX SECRET AND KEEP IT SAFE OUTSIDE OF THE SOURCE CODE.',"
Title,};
Title,We'll use this to share our key between the JWT signing and verifying steps.
Title,
Title,"Warning Warning Do not expose this key publicly. We have done so here to make it clear what the code is doing, but in a production system you must protect this key using appropriate measures such as a secrets vault, environment variable, or configuration service."
Title,
Title,"Now, open auth.module.ts in the auth folder and update it to look like this:"
Title,```typescript
Title,@@filename(auth/auth.module)
Title,import { Module } from '@nestjs/common';
Title,import { AuthService } from './auth.service';
Title,import { LocalStrategy } from './local.strategy';
Title,import { UsersModule } from '../users/users.module';
Title,import { PassportModule } from '@nestjs/passport';
Title,import { JwtModule } from '@nestjs/jwt';
Title,import { jwtConstants } from './constants';
Title,@Module({
Title,imports: [
Title,"UsersModule,"
Title,"PassportModule,"
Title,JwtModule.register({
Title,"secret: jwtConstants.secret,"
Title,"signOptions: { expiresIn: '60s' },"
Title,"}),"
Title,"],"
Title,"providers: [AuthService, LocalStrategy],"
Title,"exports: [AuthService],"
Title,})
Title,export class AuthModule {}
Title,@@switch
Title,import { Module } from '@nestjs/common';
Title,import { AuthService } from './auth.service';
Title,import { LocalStrategy } from './local.strategy';
Title,import { UsersModule } from '../users/users.module';
Title,import { PassportModule } from '@nestjs/passport';
Title,import { JwtModule } from '@nestjs/jwt';
Title,import { jwtConstants } from './constants';
Title,@Module({
Title,imports: [
Title,"UsersModule,"
Title,"PassportModule,"
Title,JwtModule.register({
Title,"secret: jwtConstants.secret,"
Title,"signOptions: { expiresIn: '60s' },"
Title,"}),"
Title,"],"
Title,"providers: [AuthService, LocalStrategy],"
Title,"exports: [AuthService],"
Title,})
Title,export class AuthModule {}
Title,```
Title,"We configure the JwtModule using register(), passing in a configuration object. See here for more on the Nest JwtModule and here for more details on the available configuration options."
Title,Now we can update the /auth/login route to return a JWT.
Title,```typescript
Title,@@filename(app.controller)
Title,"import { Controller, Request, Post, UseGuards } from '@nestjs/common';"
Title,import { LocalAuthGuard } from './auth/local-auth.guard';
Title,import { AuthService } from './auth/auth.service';
Title,@Controller()
Title,export class AppController {
Title,constructor(private authService: AuthService) {}
Title,@UseGuards(LocalAuthGuard)
Title,@Post('auth/login')
Title,async login(@Request() req) {
Title,return this.authService.login(req.user);
Title,}
Title,}
Title,@@switch
Title,"import { Controller, Bind, Request, Post, UseGuards } from '@nestjs/common';"
Title,import { LocalAuthGuard } from './auth/local-auth.guard';
Title,import { AuthService } from './auth/auth.service';
Title,@Controller()
Title,export class AppController {
Title,constructor(private authService: AuthService) {}
Title,@UseGuards(LocalAuthGuard)
Title,@Post('auth/login')
Title,@Bind(Request())
Title,async login(req) {
Title,return this.authService.login(req.user);
Title,}
Title,}
Title,```
Title,Let's go ahead and test our routes using cURL again. You can test with any of the user objects hard-coded in the UsersService.
Title,bash
Title,$ # POST to /auth/login
Title,"$ curl -X POST http://localhost:3000/auth/login -d '{""username"": ""john"", ""password"": ""changeme""}' -H ""Content-Type: application/json"""
Title,"$ # result -> {""access_token"":""eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...""}"
Title,$ # Note: above JWT truncated
Title,Implementing Passport JWT
Title,"We can now address our final requirement: protecting endpoints by requiring a valid JWT be present on the request. Passport can help us here too. It provides the passport-jwt strategy for securing RESTful endpoints with JSON Web Tokens. Start by creating a file called jwt.strategy.ts in the auth folder, and add the following code:"
Title,```typescript
Title,@@filename(auth/jwt.strategy)
Title,"import { ExtractJwt, Strategy } from 'passport-jwt';"
Title,import { PassportStrategy } from '@nestjs/passport';
Title,import { Injectable } from '@nestjs/common';
Title,import { jwtConstants } from './constants';
Title,@Injectable()
Title,export class JwtStrategy extends PassportStrategy(Strategy) {
Title,constructor() {
Title,super({
Title,"jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),"
Title,"ignoreExpiration: false,"
Title,"secretOrKey: jwtConstants.secret,"
Title,});
Title,}
Title,async validate(payload: any) {
Title,"return { userId: payload.sub, username: payload.username };"
Title,}
Title,}
Title,@@switch
Title,"import { ExtractJwt, Strategy } from 'passport-jwt';"
Title,import { PassportStrategy } from '@nestjs/passport';
Title,import { Injectable } from '@nestjs/common';
Title,import { jwtConstants } from './constants';
Title,@Injectable()
Title,export class JwtStrategy extends PassportStrategy(Strategy) {
Title,constructor() {
Title,super({
Title,"jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),"
Title,"ignoreExpiration: false,"
Title,"secretOrKey: jwtConstants.secret,"
Title,});
Title,}
Title,async validate(payload) {
Title,"return { userId: payload.sub, username: payload.username };"
Title,}
Title,}
Title,```
Title,"With our JwtStrategy, we've followed the same recipe described earlier for all Passport strategies. This strategy requires some initialization, so we do that by passing in an options object in the super() call. You can read more about the available options here. In our case, these options are:"
Title,
Title,jwtFromRequest: supplies the method by which the JWT will be extracted from the Request. We will use the standard approach of supplying a bearer token in the Authorization header of our API requests. Other options are described here.
Title,"ignoreExpiration: just to be explicit, we choose the default false setting, which delegates the responsibility of ensuring that a JWT has not expired to the Passport module. This means that if our route is supplied with an expired JWT, the request will be denied and a 401 Unauthorized response sent. Passport conveniently handles this automatically for us."
Title,"secretOrKey: we are using the expedient option of supplying a symmetric secret for signing the token. Other options, such as a PEM-encoded public key, may be more appropriate for production apps (see here for more information). In any case, as cautioned earlier, do not expose this secret publicly."
Title,
Title,"The validate() method deserves some discussion. For the jwt-strategy, Passport first verifies the JWT's signature and decodes the JSON. It then invokes our validate() method passing the decoded JSON as its single parameter. Based on the way JWT signing works, we're guaranteed that we're receiving a valid token that we have previously signed and issued to a valid user."
Title,"As a result of all this, our response to the validate() callback is trivial: we simply return an object containing the userId and username properties. Recall again that Passport will build a user object based on the return value of our validate() method, and attach it as a property on the Request object."
Title,"Additionally, you can return an array, where the first value is used to create a user object and the second value is used to create an authInfo object."
Title,"It's also worth pointing out that this approach leaves us room ('hooks' as it were) to inject other business logic into the process. For example, we could do a database lookup in our validate() method to extract more information about the user, resulting in a more enriched user object being available in our Request. This is also the place we may decide to do further token validation, such as looking up the userId in a list of revoked tokens, enabling us to perform token revocation. The model we've implemented here in our sample code is a fast, ""stateless JWT"" model, where each API call is immediately authorized based on the presence of a valid JWT, and a small bit of information about the requester (its userId and username) is available in our Request pipeline."
Title,Add the new JwtStrategy as a provider in the AuthModule:
Title,```typescript
Title,@@filename(auth/auth.module)
Title,import { Module } from '@nestjs/common';
Title,import { AuthService } from './auth.service';
Title,import { LocalStrategy } from './local.strategy';
Title,import { JwtStrategy } from './jwt.strategy';
Title,import { UsersModule } from '../users/users.module';
Title,import { PassportModule } from '@nestjs/passport';
Title,import { JwtModule } from '@nestjs/jwt';
Title,import { jwtConstants } from './constants';
Title,@Module({
Title,imports: [
Title,"UsersModule,"
Title,"PassportModule,"
Title,JwtModule.register({
Title,"secret: jwtConstants.secret,"
Title,"signOptions: { expiresIn: '60s' },"
Title,"}),"
Title,"],"
Title,"providers: [AuthService, LocalStrategy, JwtStrategy],"
Title,"exports: [AuthService],"
Title,})
Title,export class AuthModule {}
Title,@@switch
Title,import { Module } from '@nestjs/common';
Title,import { AuthService } from './auth.service';
Title,import { LocalStrategy } from './local.strategy';
Title,import { JwtStrategy } from './jwt.strategy';
Title,import { UsersModule } from '../users/users.module';
Title,import { PassportModule } from '@nestjs/passport';
Title,import { JwtModule } from '@nestjs/jwt';
Title,import { jwtConstants } from './constants';
Title,@Module({
Title,imports: [
Title,"UsersModule,"
Title,"PassportModule,"
Title,JwtModule.register({
Title,"secret: jwtConstants.secret,"
Title,"signOptions: { expiresIn: '60s' },"
Title,"}),"
Title,"],"
Title,"providers: [AuthService, LocalStrategy, JwtStrategy],"
Title,"exports: [AuthService],"
Title,})
Title,export class AuthModule {}
Title,```
Title,"By importing the same secret used when we signed the JWT, we ensure that the verify phase performed by Passport, and the sign phase performed in our AuthService, use a common secret."
Title,"Finally, we define the JwtAuthGuard class which extends the built-in AuthGuard:"
Title,```typescript
Title,@@filename(auth/jwt-auth.guard)
Title,import { Injectable } from '@nestjs/common';
Title,import { AuthGuard } from '@nestjs/passport';
Title,@Injectable()
Title,export class JwtAuthGuard extends AuthGuard('jwt') {}
Title,```
Title,Implement protected route and JWT strategy guards
Title,We can now implement our protected route and its associated Guard.
Title,Open the app.controller.ts file and update it as shown below:
Title,```typescript
Title,@@filename(app.controller)
Title,"import { Controller, Get, Request, Post, UseGuards } from '@nestjs/common';"
Title,import { JwtAuthGuard } from './auth/jwt-auth.guard';
Title,import { LocalAuthGuard } from './auth/local-auth.guard';
Title,import { AuthService } from './auth/auth.service';
Title,@Controller()
Title,export class AppController {
Title,constructor(private authService: AuthService) {}
Title,@UseGuards(LocalAuthGuard)
Title,@Post('auth/login')
Title,async login(@Request() req) {
Title,return this.authService.login(req.user);
Title,}
Title,@UseGuards(JwtAuthGuard)
Title,@Get('profile')
Title,getProfile(@Request() req) {
Title,return req.user;
Title,}
Title,}
Title,@@switch
Title,"import { Controller, Dependencies, Bind, Get, Request, Post, UseGuards } from '@nestjs/common';"
Title,import { JwtAuthGuard } from './auth/jwt-auth.guard';
Title,import { LocalAuthGuard } from './auth/local-auth.guard';
Title,import { AuthService } from './auth/auth.service';
Title,@Dependencies(AuthService)
Title,@Controller()
Title,export class AppController {
Title,constructor(authService) {
Title,this.authService = authService;
Title,}
Title,@UseGuards(LocalAuthGuard)
Title,@Post('auth/login')
Title,@Bind(Request())
Title,async login(req) {
Title,return this.authService.login(req.user);
Title,}
Title,@UseGuards(JwtAuthGuard)
Title,@Get('profile')
Title,@Bind(Request())
Title,getProfile(req) {
Title,return req.user;
Title,}
Title,}
Title,```
Title,"Once again, we're applying the AuthGuard that the @nestjs/passport module has automatically provisioned for us when we configured the passport-jwt module. This Guard is referenced by its default name, jwt. When our GET /profile route is hit, the Guard will automatically invoke our passport-jwt custom configured strategy, validate the JWT, and assign the user property to the Request object."
Title,"Ensure the app is running, and test the routes using cURL."
Title,```bash
Title,$ # GET /profile
Title,$ curl http://localhost:3000/profile
Title,"$ # result -> {""statusCode"":401,""message"":""Unauthorized""}"
Title,$ # POST /auth/login
Title,"$ curl -X POST http://localhost:3000/auth/login -d '{""username"": ""john"", ""password"": ""changeme""}' -H ""Content-Type: application/json"""
Title,"$ # result -> {""access_token"":""eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm... }"
Title,$ # GET /profile using access_token returned from previous step as bearer code
Title,"$ curl http://localhost:3000/profile -H ""Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm..."""
Title,"$ # result -> {""userId"":1,""username"":""john""}"
Title,```
Title,"Note that in the AuthModule, we configured the JWT to have an expiration of 60 seconds. This is probably too short an expiration, and dealing with the details of token expiration and refresh is beyond the scope of this article. However, we chose that to demonstrate an important quality of JWTs and the passport-jwt strategy. If you wait 60 seconds after authenticating before attempting a GET /profile request, you'll receive a 401 Unauthorized response. This is because Passport automatically checks the JWT for its expiration time, saving you the trouble of doing so in your application."
Title,"We've now completed our JWT authentication implementation. JavaScript clients (such as Angular/React/Vue), and other JavaScript apps, can now authenticate and communicate securely with our API Server."
Title,Extending guards
Title,"In most cases, using a provided AuthGuard class is sufficient. However, there might be use-cases when you would like to simply extend the default error handling or authentication logic. For this, you can extend the built-in class and override methods within a sub-class."
Title,```typescript
Title,import {
Title,"ExecutionContext,"
Title,"Injectable,"
Title,"UnauthorizedException,"
Title,} from '@nestjs/common';
Title,import { AuthGuard } from '@nestjs/passport';
Title,@Injectable()
Title,export class JwtAuthGuard extends AuthGuard('jwt') {
Title,canActivate(context: ExecutionContext) {
Title,// Add your custom authentication logic here
Title,"// for example, call super.logIn(request) to establish a session."
Title,return super.canActivate(context);
Title,}
Title,"handleRequest(err, user, info) {"
Title,"// You can throw an exception based on either ""info"" or ""err"" arguments"
Title,if (err || !user) {
Title,throw err || new UnauthorizedException();
Title,}
Title,return user;
Title,}
Title,}
Title,```
Title,"In addition to extending the default error handling and authentication logic, we can allow authentication to go through a chain of strategies. The first strategy to succeed, redirect, or error will halt the chain. Authentication failures will proceed through each strategy in series, ultimately failing if all strategies fail."
Title,typescript
Title,"export class JwtAuthGuard extends AuthGuard(['strategy_jwt_1', 'strategy_jwt_2', '...']) { ... }"
Title,Enable authentication globally
Title,"If the vast majority of your endpoints should be protected by default, you can register the authentication guard as a global guard and instead of using @UseGuards() decorator on top of each controller, you could simply flag which routes should be public."
Title,"First, register the JwtAuthGuard as a global guard using the following construction (in any module):"
Title,typescript
Title,providers: [
Title,{
Title,"provide: APP_GUARD,"
Title,"useClass: JwtAuthGuard,"
Title,"},"
Title,"],"
Title,"With this in place, Nest will automatically bind JwtAuthGuard to all endpoints."
Title,"Now we must provide a mechanism for declaring routes as public. For this, we can create a custom decorator using the SetMetadata decorator factory function."
Title,```typescript
Title,import { SetMetadata } from '@nestjs/common';
Title,export const IS_PUBLIC_KEY = 'isPublic';
Title,"export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);"
Title,```
Title,"In the file above, we exported two constants. One being our metadata key named IS_PUBLIC_KEY, and the other being our new decorator itself that we’re going to call Public (you can alternatively name it SkipAuth or AllowAnon, whatever fits your project)."
Title,"Now that we have a custom @Public() decorator, we can use it to decorate any method, as follows:"
Title,typescript
Title,@Public()
Title,@Get()
Title,findAll() {
Title,return [];
Title,}
Title,"Lastly, we need the JwtAuthGuard to return true when the ""isPublic"" metadata is found. For this, we'll use the Reflector class (read more here)."
Title,```typescript
Title,@Injectable()
Title,export class JwtAuthGuard extends AuthGuard('jwt') {
Title,constructor(private reflector: Reflector) {
Title,super();
Title,}
Title,canActivate(context: ExecutionContext) {
Title,"const isPublic = this.reflector.getAllAndOverride(IS_PUBLIC_KEY, ["
Title,"context.getHandler(),"
Title,"context.getClass(),"
Title,]);
Title,if (isPublic) {
Title,return true;
Title,}
Title,return super.canActivate(context);
Title,}
Title,}
Title,```
Title,Request-scoped strategies
Title,"The passport API is based on registering strategies to the global instance of the library. Therefore strategies are not designed to have request-dependent options or to be dynamically instantiated per request (read more about the request-scoped providers). When you configure your strategy to be request-scoped, Nest will never instantiate it since it's not tied to any specific route. There is no physical way to determine which ""request-scoped"" strategies should be executed per request."
Title,"However, there are ways to dynamically resolve request-scoped providers within the strategy. For this, we leverage the module reference feature."
Title,"First, open the local.strategy.ts file and inject the ModuleRef in the normal way:"
Title,typescript
Title,constructor(private moduleRef: ModuleRef) {
Title,super({
Title,"passReqToCallback: true,"
Title,});
Title,}
Title,
Title,info Hint The ModuleRef class is imported from the @nestjs/core package.
Title,
Title,"Be sure to set the passReqToCallback configuration property to true, as shown above."
Title,"In the next step, the request instance will be used to obtain the current context identifier, instead of generating a new one (read more about request context here)."
Title,"Now, inside the validate() method of the LocalStrategy class, use the getByRequest() method of the ContextIdFactory class to create a context id based on the request object, and pass this to the resolve() call:"
Title,typescript
Title,async validate(
Title,"request: Request,"
Title,"username: string,"
Title,"password: string,"
Title,) {
Title,const contextId = ContextIdFactory.getByRequest(request);
Title,"// ""AuthService"" is a request-scoped provider"
Title,"const authService = await this.moduleRef.resolve(AuthService, contextId);"
Title,...
Title,}
Title,"In the example above, the resolve() method will asynchronously return the request-scoped instance of the AuthService provider (we assumed that AuthService is marked as a request-scoped provider)."
Title,Customize Passport
Title,"Any standard Passport customization options can be passed the same way, using the register() method. The available options depend on the strategy being implemented. For example:"
Title,typescript
Title,PassportModule.register({ session: true });
Title,You can also pass strategies an options object in their constructors to configure them.
Title,For the local strategy you can pass e.g.:
Title,typescript
Title,constructor(private authService: AuthService) {
Title,super({
Title,"usernameField: 'email',"
Title,"passwordField: 'password',"
Title,});
Title,}
Title,Take a look at the official Passport Website for property names.
Title,Named strategies
Title,"When implementing a strategy, you can provide a name for it by passing a second argument to the PassportStrategy function. If you don't do this, each strategy will have a default name (e.g., 'jwt' for jwt-strategy):"
Title,typescript
Title,"export class JwtStrategy extends PassportStrategy(Strategy, 'myjwt')"
Title,"Then, you refer to this via a decorator like @UseGuards(AuthGuard('myjwt'))."
Title,GraphQL
Title,"In order to use an AuthGuard with GraphQL, extend the built-in AuthGuard class and override the getRequest() method."
Title,typescript
Title,@Injectable()
Title,export class GqlAuthGuard extends AuthGuard('jwt') {
Title,getRequest(context: ExecutionContext) {
Title,const ctx = GqlExecutionContext.create(context);
Title,return ctx.getContext().req;
Title,}
Title,}
Title,"To get the current authenticated user in your graphql resolver, you can define a @CurrentUser() decorator:"
Title,```typescript
Title,"import { createParamDecorator, ExecutionContext } from '@nestjs/common';"
Title,import { GqlExecutionContext } from '@nestjs/graphql';
Title,export const CurrentUser = createParamDecorator(
Title,"(data: unknown, context: ExecutionContext) => {"
Title,const ctx = GqlExecutionContext.create(context);
Title,return ctx.getContext().req.user;
Title,"},"
Title,);
Title,```
Title,"To use above decorator in your resolver, be sure to include it as a parameter of your query or mutation:"
Title,typescript
Title,@Query(() => User)
Title,@UseGuards(GqlAuthGuard)
Title,whoAmI(@CurrentUser() user: User) {
Title,return this.usersService.findById(user.id);
Title,}
Title,"For the passport-local strategy, you'll also need to add the GraphQL context's arguments to the request body so Passport can access them for validation. Otherwise, you'll get an Unauthorized error."
Title,```typescript
Title,@Injectable()
Title,export class GqlLocalAuthGuard extends AuthGuard('local') {
Title,getRequest(context: ExecutionContext) {
Title,const gqlExecutionContext = GqlExecutionContext.create(context);
Title,const gqlContext = gqlExecutionContext.getContext();
Title,const gqlArgs = gqlExecutionContext.getArgs();
Title,"gqlContext.req.body = { ...gqlContext.req.body, ...gqlArgs };"
Title,return gqlContext.req;
Title,
Title,}
Title,}
Title,```
Title,
Title,Prisma
Title,"Prisma is an open-source ORM for Node.js and TypeScript. It is used as an alternative to writing plain SQL, or using another database access tool such as SQL query builders (like knex.js) or ORMs (like TypeORM and Sequelize). Prisma currently supports PostgreSQL, MySQL, SQL Server, SQLite, MongoDB and CockroachDB (Preview)."
Title,"While Prisma can be used with plain JavaScript, it embraces TypeScript and provides a level to type-safety that goes beyond the guarantees other ORMs in the TypeScript ecosystem. You can find an in-depth comparison of the type-safety guarantees of Prisma and TypeORM here."
Title,
Title,"info Note If you want to get a quick overview of how Prisma works, you can follow the Quickstart or read the Introduction in the documentation. There also are ready-to-run examples for REST and GraphQL in the prisma-examples repo."
Title,
Title,Getting started
Title,"In this recipe, you'll learn how to get started with NestJS and Prisma from scratch. You are going to build a sample NestJS application with a REST API that can read and write data in a database."
Title,"For the purpose of this guide, you'll use a SQLite database to save the overhead of setting up a database server. Note that you can still follow this guide, even if you're using PostgreSQL or MySQL – you'll get extra instructions for using these databases at the right places."
Title,
Title,"info Note If you already have an existing project and consider migrating to Prisma, you can follow the guide for adding Prisma to an existing project. If you are migrating from TypeORM, you can read the guide Migrating from TypeORM to Prisma."
Title,
Title,Create your NestJS project
Title,"To get started, install the NestJS CLI and create your app skeleton with the following commands:"
Title,bash
Title,$ npm install -g @nestjs/cli
Title,$ nest new hello-prisma
Title,"See the First steps page to learn more about the project files created by this command. Note also that you can now run npm start to start your application. The REST API running at http://localhost:3000/ currently serves a single route that's implemented in src/app.controller.ts. Over the course of this guide, you'll implement additional routes to store and retrieve data about users and posts."
Title,Set up Prisma
Title,Start by installing the Prisma CLI as a development dependency in your project:
Title,bash
Title,$ cd hello-prisma
Title,$ npm install prisma --save-dev
Title,"In the following steps, we'll be utilizing the Prisma CLI. As a best practice, it's recommended to invoke the CLI locally by prefixing it with npx:"
Title,bash
Title,$ npx prisma
Title,Expand if you're using Yarn
Title,
Title,"If you're using Yarn, then you can install the Prisma CLI as follows:"
Title,
Title,```bash
Title,$ yarn add prisma --dev
Title,```
Title,
Title,"Once installed, you can invoke it by prefixing it with `yarn`:"
Title,
Title,```bash
Title,$ yarn prisma
Title,```
Title,
Title,
Title,Now create your initial Prisma setup using the init command of the Prisma CLI:
Title,bash
Title,$ npx prisma init
Title,This command creates a new prisma directory with the following contents:
Title,
Title,schema.prisma: Specifies your database connection and contains the database schema
Title,".env: A dotenv file, typically used to store your database credentials in a group of environment variables"
Title,
Title,Set the database connection
Title,"Your database connection is configured in the datasource block in your schema.prisma file. By default it's set to postgresql, but since you're using a SQLite database in this guide you need to adjust the provider field of the datasource block to sqlite:"
Title,```groovy
Title,datasource db {
Title,"provider = ""sqlite"""
Title,"url      = env(""DATABASE_URL"")"
Title,}
Title,generator client {
Title,"provider = ""prisma-client-js"""
Title,}
Title,```
Title,"Now, open up .env and adjust the DATABASE_URL environment variable to look as follows:"
Title,bash
Title,"DATABASE_URL=""file:./dev.db"""
Title,"Make sure you have a ConfigModule configured, otherwise the DATABASE_URL variable will not be picked up from .env."
Title,"SQLite databases are simple files; no server is required to use a SQLite database. So instead of configuring a connection URL with a host and port, you can just point it to a local file which in this case is called dev.db. This file will be created in the next step."
Title,"Expand if you're using PostgreSQL, MySQL, MsSQL or Azure SQL"
Title,
Title,"With PostgreSQL and MySQL, you need to configure the connection URL to point to the _database server_. You can learn more about the required connection URL format [here](https://www.prisma.io/docs/reference/database-reference/connection-urls)."
Title,
Title,**PostgreSQL**
Title,
Title,"If you're using PostgreSQL, you have to adjust the `schema.prisma` and `.env` files as follows:"
Title,
Title,**`schema.prisma`**
Title,
Title,```groovy
Title,datasource db {
Title,"provider = ""postgresql"""
Title,"url      = env(""DATABASE_URL"")"
Title,}
Title,
Title,generator client {
Title,"provider = ""prisma-client-js"""
Title,}
Title,```
Title,
Title,**`.env`**
Title,
Title,```bash
Title,"DATABASE_URL=""postgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=SCHEMA"""
Title,```
Title,
Title,"Replace the placeholders spelled in all uppercase letters with your database credentials. Note that if you're unsure what to provide for the `SCHEMA` placeholder, it's most likely the default value `public`:"
Title,
Title,```bash
Title,"DATABASE_URL=""postgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=public"""
Title,```
Title,
Title,"If you want to learn how to set up a PostgreSQL database, you can follow this guide on [setting up a free PostgreSQL database on Heroku](https://dev.to/prisma/how-to-setup-a-free-postgresql-database-on-heroku-1dc1)."
Title,
Title,**MySQL**
Title,
Title,"If you're using MySQL, you have to adjust the `schema.prisma` and `.env` files as follows:"
Title,
Title,**`schema.prisma`**
Title,
Title,```groovy
Title,datasource db {
Title,"provider = ""mysql"""
Title,"url      = env(""DATABASE_URL"")"
Title,}
Title,
Title,generator client {
Title,"provider = ""prisma-client-js"""
Title,}
Title,```
Title,
Title,**`.env`**
Title,
Title,```bash
Title,"DATABASE_URL=""mysql://USER:PASSWORD@HOST:PORT/DATABASE"""
Title,```
Title,
Title,Replace the placeholders spelled in all uppercase letters with your database credentials.
Title,
Title,**Microsoft SQL Server / Azure SQL Server**
Title,
Title,"If you're using Microsoft SQL Server or Azure SQL Server, you have to adjust the `schema.prisma` and `.env` files as follows:"
Title,
Title,**`schema.prisma`**
Title,
Title,```groovy
Title,datasource db {
Title,"provider = ""sqlserver"""
Title,"url      = env(""DATABASE_URL"")"
Title,}
Title,
Title,generator client {
Title,"provider = ""prisma-client-js"""
Title,}
Title,```
Title,
Title,**`.env`**
Title,
Title,"Replace the placeholders spelled in all uppercase letters with your database credentials. Note that if you're unsure what to provide for the `encrypt` placeholder, it's most likely the default value `true`:"
Title,
Title,```bash
Title,"DATABASE_URL=""sqlserver://HOST:PORT;database=DATABASE;user=USER;password=PASSWORD;encrypt=true"""
Title,```
Title,
Title,
Title,Create two database tables with Prisma Migrate
Title,"In this section, you'll create two new tables in your database using Prisma Migrate. Prisma Migrate generates SQL migration files for your declarative data model definition in the Prisma schema. These migration files are fully customizable so that you can configure any additional features of the underlying database or include additional commands, e.g. for seeding."
Title,Add the following two models to your schema.prisma file:
Title,```groovy
Title,model User {
Title,id    Int     @default(autoincrement()) @id
Title,email String  @unique
Title,name  String?
Title,posts Post[]
Title,}
Title,model Post {
Title,id        Int      @default(autoincrement()) @id
Title,title     String
Title,content   String?
Title,published Boolean? @default(false)
Title,"author    User?    @relation(fields: [authorId], references: [id])"
Title,authorId  Int?
Title,}
Title,```
Title,"With your Prisma models in place, you can generate your SQL migration files and run them against the database. Run the following commands in your terminal:"
Title,bash
Title,$ npx prisma migrate dev --name init
Title,"This prisma migrate dev command generates SQL files and directly runs them against the database. In this case, the following migration files was created in the existing prisma directory:"
Title,bash
Title,$ tree prisma
Title,prisma
Title,├── dev.db
Title,├── migrations
Title,│   └── 20201207100915_init
Title,│       └── migration.sql
Title,└── schema.prisma
Title,Expand to view the generated SQL statements
Title,
Title,The following tables were created in your SQLite database:
Title,
Title,```sql
Title,-- CreateTable
Title,"CREATE TABLE ""User"" ("
Title,"""id"" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,"
Title,"""email"" TEXT NOT NULL,"
Title,"""name"" TEXT"
Title,);
Title,
Title,-- CreateTable
Title,"CREATE TABLE ""Post"" ("
Title,"""id"" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,"
Title,"""title"" TEXT NOT NULL,"
Title,"""content"" TEXT,"
Title,"""published"" BOOLEAN DEFAULT false,"
Title,"""authorId"" INTEGER,"
Title,
Title,"FOREIGN KEY (""authorId"") REFERENCES ""User""(""id"") ON DELETE SET NULL ON UPDATE CASCADE"
Title,);
Title,
Title,-- CreateIndex
Title,"CREATE UNIQUE INDEX ""User.email_unique"" ON ""User""(""email"");"
Title,```
Title,
Title,
Title,Install and generate Prisma Client
Title,"Prisma Client is a type-safe database client that's generated from your Prisma model definition. Because of this approach, Prisma Client can expose CRUD operations that are tailored specifically to your models."
Title,"To install Prisma Client in your project, run the following command in your terminal:"
Title,bash
Title,$ npm install @prisma/client
Title,"Note that during installation, Prisma automatically invokes the prisma generate command for you. In the future, you need to run this command after every change to your Prisma models to update your generated Prisma Client."
Title,
Title,info Note The prisma generate command reads your Prisma schema and updates the generated Prisma Client library inside node_modules/@prisma/client.
Title,
Title,Use Prisma Client in your NestJS services
Title,"You're now able to send database queries with Prisma Client. If you want to learn more about building queries with Prisma Client, check out the API documentation."
Title,"When setting up your NestJS application, you'll want to abstract away the Prisma Client API for database queries within a service. To get started, you can create a new PrismaService that takes care of instantiating PrismaClient and connecting to your database."
Title,"Inside the src directory, create a new file called prisma.service.ts and add the following code to it:"
Title,```typescript
Title,"import { Injectable, OnModuleInit } from '@nestjs/common';"
Title,import { PrismaClient } from '@prisma/client';
Title,@Injectable()
Title,export class PrismaService extends PrismaClient implements OnModuleInit {
Title,async onModuleInit() {
Title,await this.$connect();
Title,}
Title,}
Title,```
Title,
Title,"info Note The onModuleInit is optional — if you leave it out, Prisma will connect lazily on its first call to the database."
Title,
Title,"Next, you can write services that you can use to make database calls for the User and Post models from your Prisma schema."
Title,"Still inside the src directory, create a new file called user.service.ts and add the following code to it:"
Title,```typescript
Title,import { Injectable } from '@nestjs/common';
Title,import { PrismaService } from './prisma.service';
Title,"import { User, Prisma } from '@prisma/client';"
Title,@Injectable()
Title,export class UserService {
Title,constructor(private prisma: PrismaService) {}
Title,async user(
Title,"userWhereUniqueInput: Prisma.UserWhereUniqueInput,"
Title,): Promise {
Title,return this.prisma.user.findUnique({
Title,"where: userWhereUniqueInput,"
Title,});
Title,}
Title,async users(params: {
Title,skip?: number;
Title,take?: number;
Title,cursor?: Prisma.UserWhereUniqueInput;
Title,where?: Prisma.UserWhereInput;
Title,orderBy?: Prisma.UserOrderByWithRelationInput;
Title,}): Promise {
Title,"const { skip, take, cursor, where, orderBy } = params;"
Title,return this.prisma.user.findMany({
Title,"skip,"
Title,"take,"
Title,"cursor,"
Title,"where,"
Title,"orderBy,"
Title,});
Title,}
Title,async createUser(data: Prisma.UserCreateInput): Promise {
Title,return this.prisma.user.create({
Title,"data,"
Title,});
Title,}
Title,async updateUser(params: {
Title,where: Prisma.UserWhereUniqueInput;
Title,data: Prisma.UserUpdateInput;
Title,}): Promise {
Title,"const { where, data } = params;"
Title,return this.prisma.user.update({
Title,"data,"
Title,"where,"
Title,});
Title,}
Title,async deleteUser(where: Prisma.UserWhereUniqueInput): Promise {
Title,return this.prisma.user.delete({
Title,"where,"
Title,});
Title,}
Title,}
Title,```
Title,Notice how you're using Prisma Client's generated types to ensure that the methods that are exposed by your service are properly typed. You therefore save the boilerplate of typing your models and creating additional interface or DTO files.
Title,Now do the same for the Post model.
Title,"Still inside the src directory, create a new file called post.service.ts and add the following code to it:"
Title,```typescript
Title,import { Injectable } from '@nestjs/common';
Title,import { PrismaService } from './prisma.service';
Title,"import { Post, Prisma } from '@prisma/client';"
Title,@Injectable()
Title,export class PostService {
Title,constructor(private prisma: PrismaService) {}
Title,async post(
Title,"postWhereUniqueInput: Prisma.PostWhereUniqueInput,"
Title,): Promise {
Title,return this.prisma.post.findUnique({
Title,"where: postWhereUniqueInput,"
Title,});
Title,}
Title,async posts(params: {
Title,skip?: number;
Title,take?: number;
Title,cursor?: Prisma.PostWhereUniqueInput;
Title,where?: Prisma.PostWhereInput;
Title,orderBy?: Prisma.PostOrderByWithRelationInput;
Title,}): Promise {
Title,"const { skip, take, cursor, where, orderBy } = params;"
Title,return this.prisma.post.findMany({
Title,"skip,"
Title,"take,"
Title,"cursor,"
Title,"where,"
Title,"orderBy,"
Title,});
Title,}
Title,async createPost(data: Prisma.PostCreateInput): Promise {
Title,return this.prisma.post.create({
Title,"data,"
Title,});
Title,}
Title,async updatePost(params: {
Title,where: Prisma.PostWhereUniqueInput;
Title,data: Prisma.PostUpdateInput;
Title,}): Promise {
Title,"const { data, where } = params;"
Title,return this.prisma.post.update({
Title,"data,"
Title,"where,"
Title,});
Title,}
Title,async deletePost(where: Prisma.PostWhereUniqueInput): Promise {
Title,return this.prisma.post.delete({
Title,"where,"
Title,});
Title,}
Title,}
Title,```
Title,"Your UserService and PostService currently wrap the CRUD queries that are available in Prisma Client. In a real world application, the service would also be the place to add business logic to your application. For example, you could have a method called updatePassword inside the UserService that would be responsible for updating the password of a user."
Title,Remember to register the new services in the app module.
Title,Implement your REST API routes in the main app controller
Title,"Finally, you'll use the services you created in the previous sections to implement the different routes of your app. For the purpose of this guide, you'll put all your routes into the already existing AppController class."
Title,Replace the contents of the app.controller.ts file with the following code:
Title,```typescript
Title,import {
Title,"Controller,"
Title,"Get,"
Title,"Param,"
Title,"Post,"
Title,"Body,"
Title,"Put,"
Title,"Delete,"
Title,} from '@nestjs/common';
Title,import { UserService } from './user.service';
Title,import { PostService } from './post.service';
Title,"import { User as UserModel, Post as PostModel } from '@prisma/client';"
Title,@Controller()
Title,export class AppController {
Title,constructor(
Title,"private readonly userService: UserService,"
Title,"private readonly postService: PostService,"
Title,) {}
Title,@Get('post/:id')
Title,async getPostById(@Param('id') id: string): Promise {
Title,return this.postService.post({ id: Number(id) });
Title,}
Title,@Get('feed')
Title,async getPublishedPosts(): Promise {
Title,return this.postService.posts({
Title,"where: { published: true },"
Title,});
Title,}
Title,@Get('filtered-posts/:searchString')
Title,async getFilteredPosts(
Title,"@Param('searchString') searchString: string,"
Title,): Promise {
Title,return this.postService.posts({
Title,where: {
Title,OR: [
Title,{
Title,"title: { contains: searchString },"
Title,"},"
Title,{
Title,"content: { contains: searchString },"
Title,"},"
Title,"],"
Title,"},"
Title,});
Title,}
Title,@Post('post')
Title,async createDraft(
Title,"@Body() postData: { title: string; content?: string; authorEmail: string },"
Title,): Promise {
Title,"const { title, content, authorEmail } = postData;"
Title,return this.postService.createPost({
Title,"title,"
Title,"content,"
Title,author: {
Title,"connect: { email: authorEmail },"
Title,"},"
Title,});
Title,}
Title,@Post('user')
Title,async signupUser(
Title,"@Body() userData: { name?: string; email: string },"
Title,): Promise {
Title,return this.userService.createUser(userData);
Title,}
Title,@Put('publish/:id')
Title,async publishPost(@Param('id') id: string): Promise {
Title,return this.postService.updatePost({
Title,"where: { id: Number(id) },"
Title,"data: { published: true },"
Title,});
Title,}
Title,@Delete('post/:id')
Title,async deletePost(@Param('id') id: string): Promise {
Title,return this.postService.deletePost({ id: Number(id) });
Title,}
Title,}
Title,```
Title,This controller implements the following routes:
Title,GET
Title,
Title,/post/:id: Fetch a single post by its id
Title,/feed: Fetch all published posts
Title,/filter-posts/:searchString: Filter posts by title or content
Title,
Title,POST
Title,
Title,/post: Create a new post
Title,Body:
Title,title: String (required): The title of the post
Title,content: String (optional): The content of the post
Title,authorEmail: String (required): The email of the user that creates the post
Title,
Title,
Title,/user: Create a new user
Title,Body:
Title,email: String (required): The email address of the user
Title,name: String (optional): The name of the user
Title,
Title,
Title,
Title,PUT
Title,
Title,/publish/:id: Publish a post by its id
Title,
Title,DELETE
Title,
Title,/post/:id: Delete a post by its id
Title,
Title,Summary
Title,"In this recipe, you learned how to use Prisma along with NestJS to implement a REST API. The controller that implements the routes of the API is calling a PrismaService which in turn uses Prisma Client to send queries to a database to fulfill the data needs of incoming requests."
Title,"If you want to learn more about using NestJS with Prisma, be sure to check out the following resources:"
Title,
Title,NestJS & Prisma
Title,Ready-to-run example projects for REST & GraphQL
Title,Production-ready starter kit
Title,Video: Accessing Databases using NestJS with Prisma (5min) by Marc Stammerjohann
Title,
Title,
Title,Read-Eval-Print-Loop (REPL)
Title,"REPL is a simple interactive environment that takes single user inputs, executes them, and returns the result to the user."
Title,The REPL feature lets you inspect your dependency graph and call methods on your providers (and controllers) directly from your terminal.
Title,Usage
Title,"To run your NestJS application in REPL mode, create a new repl.ts file (alongside the existing main.ts file) and add the following code inside:"
Title,```typescript
Title,@@filename(repl)
Title,import { repl } from '@nestjs/core';
Title,import { AppModule } from './src/app.module';
Title,async function bootstrap() {
Title,await repl(AppModule);
Title,}
Title,bootstrap();
Title,@@switch
Title,import { repl } from '@nestjs/core';
Title,import { AppModule } from './src/app.module';
Title,async function bootstrap() {
Title,await repl(AppModule);
Title,}
Title,bootstrap();
Title,```
Title,"Now in your terminal, start the REPL with the following command:"
Title,bash
Title,$ npm run start -- --entryFile repl
Title,
Title,info Hint repl returns a Node.js REPL server object.
Title,
Title,"Once it's up and running, you should see the following message in your console:"
Title,bash
Title,LOG [NestFactory] Starting Nest application...
Title,LOG [InstanceLoader] AppModule dependencies initialized
Title,LOG REPL initialized
Title,"And now you can start interacting with your dependencies graph. For instance, you can retrieve an AppService (we are using the starter project as an example here) and call the getHello() method:"
Title,```typescript
Title,
Title,get(AppService).getHello()
Title,'Hello World!'
Title,```
Title,
Title,"You can execute any JavaScript code from within your terminal, for example, assign an instance of the AppController to a local variable, and use await to call an asynchronous method:"
Title,```typescript
Title,
Title,appController = get(AppController)
Title,AppController { appService: AppService {} }
Title,await appController.getHello()
Title,'Hello World!'
Title,```
Title,
Title,"To display all public methods available on a given provider or controller, use the methods() function, as follows:"
Title,```typescript
Title,
Title,methods(AppController)
Title,
Title,Methods:
Title,◻ getHello
Title,```
Title,"To print all registered modules as a list together with their controllers and providers, use debug()."
Title,```typescript
Title,
Title,debug()
Title,
Title,AppModule:
Title,- controllers:
Title,◻ AppController
Title,- providers:
Title,◻ AppService
Title,```
Title,Quick demo:
Title,
Title,"You can find more information about the existing, predefined native methods in the section below."
Title,Native functions
Title,The built-in NestJS REPL comes with a few native functions that are globally available when you start REPL. You can call help() to list them out.
Title,"If you don't recall what's the signature (ie: expected parameters and a return type) of a function, you can call <function_name>.help."
Title,For instance:
Title,```text
Title,
Title,$.help
Title,"Retrieves an instance of either injectable or controller, otherwise, throws exception."
Title,Interface: $(token: InjectionToken) => any
Title,```
Title,info Hint Those function interfaces are written in TypeScript function type expression syntax.
Title,
Title,| Function     | Description                                                                                                        | Signature                                                             |
Title,| ------------ | ------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------- |
Title,| debug      | Print all registered modules as a list together with their controllers and providers.                              | debug(moduleCls?: ClassRef \| string) => void                       |
Title,"| get or $ | Retrieves an instance of either injectable or controller, otherwise, throws exception.                             | get(token: InjectionToken) => any                                   |"
Title,| methods    | Display all public methods available on a given provider or controller.                                            | methods(token: ClassRef \| string) => void                          |
Title,"| resolve    | Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.     | resolve(token: InjectionToken, contextId: any) => Promise<any>      |"
Title,"| select     | Allows navigating through the modules tree, for example, to pull out a specific instance from the selected module. | select(token: DynamicModule \| ClassRef) => INestApplicationContext |"
Title,Watch mode
Title,During development it is useful to run REPL in a watch mode to reflect all the code changes automatically:
Title,bash
Title,$ npm run start -- --watch --entryFile repl
Title,"This has one flaw, the REPL's command history is discarded after each reload which might be cumbersome."
Title,"Fortunately, there is a very simple solution. Modify your bootstrap function like this:"
Title,typescript
Title,async function bootstrap() {
Title,const replServer = await repl(AppModule);
Title,"replServer.setupHistory("".nestjs_repl_history"", (err) => {"
Title,if (err) {
Title,console.error(err);
Title,}
Title,});
Title,}
Title,Now the history is preserved between the runs/reloads.
Title,
Title,Router module
Title,
Title,info Hint This chapter is only relevant to HTTP-based applications.
Title,
Title,"In an HTTP application (for example, REST API), the route path for a handler is determined by concatenating the (optional) prefix declared for the controller (inside the @Controller decorator),"
Title,"and any path specified in the method's decorator (e.g, @Get('users')). You can learn more about that in this section. Additionally,"
Title,"you can define a global prefix for all routes registered in your application, or enable versioning."
Title,"Also, there are edge-cases when defining a prefix at a module-level (and so for all controllers registered inside that module) may come in handy."
Title,"For example, imagine a REST application that exposes several different endpoints being used by a specific portion of your application called ""Dashboard""."
Title,"In such a case, instead of repeating the /dashboard prefix within each controller, you could use a utility RouterModule module, as follows:"
Title,typescript
Title,@Module({
Title,imports: [
Title,"DashboardModule,"
Title,RouterModule.register([
Title,{
Title,"path: 'dashboard',"
Title,"module: DashboardModule,"
Title,"},"
Title,"]),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,
Title,info Hint The RouterModule class is exported from the @nestjs/core package.
Title,
Title,"In addition, you can define hierarchical structures. This means each module can have children modules."
Title,"The children modules will inherit their parent's prefix. In the following example, we'll register the AdminModule as a parent module of DashboardModule and MetricsModule."
Title,typescript
Title,@Module({
Title,imports: [
Title,"AdminModule,"
Title,"DashboardModule,"
Title,"MetricsModule,"
Title,RouterModule.register([
Title,{
Title,"path: 'admin',"
Title,"module: AdminModule,"
Title,children: [
Title,{
Title,"path: 'dashboard',"
Title,"module: DashboardModule,"
Title,"},"
Title,{
Title,"path: 'metrics',"
Title,"module: MetricsModule,"
Title,"},"
Title,"],"
Title,"},"
Title,])
Title,"],"
Title,});
Title,
Title,"info Hint This feature should be used very carefully, as overusing it can make code difficult to maintain over time."
Title,
Title,"In the example above, any controller registered inside the DashboardModule will have an extra /admin/dashboard prefix (as the module concatenates paths from top to bottom - recursively - parent to children)."
Title,"Likewise, each controller defined inside the MetricsModule will have an additional module-level prefix /admin/metrics."
Title,
Title,Serve Static
Title,In order to serve static content like a Single Page Application (SPA) we can use the ServeStaticModule from the @nestjs/serve-static package.
Title,Installation
Title,First we need to install the required package:
Title,bash
Title,$ npm install --save @nestjs/serve-static
Title,Bootstrap
Title,"Once the installation process is done, we can import the ServeStaticModule into the root AppModule and configure it by passing in a configuration object to the forRoot() method."
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { AppController } from './app.controller';
Title,import { AppService } from './app.service';
Title,import { ServeStaticModule } from '@nestjs/serve-static';
Title,import { join } from 'path';
Title,@Module({
Title,imports: [
Title,ServeStaticModule.forRoot({
Title,"rootPath: join(__dirname, '..', 'client'),"
Title,"}),"
Title,"],"
Title,"controllers: [AppController],"
Title,"providers: [AppService],"
Title,})
Title,export class AppModule {}
Title,```
Title,"With this in place, build the static website and place its content in the location specified by the rootPath property."
Title,Configuration
Title,ServeStaticModule can be configured with a variety of options to customize its behavior.
Title,"You can set the path to render your static app, specify excluded paths, enable or disable setting Cache-Control response header, etc. See the full list of options here."
Title,
Title,"warning Notice The default renderPath of the Static App is * (all paths), and the module will send ""index.html"" files in response."
Title,"It lets you create Client-Side routing for your SPA. Paths, specified in your controllers will fallback to the server."
Title,"You can change this behavior setting serveRoot, renderPath combining them with other options."
Title,
Title,Example
Title,A working example is available here.
Title,
Title,SQL (Sequelize)
Title,This chapter applies only to TypeScript
Title,
Title,"Warning In this article, you'll learn how to create a DatabaseModule based on the Sequelize package from scratch using custom components. As a consequence, this technique contains a lot of overhead that you can avoid by using the dedicated, out-of-the-box @nestjs/sequelize package. To learn more, see here."
Title,
Title,"Sequelize is a popular Object Relational Mapper (ORM) written in a vanilla JavaScript, but there is a sequelize-typescript TypeScript wrapper which provides a set of decorators and other extras for the base sequelize."
Title,Getting started
Title,To start the adventure with this library we have to install the following dependencies:
Title,bash
Title,$ npm install --save sequelize sequelize-typescript mysql2
Title,$ npm install --save-dev @types/sequelize
Title,"The first step we need to do is create a Sequelize instance with an options object passed into the constructor. Also, we need to add all models (the alternative is to use modelPaths property) and sync() our database tables."
Title,```typescript
Title,@@filename(database.providers)
Title,import { Sequelize } from 'sequelize-typescript';
Title,import { Cat } from '../cats/cat.entity';
Title,export const databaseProviders = [
Title,{
Title,"provide: 'SEQUELIZE',"
Title,useFactory: async () => {
Title,const sequelize = new Sequelize({
Title,"dialect: 'mysql',"
Title,"host: 'localhost',"
Title,"port: 3306,"
Title,"username: 'root',"
Title,"password: 'password',"
Title,"database: 'nest',"
Title,});
Title,sequelize.addModels([Cat]);
Title,await sequelize.sync();
Title,return sequelize;
Title,"},"
Title,"},"
Title,];
Title,```
Title,
Title,"info Hint Following best practices, we declared the custom provider in the separated file which has a *.providers.ts suffix."
Title,
Title,"Then, we need to export these providers to make them accessible for the rest part of the application."
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { databaseProviders } from './database.providers';
Title,@Module({
Title,"providers: [...databaseProviders],"
Title,"exports: [...databaseProviders],"
Title,})
Title,export class DatabaseModule {}
Title,```
Title,Now we can inject the Sequelize object using @Inject() decorator. Each class that would depend on the Sequelize async provider will wait until a Promise is resolved.
Title,Model injection
Title,"In Sequelize the Model defines a table in the database. Instances of this class represent a database row. Firstly, we need at least one entity:"
Title,```typescript
Title,@@filename(cat.entity)
Title,"import { Table, Column, Model } from 'sequelize-typescript';"
Title,@Table
Title,export class Cat extends Model {
Title,@Column
Title,name: string;
Title,@Column
Title,age: number;
Title,@Column
Title,breed: string;
Title,}
Title,```
Title,The Cat entity belongs to the cats directory. This directory represents the CatsModule. Now it's time to create a Repository provider:
Title,```typescript
Title,@@filename(cats.providers)
Title,import { Cat } from './cat.entity';
Title,export const catsProviders = [
Title,{
Title,"provide: 'CATS_REPOSITORY',"
Title,"useValue: Cat,"
Title,"},"
Title,];
Title,```
Title,
Title,warning Warning In the real-world applications you should avoid magic strings. Both CATS_REPOSITORY and SEQUELIZE should be kept in the separated constants.ts file.
Title,
Title,"In Sequelize, we use static methods to manipulate the data, and thus we created an alias here."
Title,Now we can inject the CATS_REPOSITORY to the CatsService using the @Inject() decorator:
Title,```typescript
Title,@@filename(cats.service)
Title,"import { Injectable, Inject } from '@nestjs/common';"
Title,import { CreateCatDto } from './dto/create-cat.dto';
Title,import { Cat } from './cat.entity';
Title,@Injectable()
Title,export class CatsService {
Title,constructor(
Title,@Inject('CATS_REPOSITORY')
Title,private catsRepository: typeof Cat
Title,) {}
Title,async findAll(): Promise {
Title,return this.catsRepository.findAll();
Title,}
Title,}
Title,```
Title,"The database connection is asynchronous, but Nest makes this process completely invisible for the end-user. The CATS_REPOSITORY provider is waiting for the db connection, and the CatsService is delayed until repository is ready to use. The entire application can start when each class is instantiated."
Title,Here is a final CatsModule:
Title,```typescript
Title,@@filename(cats.module)
Title,import { Module } from '@nestjs/common';
Title,import { CatsController } from './cats.controller';
Title,import { CatsService } from './cats.service';
Title,import { catsProviders } from './cats.providers';
Title,import { DatabaseModule } from '../database/database.module';
Title,@Module({
Title,"imports: [DatabaseModule],"
Title,"controllers: [CatsController],"
Title,providers: [
Title,"CatsService,"
Title,"...catsProviders,"
Title,"],"
Title,})
Title,export class CatsModule {}
Title,```
Title,
Title,info Hint Do not forget to import the CatsModule into the root AppModule.
Title,
Title,
Title,SQL (TypeORM)
Title,This chapter applies only to TypeScript
Title,
Title,"Warning In this article, you'll learn how to create a DatabaseModule based on the TypeORM package from scratch using custom providers mechanism. As a consequence, this solution contains a lot of overhead that you can omit using ready to use and available out-of-the-box dedicated @nestjs/typeorm package. To learn more, see here."
Title,
Title,"TypeORM is definitely the most mature Object Relational Mapper (ORM) available in the node.js world. Since it's written in TypeScript, it works pretty well with the Nest framework."
Title,Getting started
Title,To start the adventure with this library we have to install all required dependencies:
Title,bash
Title,$ npm install --save typeorm mysql2
Title,"The first step we need to do is to establish the connection with our database using new DataSource().initialize() class imported from the typeorm package. The initialize() function returns a Promise, and therefore we have to create an async provider."
Title,```typescript
Title,@@filename(database.providers)
Title,import { DataSource } from 'typeorm';
Title,export const databaseProviders = [
Title,{
Title,"provide: 'DATA_SOURCE',"
Title,useFactory: async () => {
Title,const dataSource = new DataSource({
Title,"type: 'mysql',"
Title,"host: 'localhost',"
Title,"port: 3306,"
Title,"username: 'root',"
Title,"password: 'root',"
Title,"database: 'test',"
Title,entities: [
Title,"__dirname + '/../*/.entity{.ts,.js}',"
Title,"],"
Title,"synchronize: true,"
Title,});
Title,return dataSource.initialize();
Title,"},"
Title,
Title,"},"
Title,];
Title,```
Title,
Title,warning Warning Setting synchronize: true shouldn't be used in production - otherwise you can lose production data.
Title,"info Hint Following best practices, we declared the custom provider in the separated file which has a *.providers.ts suffix."
Title,
Title,"Then, we need to export these providers to make them accessible for the rest of the application."
Title,```typescript
Title,@@filename(database.module)
Title,import { Module } from '@nestjs/common';
Title,import { databaseProviders } from './database.providers';
Title,@Module({
Title,"providers: [...databaseProviders],"
Title,"exports: [...databaseProviders],"
Title,})
Title,export class DatabaseModule {}
Title,```
Title,Now we can inject the DATA_SOURCE object using @Inject() decorator. Each class that would depend on the DATA_SOURCE async provider will wait until a Promise is resolved.
Title,Repository pattern
Title,"The TypeORM supports the repository design pattern, thus each entity has its own Repository. These repositories can be obtained from the database connection."
Title,"But firstly, we need at least one entity. We are going to reuse the Photo entity from the official documentation."
Title,```typescript
Title,@@filename(photo.entity)
Title,"import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';"
Title,@Entity()
Title,export class Photo {
Title,@PrimaryGeneratedColumn()
Title,id: number;
Title,@Column({ length: 500 })
Title,name: string;
Title,@Column('text')
Title,description: string;
Title,@Column()
Title,filename: string;
Title,@Column('int')
Title,views: number;
Title,@Column()
Title,isPublished: boolean;
Title,}
Title,```
Title,"The Photo entity belongs to the photo directory. This directory represents the PhotoModule. Now, let's create a Repository provider:"
Title,```typescript
Title,@@filename(photo.providers)
Title,import { DataSource } from 'typeorm';
Title,import { Photo } from './photo.entity';
Title,export const photoProviders = [
Title,{
Title,"provide: 'PHOTO_REPOSITORY',"
Title,"useFactory: (dataSource: DataSource) => dataSource.getRepository(Photo),"
Title,"inject: ['DATA_SOURCE'],"
Title,"},"
Title,];
Title,```
Title,
Title,warning Warning In the real-world applications you should avoid magic strings. Both PHOTO_REPOSITORY and DATA_SOURCE should be kept in the separated constants.ts file.
Title,
Title,Now we can inject the Repository<Photo> to the PhotoService using the @Inject() decorator:
Title,```typescript
Title,@@filename(photo.service)
Title,"import { Injectable, Inject } from '@nestjs/common';"
Title,import { Repository } from 'typeorm';
Title,import { Photo } from './photo.entity';
Title,@Injectable()
Title,export class PhotoService {
Title,constructor(
Title,@Inject('PHOTO_REPOSITORY')
Title,"private photoRepository: Repository,"
Title,) {}
Title,async findAll(): Promise {
Title,return this.photoRepository.find();
Title,}
Title,}
Title,```
Title,"The database connection is asynchronous, but Nest makes this process completely invisible for the end-user. The PhotoRepository is waiting for the db connection, and the PhotoService is delayed until repository is ready to use. The entire application can start when each class is instantiated."
Title,Here is a final PhotoModule:
Title,```typescript
Title,@@filename(photo.module)
Title,import { Module } from '@nestjs/common';
Title,import { DatabaseModule } from '../database/database.module';
Title,import { photoProviders } from './photo.providers';
Title,import { PhotoService } from './photo.service';
Title,@Module({
Title,"imports: [DatabaseModule],"
Title,providers: [
Title,"...photoProviders,"
Title,"PhotoService,"
Title,"],"
Title,})
Title,export class PhotoModule {}
Title,```
Title,
Title,info Hint Do not forget to import the PhotoModule into the root AppModule.
Title,
Title,
Title,Suites (formerly Automock)
Title,"Suites is an opinionated and flexible testing meta-framework designed to enhance the software testing experience for backend systems. By bringing together a variety of testing tools into a unified framework, Suites streamlines the creation of reliable tests, helping to ensure the development of high-quality software."
Title,
Title,info Hint Suites is a third-party package and is not maintained by the NestJS core team. Please report any issues with the library to the appropriate repository.
Title,
Title,Introduction
Title,"Inversion of Control (IoC) is a fundamental principle in the NestJS framework, enabling a modular, testable architecture. While NestJS offers built-in tools for creating testing modules, Suites provides an alternative approach that emphasizes testing isolated units or small groups of units together. Suites uses a virtual container for dependencies, where mocks are automatically generated, eliminating the need to manually replace each provider with a mock in the IoC (or DI) container. This approach can be used either in place of or alongside NestJS’s Test.createTestingModule method, offering more flexibility for unit testing based on your needs."
Title,Installation
Title,"To use Suites with NestJS, install the necessary packages:"
Title,bash
Title,$ npm i -D @suites/unit @suites/di.nestjs @suites/doubles.jest
Title,
Title,"info Hint Suites supports Vitest and Sinon as test doubles as well, @suites/doubles.vitest and @suites/doubles.sinon respectively."
Title,
Title,Example and module setup
Title,"Consider a module setup for CatsService that includes CatsApiService, CatsDAL, HttpClient, and Logger. This"
Title,will be our base for the examples in this recipe:
Title,```typescript
Title,@@filename(cats.module)
Title,import { HttpModule } from '@nestjs/axios';
Title,import { PrismaModule } from '../prisma.module';
Title,@Module({
Title,"imports: [HttpModule.register({ baseUrl: 'https://api.cats.com/' }), PrismaModule],"
Title,"providers: [CatsService, CatsApiService, CatsDAL, Logger],"
Title,"exports: [CatsService],"
Title,})
Title,export class CatsModule {}
Title,```
Title,Both the HttpModule and PrismaModule are exporting providers to the host module.
Title,Let's start by testing the CatsHttpService in isolation. This service is responsible for fetching cat data from an API and logging the operation.
Title,```typescript
Title,@@filename(cats-http.service)
Title,@Injectable()
Title,export class CatsHttpService {
Title,"constructor(private httpClient: HttpClient, private logger: Logger) {}"
Title,async fetchCats(): Promise {
Title,this.logger.log('Fetching cats from the API');
Title,const response = await this.httpClient.get('/cats');
Title,return response.data;
Title,}
Title,}
Title,```
Title,"We want to isolate CatsHttpService and mock its dependencies, HttpClient and Logger. Suites allows us to do this"
Title,easily using the .solitary() method from TestBed.
Title,```typescript
Title,@@filename(cats-http.service.spec)
Title,"import { TestBed, Mocked } from '@suites/unit';"
Title,"describe('Cats Http Service Unit Test', () => {"
Title,let catsHttpService: CatsHttpService;
Title,let httpClient: Mocked;
Title,let logger: Mocked;
Title,beforeAll(async () => {
Title,// Isolate CatsHttpService and mock HttpClient and Logger
Title,"const { unit, unitRef } = await TestBed.solitary(CatsHttpService).compile();"
Title,catsHttpService = unit;
Title,httpClient = unitRef.get(HttpClient);
Title,logger = unitRef.get(Logger);
Title,
Title,});
Title,"it('should fetch cats from the API and log the operation', async () => {"
Title,"const catsFixtures: Cat[] = [{ id: 1, name: 'Catty' }, { id: 2, name: 'Mitzy' }];"
Title,httpClient.get.mockResolvedValue({ data: catsFixtures });
Title,const cats = await catsHttpService.fetchCats();
Title,
Title,expect(logger.log).toHaveBeenCalledWith('Fetching cats from the API');
Title,expect(httpClient.get).toHaveBeenCalledWith('/cats');
Title,expect(cats).toEqual<Cat[]>(catsFixtures);
Title,
Title,});
Title,});
Title,```
Title,"In the example above, Suites automatically mocks the dependencies of CatsHttpService using TestBed.solitary(). This makes the setup easier since you don’t have to manually mock each dependency."
Title,
Title,Auto-Mocking of Dependencies: Suites generates mocks for all dependencies of the unit being tested.
Title,"Empty Behavior of Mocks: Initially, these mocks don’t have any predefined behavior. You’ll need to specify their behavior as needed for your tests."
Title,unit and unitRef properties:
Title,"unit refers to the actual instance of the class being tested, complete with its mocked dependencies."
Title,unitRef is a reference that allows you to access the mocked dependencies.
Title,
Title,Testing CatsApiService with TestingModule
Title,"For CatsApiService, we want to ensure that the HttpModule is properly imported and configured in the CatsModule host module. This includes verifying that the base URL (and other configurations) for Axios is set correctly."
Title,"In this case, we won’t use Suites; instead, we’ll use Nest’s TestingModule to test the actual configuration of HttpModule. We’ll utilize nock to mock HTTP requests without mocking the HttpClient in this scenario."
Title,```typescript
Title,@@filename(cats-api.service)
Title,import { HttpClient } from '@nestjs/axios';
Title,@Injectable()
Title,export class CatsApiService {
Title,constructor(private httpClient: HttpClient) {}
Title,async getCatById(id: number): Promise {
Title,const response = await this.httpClient.get(/cats/${id});
Title,return response.data;
Title,}
Title,}
Title,```
Title,"We need to test CatsApiService with a real, unmocked HttpClient to ensure the DI and configuration of Axios (http)"
Title,are correct. This involves importing the CatsModule and using nock for HTTP request mocking.
Title,```typescript
Title,@@filename(cats-api.service.integration.test)
Title,import { Test } from '@nestjs/testing';
Title,import * as nock from 'nock';
Title,"describe('Cats Api Service Integration Test', () => {"
Title,let catsApiService: CatsApiService;
Title,beforeAll(async () => {
Title,const moduleRef = await Test.createTestingModule({
Title,"imports: [CatsModule],"
Title,}).compile();
Title,catsApiService = moduleRef.get(CatsApiService);
Title,
Title,});
Title,afterEach(() => {
Title,nock.cleanAll();
Title,});
Title,"it('should fetch cat by id using real HttpClient', async () => {"
Title,"const catFixture: Cat = { id: 1, name: 'Catty' };"
Title,nock('https://api.cats.com') // Making this URL identical to the one in HttpModule registration
Title,.get('/cats/1')
Title,".reply(200, catFixture);"
Title,
Title,const cat = await catsApiService.getCatById(1);
Title,expect(cat).toEqual<Cat>(catFixture);
Title,
Title,});
Title,});
Title,```
Title,Sociable Testing Example
Title,"Next, let's test CatsService, which depends on CatsApiService and CatsDAL. We'll mock CatsApiService and"
Title,expose CatsDAL.
Title,```typescript
Title,@@filename(cats.dal)
Title,import { PrismaClient } from '@prisma/client';
Title,@Injectable()
Title,export class CatsDAL {
Title,constructor(private prisma: PrismaClient) {}
Title,async saveCat(cat: Cat): Promise {
Title,return this.prisma.cat.create({data: cat});
Title,}
Title,}
Title,```
Title,"Next up, we have the CatsService, which depends on CatsApiService and CatsDAL:"
Title,```typescript
Title,@@filename(cats.service)
Title,@Injectable()
Title,export class CatsService {
Title,constructor(
Title,"private catsApiService: CatsApiService,"
Title,private catsDAL: CatsDAL
Title,) {}
Title,async getAndSaveCat(id: number): Promise {
Title,const cat = await this.catsApiService.getCatById(id);
Title,return this.catsDAL.saveCat(cat);
Title,}
Title,}
Title,```
Title,"And now, let's test CatsService using sociable testing with Suites:"
Title,```typescript
Title,@@filename(cats.service.spec)
Title,"import { TestBed, Mocked } from '@suites/unit';"
Title,import { PrismaClient } from '@prisma/client';
Title,"describe('Cats Service Sociable Unit Test', () => {"
Title,let catsService: CatsService;
Title,let prisma: Mocked;
Title,let catsApiService: Mocked;
Title,beforeAll(async () => {
Title,"// Sociable test setup, exposing CatsDAL and mocking CatsApiService"
Title,"const { unit, unitRef } = await TestBed.sociable(CatsService)"
Title,.expose(CatsDAL)
Title,.mock(CatsApiService)
Title,".final({ getCatById: async () => ({ id: 1, name: 'Catty' })})"
Title,.compile();
Title,catsService = unit;
Title,prisma = unitRef.get(PrismaClient);
Title,
Title,});
Title,"it('should get cat by id and save it', async () => {"
Title,"const catFixture: Cat = { id: 1, name: 'Catty' };"
Title,prisma.cat.create.mockResolvedValue(catFixture);
Title,const savedCat = await catsService.getAndSaveCat(1);
Title,
Title,expect(prisma.cat.create).toHaveBeenCalledWith({ data: catFixture });
Title,expect(savedCat).toEqual(catFixture);
Title,
Title,});
Title,});
Title,```
Title,"In this example, we use the .sociable() method to set up the test environment. We utilize the .expose() method to allow real interactions with CatsDAL, while mocking CatsApiService with the .mock() method. The .final() method establishes fixed behavior for CatsApiService, ensuring consistent outcomes across tests."
Title,"This approach emphasizes testing CatsService with genuine interactions with CatsDAL, which involves handling Prisma. Suites will use CatsDAL as is, and only its dependencies, like Prisma, will be mocked in this case."
Title,"It's important to note that this approach is solely for verifying behavior and differs from loading the entire testing module. Sociable tests are valuable for confirming the behavior of units in isolation from their direct dependencies, especially when you want to focus on the behavior and interactions of units."
Title,Integration Testing and Database
Title,"For CatsDAL, it's possible to test against a real database such as SQLite or PostgreSQL (for instance, using Docker Compose). However, for this example, we will mock Prisma and focus on sociable testing. The reason for mocking Prisma is to avoid I/O operations and concentrate on the behavior of CatsService in isolation. That said, you can also conduct tests with real I/O operations and a live database."
Title,"Sociable Unit Tests, Integration Tests, and Mocking"
Title,
Title,
Title,"Sociable Unit Tests: These focus on testing the interactions and behaviors between units while mocking their deeper dependencies. In this example, we mock Prisma and expose CatsDAL."
Title,
Title,
Title,"Integration Tests: These involve real I/O operations and a fully configured dependency injection (DI) setup. Testing CatsApiService with HttpModule and nock is considered an integration test, as it verifies the real configuration and interactions of HttpClient. In this scenario, we will use Nest's TestingModule to load the actual module configuration."
Title,
Title,
Title,"Exercise caution when using mocks. Be sure to test I/O operations and DI configurations (especially when HTTP or database interactions are involved). After validating these components with integration tests, you can confidently mock them for sociable unit tests to focus on behavior and interactions. Suites sociable tests are geared towards verifying the behavior of units in isolation from their direct dependencies, while integration tests ensure that the overall system configuration and I/O operations function correctly."
Title,Testing IoC Container Registration
Title,"It's essential to verify that your DI container is properly configured to prevent runtime errors. This includes ensuring that all providers, services, and modules are registered and injected correctly. Testing the DI container configuration helps catch misconfigurations early, preventing issues that might only arise at runtime."
Title,"To confirm that the IoC container is set up correctly, let's create an integration test that loads the actual module configuration and verifies that all providers are registered and injected properly."
Title,```typescript
Title,"import { Test, TestingModule } from '@nestjs/testing';"
Title,import { CatsModule } from './cats.module';
Title,import { CatsService } from './cats.service';
Title,"describe('Cats Module Integration Test', () => {"
Title,let moduleRef: TestingModule;
Title,beforeAll(async () => {
Title,moduleRef = await Test.createTestingModule({
Title,"imports: [CatsModule],"
Title,}).compile();
Title,});
Title,"it('should resolve exported providers from the ioc container', () => {"
Title,const catsService = moduleRef.get(CatsService);
Title,expect(catsService).toBeDefined();
Title,});
Title,});
Title,```
Title,"Comparison Between Solitary, Sociable, Integration, and E2E Testing"
Title,Solitary Unit Tests
Title,
Title,Focus: Test single unit (class) in full isolation.
Title,Use Case: Testing CatsHttpService.
Title,Tools: Suites' TestBed.solitary() method.
Title,Example: Mocking HttpClient and testing CatsHttpService.
Title,
Title,Sociable Unit Tests
Title,
Title,Focus: Verify interactions between units while mocking deeper dependencies.
Title,Use Case: Testing CatsService with a mocked CatsApiService and exposing CatsDAL.
Title,Tools: Suites' TestBed.sociable() method.
Title,Example: Mocking Prisma and testing CatsService.
Title,
Title,Integration Tests
Title,
Title,Focus: Involve real I/O operations and fully configured modules (IoC container).
Title,Use Case: Testing CatsApiService with HttpModule and nock.
Title,Tools: Nest's TestingModule.
Title,Example: Testing the real configuration and interaction of HttpClient.
Title,
Title,E2E Tests
Title,
Title,Focus: Cover the interaction of classes and modules at a more aggregate level.
Title,Use Case: Testing the full behavior of the system from the perspective of the end-user.
Title,"Tools: Nest's TestingModule, supertest."
Title,Example: Testing the CatsModule using supertest to simulate HTTP requests.
Title,
Title,Refer to the NestJS official testing guide for more
Title,details on setting up and running E2E tests.
Title,
Title,SWC
Title,SWC (Speedy Web Compiler) is an extensible Rust-based platform that can be used for both compilation and bundling.
Title,Using SWC with Nest CLI is a great and simple way to significantly speed up your development process.
Title,
Title,info Hint SWC is approximately x20 times faster than the default TypeScript compiler.
Title,
Title,Installation
Title,"To get started, first install a few packages:"
Title,bash
Title,$ npm i --save-dev @swc/cli @swc/core
Title,Getting started
Title,"Once the installation process is complete, you can use the swc builder with Nest CLI, as follows:"
Title,```bash
Title,$ nest start -b swc
Title,OR nest start --builder swc
Title,```
Title,
Title,"info Hint If your repository is a monorepo, check out this section."
Title,
Title,"Instead of passing the -b flag you can also just set the compilerOptions.builder property to ""swc"" in your nest-cli.json file, like so:"
Title,json
Title,{
Title,"""compilerOptions"": {"
Title,"""builder"": ""swc"""
Title,}
Title,}
Title,"To customize builder's behavior, you can pass an object containing two attributes, type (""swc"") and options, as follows:"
Title,json
Title,"""compilerOptions"": {"
Title,"""builder"": {"
Title,"""type"": ""swc"","
Title,"""options"": {"
Title,"""swcrcPath"": ""infrastructure/.swcrc"","
Title,}
Title,}
Title,}
Title,"To run the application in watch mode, use the following command:"
Title,```bash
Title,$ nest start -b swc -w
Title,OR nest start --builder swc --watch
Title,```
Title,Type checking
Title,"SWC does not perform any type checking itself (as opposed to the default TypeScript compiler), so to turn it on, you need to use the --type-check flag:"
Title,bash
Title,$ nest start -b swc --type-check
Title,"This command will instruct the Nest CLI to run tsc in noEmit mode alongside SWC, which will asynchronously perform type checking. Again, instead of passing the --type-check flag you can also just set the compilerOptions.typeCheck property to true in your nest-cli.json file, like so:"
Title,json
Title,{
Title,"""compilerOptions"": {"
Title,"""builder"": ""swc"","
Title,"""typeCheck"": true"
Title,}
Title,}
Title,CLI Plugins (SWC)
Title,The --type-check flag will automatically execute NestJS CLI plugins and produce a serialized metadata file which then can be loaded by the application at runtime.
Title,SWC configuration
Title,"SWC builder is pre-configured to match the requirements of NestJS applications. However, you can customize the configuration by creating a .swcrc file in the root directory and tweaking the options as you wish."
Title,json
Title,{
Title,"""$schema"": ""https://json.schemastore.org/swcrc"","
Title,"""sourceMaps"": true,"
Title,"""jsc"": {"
Title,"""parser"": {"
Title,"""syntax"": ""typescript"","
Title,"""decorators"": true,"
Title,"""dynamicImport"": true"
Title,"},"
Title,"""baseUrl"": ""./"""
Title,"},"
Title,"""minify"": false"
Title,}
Title,Monorepo
Title,"If your repository is a monorepo, then instead of using swc builder you have to configure webpack to use swc-loader."
Title,"First, let's install the required package:"
Title,bash
Title,$ npm i --save-dev swc-loader
Title,"Once the installation is complete, create a webpack.config.js file in the root directory of your application with the following content:"
Title,```js
Title,const swcDefaultConfig = require('@nestjs/cli/lib/compiler/defaults/swc-defaults').swcDefaultsFactory().swcOptions;
Title,module.exports = {
Title,module: {
Title,rules: [
Title,{
Title,"test: /.ts$/,"
Title,"exclude: /node_modules/,"
Title,use: {
Title,"loader: 'swc-loader',"
Title,"options: swcDefaultConfig,"
Title,"},"
Title,"},"
Title,"],"
Title,"},"
Title,};
Title,```
Title,Monorepo and CLI plugins
Title,"Now if you use CLI plugins, swc-loader will not load them automatically. Instead, you have to create a separate file that will load them manually. To do so,"
Title,declare a generate-metadata.ts file near the main.ts file with the following content:
Title,```ts
Title,import { PluginMetadataGenerator } from '@nestjs/cli/lib/compiler/plugins/plugin-metadata-generator';
Title,import { ReadonlyVisitor } from '@nestjs/swagger/dist/plugin';
Title,const generator = new PluginMetadataGenerator();
Title,generator.generate({
Title,"visitors: [new ReadonlyVisitor({ introspectComments: true, pathToSource: __dirname })],"
Title,"outputDir: __dirname,"
Title,"watch: true,"
Title,"tsconfigPath: 'apps//tsconfig.app.json',"
Title,});
Title,```
Title,
Title,"info Hint In this example we used @nestjs/swagger plugin, but you can use any plugin of your choice."
Title,
Title,The generate() method accepts the following options:
Title,|                    |                                                                                                |
Title,| ------------------ | ---------------------------------------------------------------------------------------------- |
Title,| watch            | Whether to watch the project for changes.                                                      |
Title,| tsconfigPath     | Path to the tsconfig.json file. Relative to the current working directory (process.cwd()). |
Title,| outputDir        | Path to the directory where the metadata file will be saved.                                   |
Title,| visitors         | An array of visitors that will be used to generate metadata.                                   |
Title,| filename         | The name of the metadata file. Defaults to metadata.ts.                                      |
Title,| printDiagnostics | Whether to print diagnostics to the console. Defaults to true.                               |
Title,"Finally, you can run the generate-metadata script in a separate terminal window with the following command:"
Title,```bash
Title,$ npx ts-node src/generate-metadata.ts
Title,OR npx ts-node apps/{YOUR_APP}/src/generate-metadata.ts
Title,```
Title,Common pitfalls
Title,"If you use TypeORM/MikroORM or any other ORM in your application, you may stumble upon circular import issues. SWC doesn't handle circular imports well, so you should use the following workaround:"
Title,typescript
Title,@Entity()
Title,export class User {
Title,"@OneToOne(() => Profile, (profile) => profile.user)"
Title,"profile: Relation<Profile>; // <--- see ""Relation<>"" type here instead of just ""Profile"""
Title,}
Title,
Title,info Hint Relation type is exported from the typeorm package.
Title,
Title,"Doing this prevents the type of the property from being saved in the transpiled code in the property metadata, preventing circular dependency issues."
Title,"If your ORM does not provide a similar workaround, you can define the wrapper type yourself:"
Title,typescript
Title,/**
Title,* Wrapper type used to circumvent ESM modules circular dependency issue
Title,* caused by reflection metadata saving the type of the property.
Title,*/
Title,export type WrapperType<T> = T; // WrapperType === Relation
Title,"For all circular dependency injections in your project, you will also need to use the custom wrapper type described above:"
Title,typescript
Title,@Injectable()
Title,export class UserService {
Title,constructor(
Title,@Inject(forwardRef(() => ProfileService))
Title,"private readonly profileService: WrapperType<ProfileService>,"
Title,) {};
Title,}
Title,Jest + SWC
Title,"To use SWC with Jest, you need to install the following packages:"
Title,bash
Title,$ npm i --save-dev jest @swc/core @swc/jest
Title,"Once the installation is complete, update the package.json/jest.config.js file (depending on your configuration) with the following content:"
Title,json
Title,{
Title,"""jest"": {"
Title,"""transform"": {"
Title,"""^.+\\.(t|j)s?$"": [""@swc/jest""]"
Title,}
Title,}
Title,}
Title,"Additionally you would need to add the following transform properties to your .swcrc file: legacyDecorator, decoratorMetadata:"
Title,json
Title,{
Title,"""$schema"": ""https://json.schemastore.org/swcrc"","
Title,"""sourceMaps"": true,"
Title,"""jsc"": {"
Title,"""parser"": {"
Title,"""syntax"": ""typescript"","
Title,"""decorators"": true,"
Title,"""dynamicImport"": true"
Title,"},"
Title,"""transform"": {"
Title,"""legacyDecorator"": true,"
Title,"""decoratorMetadata"": true"
Title,"},"
Title,"""baseUrl"": ""./"""
Title,"},"
Title,"""minify"": false"
Title,}
Title,"If you use NestJS CLI Plugins in your project, you'll have to run PluginMetadataGenerator manually. Navigate to this section to learn more."
Title,Vitest
Title,"Vitest is a fast and lightweight test runner designed to work with Vite. It provides a modern, fast, and easy-to-use testing solution that can be integrated with NestJS projects."
Title,Installation
Title,"To get started, first install the required packages:"
Title,bash
Title,$ npm i --save-dev vitest unplugin-swc @swc/core @vitest/coverage-v8
Title,Configuration
Title,Create a vitest.config.ts file in the root directory of your application with the following content:
Title,```ts
Title,import swc from 'unplugin-swc';
Title,import { defineConfig } from 'vitest/config';
Title,export default defineConfig({
Title,test: {
Title,"globals: true,"
Title,"root: './',"
Title,"},"
Title,plugins: [
Title,// This is required to build the test files with SWC
Title,swc.vite({
Title,// Explicitly set the module type to avoid inheriting this value from a .swcrc config file
Title,"module: { type: 'es6' },"
Title,"}),"
Title,"],"
Title,});
Title,```
Title,"This configuration file sets up the Vitest environment, root directory, and SWC plugin. You should also create a separate configuration"
Title,"file for e2e tests, with an additional include field that specifies the test path regex:"
Title,```ts
Title,import swc from 'unplugin-swc';
Title,import { defineConfig } from 'vitest/config';
Title,export default defineConfig({
Title,test: {
Title,"include: ['*/.e2e-spec.ts'],"
Title,"globals: true,"
Title,"root: './',"
Title,"},"
Title,"plugins: [swc.vite()],"
Title,});
Title,```
Title,"Additionally, you can set the alias options to support TypeScript paths in your tests:"
Title,```ts
Title,import swc from 'unplugin-swc';
Title,import { defineConfig } from 'vitest/config';
Title,export default defineConfig({
Title,test: {
Title,"include: ['*/.e2e-spec.ts'],"
Title,"globals: true,"
Title,alias: {
Title,"'@src': './src',"
Title,"'@test': './test',"
Title,"},"
Title,"root: './',"
Title,"},"
Title,resolve: {
Title,alias: {
Title,"'@src': './src',"
Title,"'@test': './test',"
Title,"},"
Title,"},"
Title,"plugins: [swc.vite()],"
Title,});
Title,```
Title,Update imports in E2E tests
Title,"Change any E2E test imports using import * as request from 'supertest' to import request from 'supertest'. This is necessary because Vitest, when bundled with Vite, expects a default import for supertest. Using a namespace import may cause issues in this specific setup."
Title,"Lastly, update the test scripts in your package.json file to the following:"
Title,json
Title,{
Title,"""scripts"": {"
Title,"""test"": ""vitest run"","
Title,"""test:watch"": ""vitest"","
Title,"""test:cov"": ""vitest run --coverage"","
Title,"""test:debug"": ""vitest --inspect-brk --inspect --logHeapUsage --threads=false"","
Title,"""test:e2e"": ""vitest run --config ./vitest.config.e2e.ts"""
Title,}
Title,}
Title,"These scripts configure Vitest for running tests, watching for changes, generating code coverage reports, and debugging. The test:e2e script is specifically for running E2E tests with a custom configuration file."
Title,"With this setup, you can now enjoy the benefits of using Vitest in your NestJS project, including faster test execution and a more modern testing experience."
Title,
Title,info Hint You can check out a working example in this repository
Title,
Title,
Title,Healthchecks (Terminus)
Title,Terminus integration provides you with readiness/liveness health checks. Healthchecks are crucial when it comes to complex
Title,"backend setups. In a nutshell, a health check in the realm of web development usually consists of a special address, for example, https://my-website.com/health/readiness."
Title,"A service or a component of your infrastructure (e.g., Kubernetes checks this address continuously. Depending on the HTTP status code returned from a GET request to this address the service will take action when it receives an ""unhealthy"" response."
Title,"Since the definition of ""healthy"" or ""unhealthy"" varies with the type of service you provide, the Terminus integration supports you with a"
Title,set of health indicators.
Title,"As an example, if your web server uses MongoDB to store its data, it would be vital information whether MongoDB is still up and running."
Title,"In that case, you can make use of the MongooseHealthIndicator. If configured correctly - more on that later - your health check address will return"
Title,"a healthy or unhealthy HTTP status code, depending on whether MongoDB is running."
Title,Getting started
Title,To get started with @nestjs/terminus we need to install the required dependency.
Title,bash
Title,$ npm install --save @nestjs/terminus
Title,Setting up a Healthcheck
Title,"A health check represents a summary of health indicators. A health indicator executes a check of a service, whether it is in a healthy or unhealthy state. A health check is positive if all the assigned health indicators are up and running. Because a lot of applications will need similar health indicators, @nestjs/terminus provides a set of predefined indicators, such as:"
Title,
Title,HttpHealthIndicator
Title,TypeOrmHealthIndicator
Title,MongooseHealthIndicator
Title,SequelizeHealthIndicator
Title,MikroOrmHealthIndicator
Title,PrismaHealthIndicator
Title,MicroserviceHealthIndicator
Title,GRPCHealthIndicator
Title,MemoryHealthIndicator
Title,DiskHealthIndicator
Title,
Title,"To get started with our first health check, let's create the HealthModule and import the TerminusModule into it in its imports array."
Title,
Title,"info Hint To create the module using the Nest CLI, simply execute the $ nest g module health command."
Title,
Title,```typescript
Title,@@filename(health.module)
Title,import { Module } from '@nestjs/common';
Title,import { TerminusModule } from '@nestjs/terminus';
Title,@Module({
Title,imports: [TerminusModule]
Title,})
Title,export class HealthModule {}
Title,```
Title,"Our healthcheck(s) can be executed using a controller, which can be easily set up using the Nest CLI."
Title,bash
Title,$ nest g controller health
Title,
Title,info Info It is highly recommended to enable shutdown hooks in your application. Terminus integration makes use of this lifecycle event if enabled. Read more about shutdown hooks here.
Title,
Title,HTTP Healthcheck
Title,"Once we have installed @nestjs/terminus, imported our TerminusModule and created a new controller, we are ready to create a health check."
Title,The HTTPHealthIndicator requires the @nestjs/axios package so make sure to have it installed:
Title,bash
Title,$ npm i --save @nestjs/axios axios
Title,Now we can setup our HealthController:
Title,```typescript
Title,@@filename(health.controller)
Title,"import { Controller, Get } from '@nestjs/common';"
Title,"import { HealthCheckService, HttpHealthIndicator, HealthCheck } from '@nestjs/terminus';"
Title,@Controller('health')
Title,export class HealthController {
Title,constructor(
Title,"private health: HealthCheckService,"
Title,"private http: HttpHealthIndicator,"
Title,) {}
Title,@Get()
Title,@HealthCheck()
Title,check() {
Title,return this.health.check([
Title,"() => this.http.pingCheck('nestjs-docs', 'https://docs.nestjs.com'),"
Title,]);
Title,}
Title,}
Title,@@switch
Title,"import { Controller, Dependencies, Get } from '@nestjs/common';"
Title,"import { HealthCheckService, HttpHealthIndicator, HealthCheck } from '@nestjs/terminus';"
Title,@Controller('health')
Title,"@Dependencies(HealthCheckService, HttpHealthIndicator)"
Title,export class HealthController {
Title,constructor(
Title,"private health,"
Title,"private http,"
Title,) { }
Title,@Get()
Title,@HealthCheck()
Title,healthCheck() {
Title,return this.health.check([
Title,"() => this.http.pingCheck('nestjs-docs', 'https://docs.nestjs.com'),"
Title,])
Title,}
Title,}
Title,```
Title,```typescript
Title,@@filename(health.module)
Title,import { Module } from '@nestjs/common';
Title,import { TerminusModule } from '@nestjs/terminus';
Title,import { HttpModule } from '@nestjs/axios';
Title,import { HealthController } from './health.controller';
Title,@Module({
Title,"imports: [TerminusModule, HttpModule],"
Title,"controllers: [HealthController],"
Title,})
Title,export class HealthModule {}
Title,@@switch
Title,import { Module } from '@nestjs/common';
Title,import { TerminusModule } from '@nestjs/terminus';
Title,import { HttpModule } from '@nestjs/axios';
Title,import { HealthController } from './health.controller';
Title,@Module({
Title,"imports: [TerminusModule, HttpModule],"
Title,"controllers: [HealthController],"
Title,})
Title,export class HealthModule {}
Title,```
Title,Our health check will now send a GET-request to the https://docs.nestjs.com address. If
Title,"we get a healthy response from that address, our route at http://localhost:3000/health will return"
Title,the following object with a 200 status code.
Title,json
Title,{
Title,"""status"": ""ok"","
Title,"""info"": {"
Title,"""nestjs-docs"": {"
Title,"""status"": ""up"""
Title,}
Title,"},"
Title,"""error"": {},"
Title,"""details"": {"
Title,"""nestjs-docs"": {"
Title,"""status"": ""up"""
Title,}
Title,}
Title,}
Title,The interface of this response object can be accessed from the @nestjs/terminus package with the HealthCheckResult interface.
Title,|           |                                                                                                                                                                                             |                                      |
Title,|-----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------|
Title,"| status  | If any health indicator failed the status will be 'error'. If the NestJS app is shutting down but still accepting HTTP requests, the health check will have the 'shutting_down' status. | 'error' \| 'ok' \| 'shutting_down' |"
Title,"| info    | Object containing information of each health indicator which is of status 'up', or in other words ""healthy"".                                                                              | object                             |"
Title,"| error   | Object containing information of each health indicator which is of status 'down', or in other words ""unhealthy"".                                                                          | object                             |"
Title,| details | Object containing all information of each health indicator                                                                                                                                  | object                             |
Title,Check for specific HTTP response codes
Title,"In certain cases, you might want to check for specific criteria and validate the response. As an example, let's assume"
Title,https://my-external-service.com returns a response code 204. With HttpHealthIndicator.responseCheck you can
Title,check for that response code specifically and determine all other codes as unhealthy.
Title,"In case any other response code other than 204 gets returned, the following example would be unhealthy. The third parameter"
Title,requires you to provide a function (sync or async) which returns a boolean whether the response is considered
Title,healthy (true) or unhealthy (false).
Title,``typescript
Title,@@filename(health.controller)
Title,// Within theHealthController`-class
Title,@Get()
Title,@HealthCheck()
Title,check() {
Title,return this.health.check([
Title,() =>
Title,this.http.responseCheck(
Title,"'my-external-service',"
Title,"'https://my-external-service.com',"
Title,"(res) => res.status === 204,"
Title,"),"
Title,]);
Title,}
Title,```
Title,TypeOrm health indicator
Title,"Terminus offers the capability to add database checks to your health check. In order to get started with this health indicator, you"
Title,should check out the Database chapter and make sure your database connection within your application is established.
Title,
Title,info Hint Behind the scenes the TypeOrmHealthIndicator simply executes a SELECT 1-SQL command which is often used to verify whether the database still alive. In case you are using an Oracle database it uses SELECT 1 FROM DUAL.
Title,
Title,```typescript
Title,@@filename(health.controller)
Title,@Controller('health')
Title,export class HealthController {
Title,constructor(
Title,"private health: HealthCheckService,"
Title,"private db: TypeOrmHealthIndicator,"
Title,) {}
Title,@Get()
Title,@HealthCheck()
Title,check() {
Title,return this.health.check([
Title,"() => this.db.pingCheck('database'),"
Title,]);
Title,}
Title,}
Title,@@switch
Title,@Controller('health')
Title,"@Dependencies(HealthCheckService, TypeOrmHealthIndicator)"
Title,export class HealthController {
Title,constructor(
Title,"private health,"
Title,"private db,"
Title,) { }
Title,@Get()
Title,@HealthCheck()
Title,healthCheck() {
Title,return this.health.check([
Title,"() => this.db.pingCheck('database'),"
Title,])
Title,}
Title,}
Title,```
Title,"If your database is reachable, you should now see the following JSON-result when requesting http://localhost:3000/health with a GET request:"
Title,json
Title,{
Title,"""status"": ""ok"","
Title,"""info"": {"
Title,"""database"": {"
Title,"""status"": ""up"""
Title,}
Title,"},"
Title,"""error"": {},"
Title,"""details"": {"
Title,"""database"": {"
Title,"""status"": ""up"""
Title,}
Title,}
Title,}
Title,"In case your app uses multiple databases, you need to inject each"
Title,"connection into your HealthController. Then, you can simply pass the connection reference to the TypeOrmHealthIndicator."
Title,```typescript
Title,@@filename(health.controller)
Title,@Controller('health')
Title,export class HealthController {
Title,constructor(
Title,"private health: HealthCheckService,"
Title,"private db: TypeOrmHealthIndicator,"
Title,@InjectConnection('albumsConnection')
Title,"private albumsConnection: Connection,"
Title,@InjectConnection()
Title,"private defaultConnection: Connection,"
Title,) {}
Title,@Get()
Title,@HealthCheck()
Title,check() {
Title,return this.health.check([
Title,"() => this.db.pingCheck('albums-database', { connection: this.albumsConnection }),"
Title,"() => this.db.pingCheck('database', { connection: this.defaultConnection }),"
Title,]);
Title,}
Title,}
Title,```
Title,Disk health indicator
Title,"With the DiskHealthIndicator we can check how much storage is in use. To get started, make sure to inject the DiskHealthIndicator"
Title,into your HealthController. The following example checks the storage used of the path / (or on Windows you can use C:\\).
Title,If that exceeds more than 50% of the total storage space it would response with an unhealthy Health Check.
Title,```typescript
Title,@@filename(health.controller)
Title,@Controller('health')
Title,export class HealthController {
Title,constructor(
Title,"private readonly health: HealthCheckService,"
Title,"private readonly disk: DiskHealthIndicator,"
Title,) {}
Title,@Get()
Title,@HealthCheck()
Title,check() {
Title,return this.health.check([
Title,"() => this.disk.checkStorage('storage', { path: '/', thresholdPercent: 0.5 }),"
Title,]);
Title,}
Title,}
Title,@@switch
Title,@Controller('health')
Title,"@Dependencies(HealthCheckService, DiskHealthIndicator)"
Title,export class HealthController {
Title,"constructor(health, disk) {}"
Title,@Get()
Title,@HealthCheck()
Title,healthCheck() {
Title,return this.health.check([
Title,"() => this.disk.checkStorage('storage', { path: '/', thresholdPercent: 0.5 }),"
Title,])
Title,}
Title,}
Title,```
Title,With the DiskHealthIndicator.checkStorage function you also have the possibility to check for a fixed amount of space.
Title,The following example would be unhealthy in case the path /my-app/ would exceed 250GB.
Title,``typescript
Title,@@filename(health.controller)
Title,// Within theHealthController`-class
Title,@Get()
Title,@HealthCheck()
Title,check() {
Title,return this.health.check([
Title,"() => this.disk.checkStorage('storage', {  path: '/', threshold: 250 * 1024 * 1024 * 1024, })"
Title,]);
Title,}
Title,```
Title,Memory health indicator
Title,To make sure your process does not exceed a certain memory limit the MemoryHealthIndicator can be used.
Title,The following example can be used to check the heap of your process.
Title,
Title,info Hint Heap is the portion of memory where dynamically allocated memory resides (i.e. memory allocated via malloc). Memory allocated from the heap will remain allocated until one of the following occurs:
Title,- The memory is free'd
Title,- The program terminates
Title,
Title,```typescript
Title,@@filename(health.controller)
Title,@Controller('health')
Title,export class HealthController {
Title,constructor(
Title,"private health: HealthCheckService,"
Title,"private memory: MemoryHealthIndicator,"
Title,) {}
Title,@Get()
Title,@HealthCheck()
Title,check() {
Title,return this.health.check([
Title,"() => this.memory.checkHeap('memory_heap', 150 * 1024 * 1024),"
Title,]);
Title,}
Title,}
Title,@@switch
Title,@Controller('health')
Title,"@Dependencies(HealthCheckService, MemoryHealthIndicator)"
Title,export class HealthController {
Title,"constructor(health, memory) {}"
Title,@Get()
Title,@HealthCheck()
Title,healthCheck() {
Title,return this.health.check([
Title,"() => this.memory.checkHeap('memory_heap', 150 * 1024 * 1024),"
Title,])
Title,}
Title,}
Title,```
Title,It is also possible to verify the memory RSS of your process with MemoryHealthIndicator.checkRSS. This example
Title,would return an unhealthy response code in case your process does have more than 150MB allocated.
Title,
Title,info Hint RSS is the Resident Set Size and is used to show how much memory is allocated to that process and is in RAM.
Title,It does not include memory that is swapped out. It does include memory from shared libraries as long as the pages from
Title,those libraries are actually in memory. It does include all stack and heap memory.
Title,
Title,``typescript
Title,@@filename(health.controller)
Title,// Within theHealthController`-class
Title,@Get()
Title,@HealthCheck()
Title,check() {
Title,return this.health.check([
Title,"() => this.memory.checkRSS('memory_rss', 150 * 1024 * 1024),"
Title,]);
Title,}
Title,```
Title,Custom health indicator
Title,"In some cases, the predefined health indicators provided by @nestjs/terminus do not cover all of your health check requirements. In that case, you can set up a custom health indicator according to your needs."
Title,"Let's get started by creating a service that will represent our custom indicator. To get a basic understanding of how an indicator is structured, we will create an example DogHealthIndicator. This service should have the state 'up' if every Dog object has the type 'goodboy'. If that condition is not satisfied then it should throw an error."
Title,```typescript
Title,@@filename(dog.health)
Title,import { Injectable } from '@nestjs/common';
Title,"import { HealthIndicator, HealthIndicatorResult, HealthCheckError } from '@nestjs/terminus';"
Title,export interface Dog {
Title,name: string;
Title,type: string;
Title,}
Title,@Injectable()
Title,export class DogHealthIndicator extends HealthIndicator {
Title,private dogs: Dog[] = [
Title,"{ name: 'Fido', type: 'goodboy' },"
Title,"{ name: 'Rex', type: 'badboy' },"
Title,];
Title,async isHealthy(key: string): Promise {
Title,const badboys = this.dogs.filter(dog => dog.type === 'badboy');
Title,const isHealthy = badboys.length === 0;
Title,"const result = this.getStatus(key, isHealthy, { badboys: badboys.length });"
Title,if (isHealthy) {
Title,return result;
Title,}
Title,"throw new HealthCheckError('Dogcheck failed', result);"
Title,
Title,}
Title,}
Title,@@switch
Title,import { Injectable } from '@nestjs/common';
Title,import { HealthCheckError } from '@godaddy/terminus';
Title,@Injectable()
Title,export class DogHealthIndicator extends HealthIndicator {
Title,dogs = [
Title,"{ name: 'Fido', type: 'goodboy' },"
Title,"{ name: 'Rex', type: 'badboy' },"
Title,];
Title,async isHealthy(key) {
Title,const badboys = this.dogs.filter(dog => dog.type === 'badboy');
Title,const isHealthy = badboys.length === 0;
Title,"const result = this.getStatus(key, isHealthy, { badboys: badboys.length });"
Title,if (isHealthy) {
Title,return result;
Title,}
Title,"throw new HealthCheckError('Dogcheck failed', result);"
Title,
Title,}
Title,}
Title,```
Title,The next thing we need to do is register the health indicator as a provider.
Title,```typescript
Title,@@filename(health.module)
Title,import { Module } from '@nestjs/common';
Title,import { TerminusModule } from '@nestjs/terminus';
Title,import { DogHealthIndicator } from './dog.health';
Title,@Module({
Title,"controllers: [HealthController],"
Title,"imports: [TerminusModule],"
Title,providers: [DogHealthIndicator]
Title,})
Title,export class HealthModule { }
Title,```
Title,
Title,"info Hint In a real-world application the DogHealthIndicator should be provided in a separate module, for example, DogModule, which then will be imported by the HealthModule."
Title,
Title,"The last required step is to add the now available health indicator in the required health check endpoint. For that, we go back to our HealthController and add it to our check function."
Title,```typescript
Title,@@filename(health.controller)
Title,"import { HealthCheckService, HealthCheck } from '@nestjs/terminus';"
Title,"import { Injectable, Dependencies, Get } from '@nestjs/common';"
Title,import { DogHealthIndicator } from './dog.health';
Title,@Injectable()
Title,export class HealthController {
Title,constructor(
Title,"private health: HealthCheckService,"
Title,private dogHealthIndicator: DogHealthIndicator
Title,) {}
Title,@Get()
Title,@HealthCheck()
Title,healthCheck() {
Title,return this.health.check([
Title,"() => this.dogHealthIndicator.isHealthy('dog'),"
Title,])
Title,}
Title,}
Title,@@switch
Title,"import { HealthCheckService, HealthCheck } from '@nestjs/terminus';"
Title,"import { Injectable, Get } from '@nestjs/common';"
Title,import { DogHealthIndicator } from './dog.health';
Title,@Injectable()
Title,"@Dependencies(HealthCheckService, DogHealthIndicator)"
Title,export class HealthController {
Title,constructor(
Title,"private health,"
Title,private dogHealthIndicator
Title,) {}
Title,@Get()
Title,@HealthCheck()
Title,healthCheck() {
Title,return this.health.check([
Title,"() => this.dogHealthIndicator.isHealthy('dog'),"
Title,])
Title,}
Title,}
Title,```
Title,Logging
Title,"Terminus only logs error messages, for instance when a Healthcheck has failed. With the TerminusModule.forRoot() method you have more control over how errors are being logged"
Title,as well as completely take over the logging itself.
Title,"In this section, we are going to walk you through how you create a custom logger TerminusLogger. This logger extends the built-in logger."
Title,Therefore you can pick and choose which part of the logger you would like to overwrite
Title,
Title,"info Info If you want to learn more about custom loggers in NestJS, read more here."
Title,
Title,```typescript
Title,@@filename(terminus-logger.service)
Title,"import { Injectable, Scope, ConsoleLogger } from '@nestjs/common';"
Title,@Injectable({ scope: Scope.TRANSIENT })
Title,export class TerminusLogger extends ConsoleLogger {
Title,"error(message: any, stack?: string, context?: string): void;"
Title,"error(message: any, ...optionalParams: any[]): void;"
Title,error(
Title,"message: unknown,"
Title,"stack?: unknown,"
Title,"context?: unknown,"
Title,...rest: unknown[]
Title,): void {
Title,// Overwrite here how error messages should be logged
Title,}
Title,}
Title,```
Title,"Once you have created your custom logger, all you need to do is simply pass it into the TerminusModule.forRoot() as such."
Title,typescript
Title,@@filename(health.module)
Title,@Module({
Title,imports: [
Title,TerminusModule.forRoot({
Title,"logger: TerminusLogger,"
Title,"}),"
Title,"],"
Title,})
Title,export class HealthModule {}
Title,"To completely suppress any log messages coming from Terminus, including error messages, configure Terminus as such."
Title,typescript
Title,@@filename(health.module)
Title,@Module({
Title,imports: [
Title,TerminusModule.forRoot({
Title,"logger: false,"
Title,"}),"
Title,"],"
Title,})
Title,export class HealthModule {}
Title,Terminus allows you to configure how Healthcheck errors should be displayed in your logs.
Title,| Error Log Style          | Description                                                                                                                        | Example                                                              |
Title,|:------------------|:-----------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------|
Title,| json  (default) | Prints a summary of the health check result in case of an error as JSON object                                                     |    |
Title,| pretty          | Prints a summary of the health check result in case of an error within formatted boxes and highlights successful/erroneous results |  |
Title,You can change the log style using the errorLogStyle configuration option as in the following snippet.
Title,typescript
Title,@@filename(health.module)
Title,@Module({
Title,imports: [
Title,TerminusModule.forRoot({
Title,"errorLogStyle: 'pretty',"
Title,"}),"
Title,]
Title,})
Title,export class HealthModule {}
Title,Graceful shutdown timeout
Title,"If your application requires postponing its shutdown process, Terminus can handle it for you."
Title,This setting can prove particularly beneficial when working with an orchestrator such as Kubernetes.
Title,"By setting a delay slightly longer than the readiness check interval, you can achieve zero downtime when shutting down containers."
Title,typescript
Title,@@filename(health.module)
Title,@Module({
Title,imports: [
Title,TerminusModule.forRoot({
Title,"gracefulShutdownTimeoutMs: 1000,"
Title,"}),"
Title,]
Title,})
Title,export class HealthModule {}
Title,More examples
Title,More working examples are available here.
Title,
Title,Authentication
Title,Authentication is an essential part of most applications. There are many different approaches and strategies to handle authentication. The approach taken for any project depends on its particular application requirements. This chapter presents several approaches to authentication that can be adapted to a variety of different requirements.
Title,"Let's flesh out our requirements. For this use case, clients will start by authenticating with a username and password. Once authenticated, the server will issue a JWT that can be sent as a bearer token in an authorization header on subsequent requests to prove authentication. We'll also create a protected route that is accessible only to requests that contain a valid JWT."
Title,"We'll start with the first requirement: authenticating a user. We'll then extend that by issuing a JWT. Finally, we'll create a protected route that checks for a valid JWT on the request."
Title,Creating an authentication module
Title,"We'll start by generating an AuthModule and in it, an AuthService and an AuthController. We'll use the AuthService to implement the authentication logic, and the AuthController to expose the authentication endpoints."
Title,bash
Title,$ nest g module auth
Title,$ nest g controller auth
Title,$ nest g service auth
Title,"As we implement the AuthService, we'll find it useful to encapsulate user operations in a UsersService, so let's generate that module and service now:"
Title,bash
Title,$ nest g module users
Title,$ nest g service users
Title,"Replace the default contents of these generated files as shown below. For our sample app, the UsersService simply maintains a hard-coded in-memory list of users, and a find method to retrieve one by username. In a real app, this is where you'd build your user model and persistence layer, using your library of choice (e.g., TypeORM, Sequelize, Mongoose, etc.)."
Title,```typescript
Title,@@filename(users/users.service)
Title,import { Injectable } from '@nestjs/common';
Title,// This should be a real class/interface representing a user entity
Title,export type User = any;
Title,@Injectable()
Title,export class UsersService {
Title,private readonly users = [
Title,{
Title,"userId: 1,"
Title,"username: 'john',"
Title,"password: 'changeme',"
Title,"},"
Title,{
Title,"userId: 2,"
Title,"username: 'maria',"
Title,"password: 'guess',"
Title,"},"
Title,];
Title,async findOne(username: string): Promise {
Title,return this.users.find(user => user.username === username);
Title,}
Title,}
Title,@@switch
Title,import { Injectable } from '@nestjs/common';
Title,@Injectable()
Title,export class UsersService {
Title,constructor() {
Title,this.users = [
Title,{
Title,"userId: 1,"
Title,"username: 'john',"
Title,"password: 'changeme',"
Title,"},"
Title,{
Title,"userId: 2,"
Title,"username: 'maria',"
Title,"password: 'guess',"
Title,"},"
Title,];
Title,}
Title,async findOne(username) {
Title,return this.users.find(user => user.username === username);
Title,}
Title,}
Title,```
Title,"In the UsersModule, the only change needed is to add the UsersService to the exports array of the @Module decorator so that it is visible outside this module (we'll soon use it in our AuthService)."
Title,```typescript
Title,@@filename(users/users.module)
Title,import { Module } from '@nestjs/common';
Title,import { UsersService } from './users.service';
Title,@Module({
Title,"providers: [UsersService],"
Title,"exports: [UsersService],"
Title,})
Title,export class UsersModule {}
Title,@@switch
Title,import { Module } from '@nestjs/common';
Title,import { UsersService } from './users.service';
Title,@Module({
Title,"providers: [UsersService],"
Title,"exports: [UsersService],"
Title,})
Title,export class UsersModule {}
Title,```
Title,"Implementing the ""Sign in"" endpoint"
Title,"Our AuthService has the job of retrieving a user and verifying the password. We create a signIn() method for this purpose. In the code below, we use a convenient ES6 spread operator to strip the password property from the user object before returning it. This is a common practice when returning user objects, as you don't want to expose sensitive fields like passwords or other security keys."
Title,```typescript
Title,@@filename(auth/auth.service)
Title,"import { Injectable, UnauthorizedException } from '@nestjs/common';"
Title,import { UsersService } from '../users/users.service';
Title,@Injectable()
Title,export class AuthService {
Title,constructor(private usersService: UsersService) {}
Title,"async signIn(username: string, pass: string): Promise {"
Title,const user = await this.usersService.findOne(username);
Title,if (user?.password !== pass) {
Title,throw new UnauthorizedException();
Title,}
Title,"const { password, ...result } = user;"
Title,// TODO: Generate a JWT and return it here
Title,// instead of the user object
Title,return result;
Title,}
Title,}
Title,@@switch
Title,"import { Injectable, Dependencies, UnauthorizedException } from '@nestjs/common';"
Title,import { UsersService } from '../users/users.service';
Title,@Injectable()
Title,@Dependencies(UsersService)
Title,export class AuthService {
Title,constructor(usersService) {
Title,this.usersService = usersService;
Title,}
Title,"async signIn(username: string, pass: string) {"
Title,const user = await this.usersService.findOne(username);
Title,if (user?.password !== pass) {
Title,throw new UnauthorizedException();
Title,}
Title,"const { password, ...result } = user;"
Title,// TODO: Generate a JWT and return it here
Title,// instead of the user object
Title,return result;
Title,}
Title,}
Title,```
Title,
Title,"Warning Warning Of course in a real application, you wouldn't store a password in plain text. You'd instead use a library like bcrypt, with a salted one-way hash algorithm. With that approach, you'd only store hashed passwords, and then compare the stored password to a hashed version of the incoming password, thus never storing or exposing user passwords in plain text. To keep our sample app simple, we violate that absolute mandate and use plain text. Don't do this in your real app!"
Title,
Title,"Now, we update our AuthModule to import the UsersModule."
Title,```typescript
Title,@@filename(auth/auth.module)
Title,import { Module } from '@nestjs/common';
Title,import { AuthService } from './auth.service';
Title,import { AuthController } from './auth.controller';
Title,import { UsersModule } from '../users/users.module';
Title,@Module({
Title,"imports: [UsersModule],"
Title,"providers: [AuthService],"
Title,"controllers: [AuthController],"
Title,})
Title,export class AuthModule {}
Title,@@switch
Title,import { Module } from '@nestjs/common';
Title,import { AuthService } from './auth.service';
Title,import { AuthController } from './auth.controller';
Title,import { UsersModule } from '../users/users.module';
Title,@Module({
Title,"imports: [UsersModule],"
Title,"providers: [AuthService],"
Title,"controllers: [AuthController],"
Title,})
Title,export class AuthModule {}
Title,```
Title,"With this in place, let's open up the AuthController and add a signIn() method to it. This method will be called by the client to authenticate a user. It will receive the username and password in the request body, and will return a JWT token if the user is authenticated."
Title,```typescript
Title,@@filename(auth/auth.controller)
Title,"import { Body, Controller, Post, HttpCode, HttpStatus } from '@nestjs/common';"
Title,import { AuthService } from './auth.service';
Title,@Controller('auth')
Title,export class AuthController {
Title,constructor(private authService: AuthService) {}
Title,@HttpCode(HttpStatus.OK)
Title,@Post('login')
Title,signIn(@Body() signInDto: Record) {
Title,"return this.authService.signIn(signInDto.username, signInDto.password);"
Title,}
Title,}
Title,```
Title,
Title,"info Hint Ideally, instead of using the Record<string, any> type, we should use a DTO class to define the shape of the request body. See the validation chapter for more information."
Title,
Title,
Title,JWT token
Title,We're ready to move on to the JWT portion of our auth system. Let's review and refine our requirements:
Title,
Title,"Allow users to authenticate with username/password, returning a JWT for use in subsequent calls to protected API endpoints. We're well on our way to meeting this requirement. To complete it, we'll need to write the code that issues a JWT."
Title,Create API routes which are protected based on the presence of a valid JWT as a bearer token
Title,
Title,We'll need to install one additional package to support our JWT requirements:
Title,bash
Title,$ npm install --save @nestjs/jwt
Title,
Title,info Hint The @nestjs/jwt package (see more here) is a utility package that helps with JWT manipulation. This includes generating and verifying JWT tokens.
Title,
Title,"To keep our services cleanly modularized, we'll handle generating the JWT in the authService. Open the auth.service.ts file in the auth folder, inject the JwtService, and update the signIn method to generate a JWT token as shown below:"
Title,```typescript
Title,@@filename(auth/auth.service)
Title,"import { Injectable, UnauthorizedException } from '@nestjs/common';"
Title,import { UsersService } from '../users/users.service';
Title,import { JwtService } from '@nestjs/jwt';
Title,@Injectable()
Title,export class AuthService {
Title,constructor(
Title,"private usersService: UsersService,"
Title,private jwtService: JwtService
Title,) {}
Title,async signIn(
Title,"username: string,"
Title,"pass: string,"
Title,): Promise<{ access_token: string }> {
Title,const user = await this.usersService.findOne(username);
Title,if (user?.password !== pass) {
Title,throw new UnauthorizedException();
Title,}
Title,"const payload = { sub: user.userId, username: user.username };"
Title,return {
Title,"access_token: await this.jwtService.signAsync(payload),"
Title,};
Title,}
Title,}
Title,@@switch
Title,"import { Injectable, Dependencies, UnauthorizedException } from '@nestjs/common';"
Title,import { UsersService } from '../users/users.service';
Title,import { JwtService } from '@nestjs/jwt';
Title,"@Dependencies(UsersService, JwtService)"
Title,@Injectable()
Title,export class AuthService {
Title,"constructor(usersService, jwtService) {"
Title,this.usersService = usersService;
Title,this.jwtService = jwtService;
Title,}
Title,"async signIn(username, pass) {"
Title,const user = await this.usersService.findOne(username);
Title,if (user?.password !== pass) {
Title,throw new UnauthorizedException();
Title,}
Title,"const payload = { username: user.username, sub: user.userId };"
Title,return {
Title,"access_token: await this.jwtService.signAsync(payload),"
Title,};
Title,}
Title,}
Title,```
Title,"We're using the @nestjs/jwt library, which supplies a signAsync() function to generate our JWT from a subset of the user object properties, which we then return as a simple object with a single access_token property. Note: we choose a property name of sub to hold our userId value to be consistent with JWT standards."
Title,We now need to update the AuthModule to import the new dependencies and configure the JwtModule.
Title,"First, create constants.ts in the auth folder, and add the following code:"
Title,typescript
Title,@@filename(auth/constants)
Title,export const jwtConstants = {
Title,"secret: 'DO NOT USE THIS VALUE. INSTEAD, CREATE A COMPLEX SECRET AND KEEP IT SAFE OUTSIDE OF THE SOURCE CODE.',"
Title,};
Title,@@switch
Title,export const jwtConstants = {
Title,"secret: 'DO NOT USE THIS VALUE. INSTEAD, CREATE A COMPLEX SECRET AND KEEP IT SAFE OUTSIDE OF THE SOURCE CODE.',"
Title,};
Title,We'll use this to share our key between the JWT signing and verifying steps.
Title,
Title,"Warning Warning Do not expose this key publicly. We have done so here to make it clear what the code is doing, but in a production system you must protect this key using appropriate measures such as a secrets vault, environment variable, or configuration service."
Title,
Title,"Now, open auth.module.ts in the auth folder and update it to look like this:"
Title,```typescript
Title,@@filename(auth/auth.module)
Title,import { Module } from '@nestjs/common';
Title,import { AuthService } from './auth.service';
Title,import { UsersModule } from '../users/users.module';
Title,import { JwtModule } from '@nestjs/jwt';
Title,import { AuthController } from './auth.controller';
Title,import { jwtConstants } from './constants';
Title,@Module({
Title,imports: [
Title,"UsersModule,"
Title,JwtModule.register({
Title,"global: true,"
Title,"secret: jwtConstants.secret,"
Title,"signOptions: { expiresIn: '60s' },"
Title,"}),"
Title,"],"
Title,"providers: [AuthService],"
Title,"controllers: [AuthController],"
Title,"exports: [AuthService],"
Title,})
Title,export class AuthModule {}
Title,@@switch
Title,import { Module } from '@nestjs/common';
Title,import { AuthService } from './auth.service';
Title,import { UsersModule } from '../users/users.module';
Title,import { JwtModule } from '@nestjs/jwt';
Title,import { AuthController } from './auth.controller';
Title,import { jwtConstants } from './constants';
Title,@Module({
Title,imports: [
Title,"UsersModule,"
Title,JwtModule.register({
Title,"global: true,"
Title,"secret: jwtConstants.secret,"
Title,"signOptions: { expiresIn: '60s' },"
Title,"}),"
Title,"],"
Title,"providers: [AuthService],"
Title,"controllers: [AuthController],"
Title,"exports: [AuthService],"
Title,})
Title,export class AuthModule {}
Title,```
Title,
Title,info Hint We're registering the JwtModule as global to make things easier for us. This means that we don't need to import the JwtModule anywhere else in our application.
Title,
Title,"We configure the JwtModule using register(), passing in a configuration object. See here for more on the Nest JwtModule and here for more details on the available configuration options."
Title,Let's go ahead and test our routes using cURL again. You can test with any of the user objects hard-coded in the UsersService.
Title,bash
Title,$ # POST to /auth/login
Title,"$ curl -X POST http://localhost:3000/auth/login -d '{""username"": ""john"", ""password"": ""changeme""}' -H ""Content-Type: application/json"""
Title,"{""access_token"":""eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...""}"
Title,$ # Note: above JWT truncated
Title,Implementing the authentication guard
Title,We can now address our final requirement: protecting endpoints by requiring a valid JWT be present on the request. We'll do this by creating an AuthGuard that we can use to protect our routes.
Title,```typescript
Title,@@filename(auth/auth.guard)
Title,import {
Title,"CanActivate,"
Title,"ExecutionContext,"
Title,"Injectable,"
Title,"UnauthorizedException,"
Title,} from '@nestjs/common';
Title,import { JwtService } from '@nestjs/jwt';
Title,import { jwtConstants } from './constants';
Title,import { Request } from 'express';
Title,@Injectable()
Title,export class AuthGuard implements CanActivate {
Title,constructor(private jwtService: JwtService) {}
Title,async canActivate(context: ExecutionContext): Promise {
Title,const request = context.switchToHttp().getRequest();
Title,const token = this.extractTokenFromHeader(request);
Title,if (!token) {
Title,throw new UnauthorizedException();
Title,}
Title,try {
Title,const payload = await this.jwtService.verifyAsync(
Title,"token,"
Title,{
Title,secret: jwtConstants.secret
Title,}
Title,);
Title,// 💡 We're assigning the payload to the request object here
Title,// so that we can access it in our route handlers
Title,request['user'] = payload;
Title,} catch {
Title,throw new UnauthorizedException();
Title,}
Title,return true;
Title,}
Title,private extractTokenFromHeader(request: Request): string | undefined {
Title,"const [type, token] = request.headers.authorization?.split(' ') ?? [];"
Title,return type === 'Bearer' ? token : undefined;
Title,}
Title,}
Title,```
Title,We can now implement our protected route and register our AuthGuard to protect it.
Title,Open the auth.controller.ts file and update it as shown below:
Title,```typescript
Title,@@filename(auth.controller)
Title,import {
Title,"Body,"
Title,"Controller,"
Title,"Get,"
Title,"HttpCode,"
Title,"HttpStatus,"
Title,"Post,"
Title,"Request,"
Title,UseGuards
Title,} from '@nestjs/common';
Title,import { AuthGuard } from './auth.guard';
Title,import { AuthService } from './auth.service';
Title,@Controller('auth')
Title,export class AuthController {
Title,constructor(private authService: AuthService) {}
Title,@HttpCode(HttpStatus.OK)
Title,@Post('login')
Title,signIn(@Body() signInDto: Record) {
Title,"return this.authService.signIn(signInDto.username, signInDto.password);"
Title,}
Title,@UseGuards(AuthGuard)
Title,@Get('profile')
Title,getProfile(@Request() req) {
Title,return req.user;
Title,}
Title,}
Title,```
Title,We're applying the AuthGuard that we just created to the GET /profile route so that it will be protected.
Title,"Ensure the app is running, and test the routes using cURL."
Title,```bash
Title,$ # GET /profile
Title,$ curl http://localhost:3000/auth/profile
Title,"{""statusCode"":401,""message"":""Unauthorized""}"
Title,$ # POST /auth/login
Title,"$ curl -X POST http://localhost:3000/auth/login -d '{""username"": ""john"", ""password"": ""changeme""}' -H ""Content-Type: application/json"""
Title,"{""access_token"":""eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm...""}"
Title,$ # GET /profile using access_token returned from previous step as bearer code
Title,"$ curl http://localhost:3000/auth/profile -H ""Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm..."""
Title,"{""sub"":1,""username"":""john"",""iat"":...,""exp"":...}"
Title,```
Title,"Note that in the AuthModule, we configured the JWT to have an expiration of 60 seconds. This is too short an expiration, and dealing with the details of token expiration and refresh is beyond the scope of this article. However, we chose that to demonstrate an important quality of JWTs. If you wait 60 seconds after authenticating before attempting a GET /auth/profile request, you'll receive a 401 Unauthorized response. This is because @nestjs/jwt automatically checks the JWT for its expiration time, saving you the trouble of doing so in your application."
Title,"We've now completed our JWT authentication implementation. JavaScript clients (such as Angular/React/Vue), and other JavaScript apps, can now authenticate and communicate securely with our API Server."
Title,Enable authentication globally
Title,"If the vast majority of your endpoints should be protected by default, you can register the authentication guard as a global guard and instead of using @UseGuards() decorator on top of each controller, you could simply flag which routes should be public."
Title,"First, register the AuthGuard as a global guard using the following construction (in any module, for example, in the AuthModule):"
Title,typescript
Title,providers: [
Title,{
Title,"provide: APP_GUARD,"
Title,"useClass: AuthGuard,"
Title,"},"
Title,"],"
Title,"With this in place, Nest will automatically bind AuthGuard to all endpoints."
Title,"Now we must provide a mechanism for declaring routes as public. For this, we can create a custom decorator using the SetMetadata decorator factory function."
Title,```typescript
Title,import { SetMetadata } from '@nestjs/common';
Title,export const IS_PUBLIC_KEY = 'isPublic';
Title,"export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);"
Title,```
Title,"In the file above, we exported two constants. One being our metadata key named IS_PUBLIC_KEY, and the other being our new decorator itself that we’re going to call Public (you can alternatively name it SkipAuth or AllowAnon, whatever fits your project)."
Title,"Now that we have a custom @Public() decorator, we can use it to decorate any method, as follows:"
Title,typescript
Title,@Public()
Title,@Get()
Title,findAll() {
Title,return [];
Title,}
Title,"Lastly, we need the AuthGuard to return true when the ""isPublic"" metadata is found. For this, we'll use the Reflector class (read more here)."
Title,```typescript
Title,@Injectable()
Title,export class AuthGuard implements CanActivate {
Title,"constructor(private jwtService: JwtService, private reflector: Reflector) {}"
Title,async canActivate(context: ExecutionContext): Promise {
Title,"const isPublic = this.reflector.getAllAndOverride(IS_PUBLIC_KEY, ["
Title,"context.getHandler(),"
Title,"context.getClass(),"
Title,]);
Title,if (isPublic) {
Title,// 💡 See this condition
Title,return true;
Title,}
Title,const request = context.switchToHttp().getRequest();
Title,const token = this.extractTokenFromHeader(request);
Title,if (!token) {
Title,throw new UnauthorizedException();
Title,}
Title,try {
Title,"const payload = await this.jwtService.verifyAsync(token, {"
Title,"secret: jwtConstants.secret,"
Title,});
Title,// 💡 We're assigning the payload to the request object here
Title,// so that we can access it in our route handlers
Title,request['user'] = payload;
Title,} catch {
Title,throw new UnauthorizedException();
Title,}
Title,return true;
Title,
Title,}
Title,private extractTokenFromHeader(request: Request): string | undefined {
Title,"const [type, token] = request.headers.authorization?.split(' ') ?? [];"
Title,return type === 'Bearer' ? token : undefined;
Title,}
Title,}
Title,```
Title,Passport integration
Title,"Passport is the most popular node.js authentication library, well-known by the community and successfully used in many production applications. It's straightforward to integrate this library with a Nest application using the @nestjs/passport module."
Title,"To learn how you can integrate Passport with NestJS, check out this chapter."
Title,Example
Title,You can find a complete version of the code in this chapter here.
Title,
Title,Authorization
Title,"Authorization refers to the process that determines what a user is able to do. For example, an administrative user is allowed to create, edit, and delete posts. A non-administrative user is only authorized to read the posts."
Title,"Authorization is orthogonal and independent from authentication. However, authorization requires an authentication mechanism."
Title,There are many different approaches and strategies to handle authorization. The approach taken for any project depends on its particular application requirements. This chapter presents a few approaches to authorization that can be adapted to a variety of different requirements.
Title,Basic RBAC implementation
Title,"Role-based access control (RBAC) is a policy-neutral access-control mechanism defined around roles and privileges. In this section, we'll demonstrate how to implement a very basic RBAC mechanism using Nest guards."
Title,"First, let's create a Role enum representing roles in the system:"
Title,typescript
Title,@@filename(role.enum)
Title,export enum Role {
Title,"User = 'user',"
Title,"Admin = 'admin',"
Title,}
Title,
Title,"info Hint In more sophisticated systems, you may store roles within a database, or pull them from the external authentication provider."
Title,
Title,"With this in place, we can create a @Roles() decorator. This decorator allows specifying what roles are required to access specific resources."
Title,```typescript
Title,@@filename(roles.decorator)
Title,import { SetMetadata } from '@nestjs/common';
Title,import { Role } from '../enums/role.enum';
Title,export const ROLES_KEY = 'roles';
Title,"export const Roles = (...roles: Role[]) => SetMetadata(ROLES_KEY, roles);"
Title,@@switch
Title,import { SetMetadata } from '@nestjs/common';
Title,export const ROLES_KEY = 'roles';
Title,"export const Roles = (...roles) => SetMetadata(ROLES_KEY, roles);"
Title,```
Title,"Now that we have a custom @Roles() decorator, we can use it to decorate any route handler."
Title,typescript
Title,@@filename(cats.controller)
Title,@Post()
Title,@Roles(Role.Admin)
Title,create(@Body() createCatDto: CreateCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,@@switch
Title,@Post()
Title,@Roles(Role.Admin)
Title,@Bind(Body())
Title,create(createCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,"Finally, we create a RolesGuard class which will compare the roles assigned to the current user to the actual roles required by the current route being processed. In order to access the route's role(s) (custom metadata), we'll use the Reflector helper class, which is provided out of the box by the framework and exposed from the @nestjs/core package."
Title,```typescript
Title,@@filename(roles.guard)
Title,"import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';"
Title,import { Reflector } from '@nestjs/core';
Title,@Injectable()
Title,export class RolesGuard implements CanActivate {
Title,constructor(private reflector: Reflector) {}
Title,canActivate(context: ExecutionContext): boolean {
Title,"const requiredRoles = this.reflector.getAllAndOverride(ROLES_KEY, ["
Title,"context.getHandler(),"
Title,"context.getClass(),"
Title,]);
Title,if (!requiredRoles) {
Title,return true;
Title,}
Title,const { user } = context.switchToHttp().getRequest();
Title,return requiredRoles.some((role) => user.roles?.includes(role));
Title,}
Title,}
Title,@@switch
Title,"import { Injectable, Dependencies } from '@nestjs/common';"
Title,import { Reflector } from '@nestjs/core';
Title,@Injectable()
Title,@Dependencies(Reflector)
Title,export class RolesGuard {
Title,constructor(reflector) {
Title,this.reflector = reflector;
Title,}
Title,canActivate(context) {
Title,"const requiredRoles = this.reflector.getAllAndOverride(ROLES_KEY, ["
Title,"context.getHandler(),"
Title,"context.getClass(),"
Title,]);
Title,if (!requiredRoles) {
Title,return true;
Title,}
Title,const { user } = context.switchToHttp().getRequest();
Title,return requiredRoles.some((role) => user.roles.includes(role));
Title,}
Title,}
Title,```
Title,
Title,info Hint Refer to the Reflection and metadata section of the Execution context chapter for more details on utilizing Reflector in a context-sensitive way.
Title,"warning Notice This example is named ""basic"" as we only check for the presence of roles on the route handler level. In real-world applications, you may have endpoints/handlers that involve several operations, in which each of them requires a specific set of permissions. In this case, you'll have to provide a mechanism to check roles somewhere within your business-logic, making it somewhat harder to maintain as there will be no centralized place that associates permissions with specific actions."
Title,
Title,"In this example, we assumed that request.user contains the user instance and allowed roles (under the roles property). In your app, you will probably make that association in your custom authentication guard - see authentication chapter for more details."
Title,"To make sure this example works, your User class must look as follows:"
Title,typescript
Title,class User {
Title,// ...other properties
Title,roles: Role[];
Title,}
Title,"Lastly, make sure to register the RolesGuard, for example, at the controller level, or globally:"
Title,typescript
Title,providers: [
Title,{
Title,"provide: APP_GUARD,"
Title,"useClass: RolesGuard,"
Title,"},"
Title,"],"
Title,"When a user with insufficient privileges requests an endpoint, Nest automatically returns the following response:"
Title,typescript
Title,{
Title,"""statusCode"": 403,"
Title,"""message"": ""Forbidden resource"","
Title,"""error"": ""Forbidden"""
Title,}
Title,
Title,"info Hint If you want to return a different error response, you should throw your own specific exception instead of returning a boolean value."
Title,
Title,
Title,Claims-based authorization
Title,"When an identity is created it may be assigned one or more claims issued by a trusted party. A claim is a name-value pair that represents what the subject can do, not what the subject is."
Title,"To implement a Claims-based authorization in Nest, you can follow the same steps we have shown above in the RBAC section with one significant difference: instead of checking for specific roles, you should compare permissions. Every user would have a set of permissions assigned. Likewise, each resource/endpoint would define what permissions are required (for example, through a dedicated @RequirePermissions() decorator) to access them."
Title,typescript
Title,@@filename(cats.controller)
Title,@Post()
Title,@RequirePermissions(Permission.CREATE_CAT)
Title,create(@Body() createCatDto: CreateCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,@@switch
Title,@Post()
Title,@RequirePermissions(Permission.CREATE_CAT)
Title,@Bind(Body())
Title,create(createCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,
Title,"info Hint In the example above, Permission (similar to Role we have shown in RBAC section) is a TypeScript enum that contains all the permissions available in your system."
Title,
Title,Integrating CASL
Title,CASL is an isomorphic authorization library which restricts what resources a given client is allowed to access. It's designed to be incrementally adoptable and can easily scale between a simple claim based and fully featured subject and attribute based authorization.
Title,"To start, first install the @casl/ability package:"
Title,bash
Title,$ npm i @casl/ability
Title,
Title,"info Hint In this example, we chose CASL, but you can use any other library like accesscontrol or acl, depending on your preferences and project needs."
Title,
Title,"Once the installation is complete, for the sake of illustrating the mechanics of CASL, we'll define two entity classes: User and Article."
Title,typescript
Title,class User {
Title,id: number;
Title,isAdmin: boolean;
Title,}
Title,"User class consists of two properties, id, which is a unique user identifier, and isAdmin, indicating whether a user has administrator privileges."
Title,typescript
Title,class Article {
Title,id: number;
Title,isPublished: boolean;
Title,authorId: number;
Title,}
Title,"Article class has three properties, respectively id, isPublished, and authorId. id is a unique article identifier, isPublished indicates whether an article was already published or not, and authorId, which is an ID of a user who wrote the article."
Title,Now let's review and refine our requirements for this example:
Title,
Title,Admins can manage (create/read/update/delete) all entities
Title,Users have read-only access to everything
Title,Users can update their articles (article.authorId === userId)
Title,Articles that are published already cannot be removed (article.isPublished === true)
Title,
Title,"With this in mind, we can start off by creating an Action enum representing all possible actions that the users can perform with entities:"
Title,typescript
Title,export enum Action {
Title,"Manage = 'manage',"
Title,"Create = 'create',"
Title,"Read = 'read',"
Title,"Update = 'update',"
Title,"Delete = 'delete',"
Title,}
Title,
Title,"warning Notice manage is a special keyword in CASL which represents ""any"" action."
Title,
Title,"To encapsulate CASL library, let's generate the CaslModule and CaslAbilityFactory now."
Title,bash
Title,$ nest g module casl
Title,$ nest g class casl/casl-ability.factory
Title,"With this in place, we can define the createForUser() method on the CaslAbilityFactory. This method will create the Ability object for a given user:"
Title,```typescript
Title,type Subjects = InferSubjects | 'all';
Title,"export type AppAbility = Ability<[Action, Subjects]>;"
Title,@Injectable()
Title,export class CaslAbilityFactory {
Title,createForUser(user: User) {
Title,"const { can, cannot, build } = new AbilityBuilder<"
Title,"Ability<[Action, Subjects]>"
Title,>(Ability as AbilityClass);
Title,if (user.isAdmin) {
Title,"can(Action.Manage, 'all'); // read-write access to everything"
Title,} else {
Title,"can(Action.Read, 'all'); // read-only access to everything"
Title,}
Title,
Title,"can(Action.Update, Article, { authorId: user.id });"
Title,"cannot(Action.Delete, Article, { isPublished: true });"
Title,
Title,return build({
Title,// Read https://casl.js.org/v6/en/guide/subject-type-detection#use-classes-as-subject-types for details
Title,detectSubjectType: (item) =>
Title,"item.constructor as ExtractSubjectType<Subjects>,"
Title,});
Title,
Title,}
Title,}
Title,```
Title,
Title,"warning Notice all is a special keyword in CASL that represents ""any subject""."
Title,"info Hint Ability, AbilityBuilder, AbilityClass, and ExtractSubjectType classes are exported from the @casl/ability package."
Title,info Hint detectSubjectType option let CASL understand how to get subject type out of an object. For more information read CASL documentation for details.
Title,
Title,"In the example above, we created the Ability instance using the AbilityBuilder class. As you probably guessed, can and cannot accept the same arguments but have different meanings, can allows to do an action on the specified subject and cannot forbids. Both may accept up to 4 arguments. To learn more about these functions, visit the official CASL documentation."
Title,"Lastly, make sure to add the CaslAbilityFactory to the providers and exports arrays in the CaslModule module definition:"
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { CaslAbilityFactory } from './casl-ability.factory';
Title,@Module({
Title,"providers: [CaslAbilityFactory],"
Title,"exports: [CaslAbilityFactory],"
Title,})
Title,export class CaslModule {}
Title,```
Title,"With this in place, we can inject the CaslAbilityFactory to any class using standard constructor injection as long as the CaslModule is imported in the host context:"
Title,typescript
Title,constructor(private caslAbilityFactory: CaslAbilityFactory) {}
Title,Then use it in a class as follows.
Title,typescript
Title,const ability = this.caslAbilityFactory.createForUser(user);
Title,"if (ability.can(Action.Read, 'all')) {"
Title,"// ""user"" has read access to everything"
Title,}
Title,
Title,info Hint Learn more about the Ability class in the official CASL documentation.
Title,
Title,"For example, let's say we have a user who is not an admin. In this case, the user should be able to read articles, but creating new ones or removing the existing articles should be prohibited."
Title,```typescript
Title,const user = new User();
Title,user.isAdmin = false;
Title,const ability = this.caslAbilityFactory.createForUser(user);
Title,"ability.can(Action.Read, Article); // true"
Title,"ability.can(Action.Delete, Article); // false"
Title,"ability.can(Action.Create, Article); // false"
Title,```
Title,
Title,"info Hint Although both Ability and AbilityBuilder classes provide can and cannot methods, they have different purposes and accept slightly different arguments."
Title,
Title,"Also, as we have specified in our requirements, the user should be able to update its articles:"
Title,```typescript
Title,const user = new User();
Title,user.id = 1;
Title,const article = new Article();
Title,article.authorId = user.id;
Title,const ability = this.caslAbilityFactory.createForUser(user);
Title,"ability.can(Action.Update, article); // true"
Title,article.authorId = 2;
Title,"ability.can(Action.Update, article); // false"
Title,```
Title,"As you can see, Ability instance allows us to check permissions in pretty readable way. Likewise, AbilityBuilder allows us to define permissions (and specify various conditions) in a similar fashion. To find more examples, visit the official documentation."
Title,Advanced: Implementing a PoliciesGuard
Title,"In this section, we'll demonstrate how to build a somewhat more sophisticated guard, which checks if a user meets specific authorization policies that can be configured on the method-level (you can extend it to respect policies configured on the class-level too). In this example, we are going to use the CASL package just for illustration purposes, but using this library is not required. Also, we will use the CaslAbilityFactory provider that we've created in the previous section."
Title,"First, let's flesh out the requirements. The goal is to provide a mechanism that allows specifying policy checks per route handler. We will support both objects and functions (for simpler checks and for those who prefer more functional-style code)."
Title,Let's start off by defining interfaces for policy handlers:
Title,```typescript
Title,import { AppAbility } from '../casl/casl-ability.factory';
Title,interface IPolicyHandler {
Title,handle(ability: AppAbility): boolean;
Title,}
Title,type PolicyHandlerCallback = (ability: AppAbility) => boolean;
Title,export type PolicyHandler = IPolicyHandler | PolicyHandlerCallback;
Title,```
Title,"As mentioned above, we provided two possible ways of defining a policy handler, an object (instance of a class that implements the IPolicyHandler interface) and a function (which meets the PolicyHandlerCallback type)."
Title,"With this in place, we can create a @CheckPolicies() decorator. This decorator allows specifying what policies have to be met to access specific resources."
Title,typescript
Title,export const CHECK_POLICIES_KEY = 'check_policy';
Title,export const CheckPolicies = (...handlers: PolicyHandler[]) =>
Title,"SetMetadata(CHECK_POLICIES_KEY, handlers);"
Title,Now let's create a PoliciesGuard that will extract and execute all the policy handlers bound to a route handler.
Title,```typescript
Title,@Injectable()
Title,export class PoliciesGuard implements CanActivate {
Title,constructor(
Title,"private reflector: Reflector,"
Title,"private caslAbilityFactory: CaslAbilityFactory,"
Title,) {}
Title,async canActivate(context: ExecutionContext): Promise {
Title,const policyHandlers =
Title,this.reflector.get(
Title,"CHECK_POLICIES_KEY,"
Title,"context.getHandler(),"
Title,) || [];
Title,const { user } = context.switchToHttp().getRequest();
Title,const ability = this.caslAbilityFactory.createForUser(user);
Title,
Title,return policyHandlers.every((handler) =>
Title,"this.execPolicyHandler(handler, ability),"
Title,);
Title,
Title,}
Title,"private execPolicyHandler(handler: PolicyHandler, ability: AppAbility) {"
Title,if (typeof handler === 'function') {
Title,return handler(ability);
Title,}
Title,return handler.handle(ability);
Title,}
Title,}
Title,```
Title,
Title,"info Hint In this example, we assumed that request.user contains the user instance. In your app, you will probably make that association in your custom authentication guard - see authentication chapter for more details."
Title,
Title,"Let's break this example down. The policyHandlers is an array of handlers assigned to the method through the @CheckPolicies() decorator. Next, we use the CaslAbilityFactory#create method which constructs the Ability object, allowing us to verify whether a user has sufficient permissions to perform specific actions. We are passing this object to the policy handler which is either a function or an instance of a class that implements the IPolicyHandler, exposing the handle() method that returns a boolean. Lastly, we use the Array#every method to make sure that every handler returned true value."
Title,"Finally, to test this guard, bind it to any route handler, and register an inline policy handler (functional approach), as follows:"
Title,typescript
Title,@Get()
Title,@UseGuards(PoliciesGuard)
Title,"@CheckPolicies((ability: AppAbility) => ability.can(Action.Read, Article))"
Title,findAll() {
Title,return this.articlesService.findAll();
Title,}
Title,"Alternatively, we can define a class which implements the IPolicyHandler interface:"
Title,typescript
Title,export class ReadArticlePolicyHandler implements IPolicyHandler {
Title,handle(ability: AppAbility) {
Title,"return ability.can(Action.Read, Article);"
Title,}
Title,}
Title,And use it as follows:
Title,typescript
Title,@Get()
Title,@UseGuards(PoliciesGuard)
Title,@CheckPolicies(new ReadArticlePolicyHandler())
Title,findAll() {
Title,return this.articlesService.findAll();
Title,}
Title,
Title,"warning Notice Since we must instantiate the policy handler in-place using the new keyword, ReadArticlePolicyHandler class cannot use the Dependency Injection. This can be addressed with the ModuleRef#get method (read more here). Basically, instead of registering functions and instances through the @CheckPolicies() decorator, you must allow passing a Type<IPolicyHandler>. Then, inside your guard, you could retrieve an instance using a type reference: moduleRef.get(YOUR_HANDLER_TYPE) or even dynamically instantiate it using the ModuleRef#create method."
Title,
Title,
Title,CORS
Title,"Cross-origin resource sharing (CORS) is a mechanism that allows resources to be requested from another domain. Under the hood, Nest makes use of the Express cors or Fastify @fastify/cors packages depending on the underlying platform. These packages provide various options that you can customize based on your requirements."
Title,Getting started
Title,"To enable CORS, call the enableCors() method on the Nest application object."
Title,typescript
Title,const app = await NestFactory.create(AppModule);
Title,app.enableCors();
Title,await app.listen(process.env.PORT ?? 3000);
Title,The enableCors() method takes an optional configuration object argument. The available properties of this object are described in the official CORS documentation. Another way is to pass a callback function that lets you define the configuration object asynchronously based on the request (on the fly).
Title,"Alternatively, enable CORS via the create() method's options object. Set the cors property to true to enable CORS with default settings."
Title,"Or, pass a CORS configuration object or callback function as the cors property value to customize its behavior."
Title,typescript
Title,"const app = await NestFactory.create(AppModule, { cors: true });"
Title,await app.listen(process.env.PORT ?? 3000);
Title,
Title,CSRF Protection
Title,"Cross-site request forgery (CSRF or XSRF) is a type of attack where unauthorized commands are sent from a trusted user to a web application. To help prevent this, you can use the csrf-csrf package."
Title,Use with Express (default)
Title,Start by installing the required package:
Title,bash
Title,$ npm i csrf-csrf
Title,
Title,"warning Warning As noted in the csrf-csrf documentation, this middleware requires session middleware or cookie-parser to be initialized beforehand. Please refer to the documentation for further details."
Title,
Title,"Once the installation is complete, register the csrf-csrf middleware as global middleware."
Title,typescript
Title,import { doubleCsrf } from 'csrf-csrf';
Title,// ...
Title,// somewhere in your initialization file
Title,const {
Title,"invalidCsrfTokenError, // This is provided purely for convenience if you plan on creating your own middleware."
Title,"generateToken, // Use this in your routes to generate and provide a CSRF hash, along with a token cookie and token."
Title,"validateRequest, // Also a convenience if you plan on making your own middleware."
Title,"doubleCsrfProtection, // This is the default CSRF protection middleware."
Title,} = doubleCsrf(doubleCsrfOptions);
Title,app.use(doubleCsrfProtection);
Title,Use with Fastify
Title,Start by installing the required package:
Title,bash
Title,$ npm i --save @fastify/csrf-protection
Title,"Once the installation is complete, register the @fastify/csrf-protection plugin, as follows:"
Title,typescript
Title,import fastifyCsrf from '@fastify/csrf-protection';
Title,// ...
Title,// somewhere in your initialization file after registering some storage plugin
Title,await app.register(fastifyCsrf);
Title,
Title,"warning Warning As explained in the @fastify/csrf-protection docs here, this plugin requires a storage plugin to be initialized first. Please, see that documentation for further instructions."
Title,
Title,
Title,Encryption and Hashing
Title,"Encryption is the process of encoding information. This process converts the original representation of the information, known as plaintext, into an alternative form known as ciphertext. Ideally, only authorized parties can decipher a ciphertext back to plaintext and access the original information. Encryption does not itself prevent interference but denies the intelligible content to a would-be interceptor. Encryption is a two-way function; what is encrypted can be decrypted with the proper key."
Title,"Hashing is the process of converting a given key into another value. A hash function is used to generate the new value according to a mathematical algorithm. Once hashing has been done, it should be impossible to go from the output to the input."
Title,Encryption
Title,"Node.js provides a built-in crypto module that you can use to encrypt and decrypt strings, numbers, buffers, streams, and more. Nest itself does not provide any additional package on top of this module to avoid introducing unnecessary abstractions."
Title,"As an example, let's use AES (Advanced Encryption System) 'aes-256-ctr' algorithm CTR encryption mode."
Title,```typescript
Title,"import { createCipheriv, randomBytes, scrypt } from 'crypto';"
Title,import { promisify } from 'util';
Title,const iv = randomBytes(16);
Title,const password = 'Password used to generate key';
Title,// The key length is dependent on the algorithm.
Title,"// In this case for aes256, it is 32 bytes."
Title,"const key = (await promisify(scrypt)(password, 'salt', 32)) as Buffer;"
Title,"const cipher = createCipheriv('aes-256-ctr', key, iv);"
Title,const textToEncrypt = 'Nest';
Title,const encryptedText = Buffer.concat([
Title,"cipher.update(textToEncrypt),"
Title,"cipher.final(),"
Title,]);
Title,```
Title,Now to decrypt encryptedText value:
Title,```typescript
Title,import { createDecipheriv } from 'crypto';
Title,"const decipher = createDecipheriv('aes-256-ctr', key, iv);"
Title,const decryptedText = Buffer.concat([
Title,"decipher.update(encryptedText),"
Title,"decipher.final(),"
Title,]);
Title,```
Title,Hashing
Title,"For hashing, we recommend using either the bcrypt or argon2 packages. Nest itself does not provide any additional wrappers on top of these modules to avoid introducing unnecessary abstractions (making the learning curve short)."
Title,"As an example, let's use bcrypt to hash a random password."
Title,First install required packages:
Title,shell
Title,$ npm i bcrypt
Title,$ npm i -D @types/bcrypt
Title,"Once the installation is complete, you can use the hash function, as follows:"
Title,```typescript
Title,import * as bcrypt from 'bcrypt';
Title,const saltOrRounds = 10;
Title,const password = 'random_password';
Title,"const hash = await bcrypt.hash(password, saltOrRounds);"
Title,```
Title,"To generate a salt, use the genSalt function:"
Title,typescript
Title,const salt = await bcrypt.genSalt();
Title,"To compare/check a password, use the compare function:"
Title,typescript
Title,"const isMatch = await bcrypt.compare(password, hash);"
Title,You can read more about available functions here.
Title,
Title,Helmet
Title,"Helmet can help protect your app from some well-known web vulnerabilities by setting HTTP headers appropriately. Generally, Helmet is just a collection of smaller middleware functions that set security-related HTTP headers (read more)."
Title,
Title,"info Hint Note that applying helmet as global or registering it must come before other calls to app.use() or setup functions that may call app.use(). This is due to the way the underlying platform (i.e., Express or Fastify) works, where the order that middleware/routes are defined matters. If you use middleware like helmet or cors after you define a route, then that middleware will not apply to that route, it will only apply to routes defined after the middleware."
Title,
Title,Use with Express (default)
Title,Start by installing the required package.
Title,bash
Title,$ npm i --save helmet
Title,"Once the installation is complete, apply it as a global middleware."
Title,typescript
Title,import helmet from 'helmet';
Title,// somewhere in your initialization file
Title,app.use(helmet());
Title,
Title,"warning Warning When using helmet, @apollo/server (4.x), and the Apollo Sandbox, there may be a problem with CSP on the Apollo Sandbox. To solve this issue configure the CSP as shown below:"
Title,``typescript
Title,app.use(helmet({
Title,"crossOriginEmbedderPolicy: false,"
Title,contentSecurityPolicy: {
Title,directives: {
Title,"imgSrc: ['self', 'data:', 'apollo-server-landing-page.cdn.apollographql.com'],"
Title,"scriptSrc: ['self',https: 'unsafe-inline'],"
Title,"manifestSrc: ['self', 'apollo-server-landing-page.cdn.apollographql.com'],"
Title,"frameSrc: ['self'`, 'sandbox.embed.apollographql.com'],"
Title,"},"
Title,"},"
Title,}));
Title,
Title,Use with Fastify
Title,"If you are using the FastifyAdapter, install the @fastify/helmet package:"
Title,bash
Title,$ npm i --save @fastify/helmet
Title,"fastify-helmet should not be used as a middleware, but as a Fastify plugin, i.e., by using app.register():"
Title,typescript
Title,import helmet from '@fastify/helmet'
Title,// somewhere in your initialization file
Title,await app.register(helmet)
Title,
Title,"warning Warning When using apollo-server-fastify and @fastify/helmet, there may be a problem with CSP on the GraphQL playground, to solve this collision, configure the CSP as shown below:"
Title,``typescript
Title,"await app.register(fastifyHelmet, {"
Title,contentSecurityPolicy: {
Title,directives: {
Title,"defaultSrc: ['self', 'unpkg.com'],"
Title,"styleSrc: ['self','unsafe-inline',"
Title,"'cdn.jsdelivr.net',"
Title,"'fonts.googleapis.com',"
Title,"'unpkg.com',"
Title,"],"
Title,"fontSrc: ['self', 'fonts.gstatic.com', 'data:'],"
Title,"imgSrc: ['self', 'data:', 'cdn.jsdelivr.net'],"
Title,"scriptSrc: ['self',https: 'unsafe-inline',cdn.jsdelivr.net,'unsafe-eval'`,"
Title,"],"
Title,"},"
Title,"},"
Title,});
Title,"// If you are not going to use CSP at all, you can use this:"
Title,"await app.register(fastifyHelmet, {"
Title,"contentSecurityPolicy: false,"
Title,});
Title,```
Title,
Title,
Title,Rate Limiting
Title,"A common technique to protect applications from brute-force attacks is rate-limiting. To get started, you'll need to install the @nestjs/throttler package."
Title,bash
Title,$ npm i --save @nestjs/throttler
Title,"Once the installation is complete, the ThrottlerModule can be configured as any other Nest package with forRoot or forRootAsync methods."
Title,typescript
Title,@@filename(app.module)
Title,@Module({
Title,imports: [
Title,ThrottlerModule.forRoot([{
Title,"ttl: 60000,"
Title,"limit: 10,"
Title,"}]),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,"The above will set the global options for the ttl, the time to live in milliseconds, and the limit, the maximum number of requests within the ttl, for the routes of your application that are guarded."
Title,"Once the module has been imported, you can then choose how you would like to bind the ThrottlerGuard. Any kind of binding as mentioned in the guards section is fine. If you wanted to bind the guard globally, for example, you could do so by adding this provider to any module:"
Title,typescript
Title,{
Title,"provide: APP_GUARD,"
Title,useClass: ThrottlerGuard
Title,}
Title,Multiple Throttler Definitions
Title,"There may come upon times where you want to set up multiple throttling definitions, like no more than 3 calls in a second, 20 calls in 10 seconds, and 100 calls in a minute. To do so, you can set up your definitions in the array with named options, that can later be referenced in the @SkipThrottle() and @Throttle() decorators to change the options again."
Title,typescript
Title,@@filename(app.module)
Title,@Module({
Title,imports: [
Title,ThrottlerModule.forRoot([
Title,{
Title,"name: 'short',"
Title,"ttl: 1000,"
Title,"limit: 3,"
Title,"},"
Title,{
Title,"name: 'medium',"
Title,"ttl: 10000,"
Title,limit: 20
Title,"},"
Title,{
Title,"name: 'long',"
Title,"ttl: 60000,"
Title,limit: 100
Title,}
Title,"]),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,Customization
Title,"There may be a time where you want to bind the guard to a controller or globally, but want to disable rate limiting for one or more of your endpoints. For that, you can use the @SkipThrottle() decorator, to negate the throttler for an entire class or a single route. The @SkipThrottle() decorator can also take in an object of string keys with boolean values for if there is a case where you want to exclude most of a controller, but not every route, and configure it per throttler set if you have more than one. If you do not pass an object, the default is to use {{ '{' }} default: true {{ '}' }}"
Title,typescript
Title,@SkipThrottle()
Title,@Controller('users')
Title,export class UsersController {}
Title,This @SkipThrottle() decorator can be used to skip a route or a class or to negate the skipping of a route in a class that is skipped.
Title,typescript
Title,@SkipThrottle()
Title,@Controller('users')
Title,export class UsersController {
Title,// Rate limiting is applied to this route.
Title,@SkipThrottle({ default: false })
Title,dontSkip() {
Title,return 'List users work with Rate limiting.';
Title,}
Title,// This route will skip rate limiting.
Title,doSkip() {
Title,return 'List users work without Rate limiting.';
Title,}
Title,}
Title,"There is also the @Throttle() decorator which can be used to override the limit and ttl set in the global module, to give tighter or looser security options. This decorator can be used on a class or a function as well. With version 5 and onwards, the decorator takes in an object with the string relating to the name of the throttler set, and an object with the limit and ttl keys and integer values, similar to the options passed to the root module. If you do not have a name set in your original options, use the string default You have to configure it like this:"
Title,typescript
Title,// Override default configuration for Rate limiting and duration.
Title,"@Throttle({ default: { limit: 3, ttl: 60000 } })"
Title,@Get()
Title,findAll() {
Title,"return ""List users works with custom rate limiting."";"
Title,}
Title,Proxies
Title,"If your application is running behind a proxy server, it’s essential to configure the HTTP adapter to trust the proxy. You can refer to the specific HTTP adapter options for Express and Fastify to enable the trust proxy setting."
Title,Here's an example that demonstrates how to enable trust proxy for the Express adapter:
Title,```typescript
Title,@@filename(main.ts)
Title,import { NestFactory } from '@nestjs/core';
Title,import { AppModule } from './app.module';
Title,import { NestExpressApplication } from '@nestjs/platform-express';
Title,async function bootstrap() {
Title,const app = await NestFactory.create(AppModule);
Title,"app.set('trust proxy', 'loopback'); // Trust requests from the loopback address"
Title,await app.listen(3000);
Title,}
Title,bootstrap();
Title,@@switch
Title,import { NestFactory } from '@nestjs/core';
Title,import { AppModule } from './app.module';
Title,import { NestExpressApplication } from '@nestjs/platform-express';
Title,async function bootstrap() {
Title,const app = await NestFactory.create(AppModule);
Title,"app.set('trust proxy', 'loopback'); // Trust requests from the loopback address"
Title,await app.listen(3000);
Title,}
Title,bootstrap();
Title,```
Title,Enabling trust proxy allows you to retrieve the original IP address from the X-Forwarded-For header. You can also customize the behavior of your application by overriding the getTracker() method to extract the IP address from this header instead of relying on req.ip. The following example demonstrates how to achieve this for both Express and Fastify:
Title,```typescript
Title,@@filename(throttler-behind-proxy.guard)
Title,import { ThrottlerGuard } from '@nestjs/throttler';
Title,import { Injectable } from '@nestjs/common';
Title,@Injectable()
Title,export class ThrottlerBehindProxyGuard extends ThrottlerGuard {
Title,protected async getTracker(req: Record): Promise {
Title,return req.ips.length ? req.ips[0] : req.ip; // individualize IP extraction to meet your own needs
Title,}
Title,}
Title,```
Title,
Title,info Hint You can find the API of the req Request object for express here and for fastify here.
Title,
Title,Websockets
Title,"This module can work with websockets, but it requires some class extension. You can extend the ThrottlerGuard and override the handleRequest method like so:"
Title,```typescript
Title,@Injectable()
Title,export class WsThrottlerGuard extends ThrottlerGuard {
Title,async handleRequest(requestProps: ThrottlerRequest): Promise {
Title,const {
Title,"context,"
Title,"limit,"
Title,"ttl,"
Title,"throttler,"
Title,"blockDuration,"
Title,"getTracker,"
Title,"generateKey,"
Title,} = requestProps;
Title,const client = context.switchToWs().getClient();
Title,const tracker = client._socket.remoteAddress;
Title,"const key = generateKey(context, tracker, throttler.name);"
Title,"const { totalHits, timeToExpire, isBlocked, timeToBlockExpire } ="
Title,await this.storageService.increment(
Title,"key,"
Title,"ttl,"
Title,"limit,"
Title,"blockDuration,"
Title,"throttler.name,"
Title,);
Title,
Title,const getThrottlerSuffix = (name: string) =>
Title,name === 'default' ? '' : `-${name}`;
Title,
Title,// Throw an error when the user reached their limit.
Title,if (isBlocked) {
Title,"await this.throwThrottlingException(context, {"
Title,"limit,"
Title,"ttl,"
Title,"key,"
Title,"tracker,"
Title,"totalHits,"
Title,"timeToExpire,"
Title,"isBlocked,"
Title,"timeToBlockExpire,"
Title,});
Title,}
Title,
Title,return true;
Title,
Title,}
Title,}
Title,```
Title,
Title,"info Hint If you are using ws, it is necessary to replace the _socket with conn"
Title,
Title,There's a few things to keep in mind when working with WebSockets:
Title,
Title,Guard cannot be registered with the APP_GUARD or app.useGlobalGuards()
Title,"When a limit is reached, Nest will emit an exception event, so make sure there is a listener ready for this"
Title,
Title,
Title,info Hint If you are using the @nestjs/platform-ws package you can use client._socket.remoteAddress instead.
Title,
Title,GraphQL
Title,"The ThrottlerGuard can also be used to work with GraphQL requests. Again, the guard can be extended, but this time the getRequestResponse method will be overridden"
Title,typescript
Title,@Injectable()
Title,export class GqlThrottlerGuard extends ThrottlerGuard {
Title,getRequestResponse(context: ExecutionContext) {
Title,const gqlCtx = GqlExecutionContext.create(context);
Title,const ctx = gqlCtx.getContext();
Title,"return { req: ctx.req, res: ctx.res };"
Title,}
Title,}
Title,Configuration
Title,The following options are valid for the object passed to the array of the ThrottlerModule's options:
Title,
Title,
Title,name
Title,the name for internal tracking of which throttler set is being used. Defaults to `default` if not passed
Title,
Title,
Title,ttl
Title,the number of milliseconds that each request will last in storage
Title,
Title,
Title,limit
Title,the maximum number of requests within the TTL limit
Title,
Title,
Title,blockDuration
Title,the number of milliseconds that request will be blocked for that time
Title,
Title,
Title,ignoreUserAgents
Title,an array of regular expressions of user-agents to ignore when it comes to throttling requests
Title,
Title,
Title,skipIf
Title,"a function that takes in the ExecutionContext and returns a boolean to short circuit the throttler logic. Like @SkipThrottler(), but based on the request"
Title,
Title,
Title,"If you need to set up storage instead, or want to use some of the above options in a more global sense, applying to each throttler set, you can pass the options above via the throttlers option key and use the below table"
Title,
Title,
Title,storage
Title,a custom storage service for where the throttling should be kept track. See here.
Title,
Title,
Title,ignoreUserAgents
Title,an array of regular expressions of user-agents to ignore when it comes to throttling requests
Title,
Title,
Title,skipIf
Title,"a function that takes in the ExecutionContext and returns a boolean to short circuit the throttler logic. Like @SkipThrottler(), but based on the request"
Title,
Title,
Title,throttlers
Title,"an array of throttler sets, defined using the table above"
Title,
Title,
Title,errorMessage
Title,a string OR a function that takes in the ExecutionContext and the ThrottlerLimitDetail and returns a string which overrides the default throttler error message
Title,
Title,
Title,getTracker
Title,a function that takes in the Request and returns a string to override the default logic of the getTracker method
Title,
Title,
Title,generateKey
Title,"a function that takes in the ExecutionContext, the tacker string and the throttler name as a string and returns a string to override the final key which will be used to store the rate limit value. This overrides the default logic of the generateKey method"
Title,
Title,
Title,Async Configuration
Title,"You may want to get your rate-limiting configuration asynchronously instead of synchronously. You can use the forRootAsync() method, which allows for dependency injection and async methods."
Title,One approach would be to use a factory function:
Title,typescript
Title,@Module({
Title,imports: [
Title,ThrottlerModule.forRootAsync({
Title,"imports: [ConfigModule],"
Title,"inject: [ConfigService],"
Title,useFactory: (config: ConfigService) => [
Title,{
Title,"ttl: config.get('THROTTLE_TTL'),"
Title,"limit: config.get('THROTTLE_LIMIT'),"
Title,"},"
Title,"],"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,You can also use the useClass syntax:
Title,typescript
Title,@Module({
Title,imports: [
Title,ThrottlerModule.forRootAsync({
Title,"imports: [ConfigModule],"
Title,"useClass: ThrottlerConfigService,"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,"This is doable, as long as ThrottlerConfigService implements the interface ThrottlerOptionsFactory."
Title,Storages
Title,The built in storage is an in memory cache that keeps track of the requests made until they have passed the TTL set by the global options. You can drop in your own storage option to the storage option of the ThrottlerModule so long as the class implements the ThrottlerStorage interface.
Title,For distributed servers you could use the community storage provider for Redis to have a single source of truth.
Title,
Title,info Note ThrottlerStorage can be imported from @nestjs/throttler.
Title,
Title,Time Helpers
Title,"There are a couple of helper methods to make the timings more readable if you prefer to use them over the direct definition. @nestjs/throttler exports five different helpers, seconds, minutes, hours, days, and weeks. To use them, simply call seconds(5) or any of the other helpers, and the correct number of milliseconds will be returned."
Title,Migration Guide
Title,"For most people, wrapping your options in an array will be enough."
Title,"If you are using a custom storage, you should wrap your ttl and limit in an"
Title,array and assign it to the throttlers property of the options object.
Title,Any @ThrottleSkip() should now take in an object with string: boolean props.
Title,"The strings are the names of the throttlers. If you do not have a name, pass the"
Title,"string 'default', as this is what will be used under the hood otherwise."
Title,"Any @Throttle() decorators should also now take in an object with string keys,"
Title,"relating to the names of the throttler contexts (again, 'default' if no name)"
Title,and values of objects that have limit and ttl keys.
Title,
Title,Warning Important The ttl is now in milliseconds. If you want to keep your ttl
Title,"in seconds for readability, use the seconds helper from this package. It just"
Title,multiplies the ttl by 1000 to make it in milliseconds.
Title,
Title,"For more info, see the Changelog"
Title,
Title,Support
Title,"Nest is an MIT-licensed open source project with its ongoing development made possible thanks to the support by the community. This framework is a result of the long road, full of sleepless nights, working after hours, and busy weekends."
Title,How can you help?
Title,"Nest doesn't have a large company that sits behind and is continuously paying for hours spent on the development. I fully rely on the goodness ❤️ of the people. However, I would love to make this framework even more powerful, to be fully focused on delivering you great solutions that make coding process enjoyable: In order to help me, I run few supporting platforms:"
Title,
Title,become a backer or sponsor on OpenCollective
Title,use PayPal to send a one-time donation
Title,or reach me directly: mail@kamilmysliwiec.com
Title,
Title,"If you fell in love with Nest, or you run a business which is using Nest, consider sponsoring its development to ensure that the project which your product relies on is actively maintained and improved. Also, your support could help me to work more on content that benefits whole Nest community, writing either educational blog posts or recording videos."
Title,
Title,Caching
Title,Caching is a great and simple technique that helps improve your app's performance. It acts as a temporary data store providing high performance data access.
Title,Installation
Title,First install required packages:
Title,bash
Title,$ npm install @nestjs/cache-manager cache-manager
Title,
Title,"warning Warning cache-manager version 4 uses seconds for TTL (Time-To-Live). The current version of cache-manager (v5) has switched to using milliseconds instead. NestJS doesn't convert the value, and simply forwards the ttl you provide to the library. In other words:"
Title,
Title,"If using cache-manager v4, provide ttl in seconds"
Title,"If using cache-manager v5, provide ttl in milliseconds"
Title,"Documentation is referring to seconds, since NestJS was released targeting version 4 of cache-manager."
Title,
Title,
Title,In-memory cache
Title,"Nest provides a unified API for various cache storage providers. The built-in one is an in-memory data store. However, you can easily switch to a more comprehensive solution, like Redis."
Title,"In order to enable caching, import the CacheModule and call its register() method."
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { CacheModule } from '@nestjs/cache-manager';
Title,import { AppController } from './app.controller';
Title,@Module({
Title,"imports: [CacheModule.register()],"
Title,"controllers: [AppController],"
Title,})
Title,export class AppModule {}
Title,```
Title,Interacting with the Cache store
Title,"To interact with the cache manager instance, inject it to your class using the CACHE_MANAGER token, as follows:"
Title,typescript
Title,constructor(@Inject(CACHE_MANAGER) private cacheManager: Cache) {}
Title,
Title,"info Hint The Cache class is imported from the cache-manager, while CACHE_MANAGER token from the @nestjs/cache-manager package."
Title,
Title,"The get method on the Cache instance (from the cache-manager package) is used to retrieve items from the cache. If the item does not exist in the cache, null will be returned."
Title,typescript
Title,const value = await this.cacheManager.get('key');
Title,"To add an item to the cache, use the set method:"
Title,typescript
Title,"await this.cacheManager.set('key', 'value');"
Title,
Title,warning Note The in-memory cache storage can only store values of types that are supported by the structured clone algorithm.
Title,
Title,The default expiration time of the cache is 5 seconds.
Title,"You can manually specify a TTL (expiration time in seconds) for this specific key, as follows:"
Title,typescript
Title,"await this.cacheManager.set('key', 'value', 1000);"
Title,"To disable expiration of the cache, set the ttl configuration property to 0:"
Title,typescript
Title,"await this.cacheManager.set('key', 'value', 0);"
Title,"To remove an item from the cache, use the del method:"
Title,typescript
Title,await this.cacheManager.del('key');
Title,"To clear the entire cache, use the reset method:"
Title,typescript
Title,await this.cacheManager.reset();
Title,Auto-caching responses
Title,
Title,"warning Warning In GraphQL applications, interceptors are executed separately for each field resolver. Thus, CacheModule (which uses interceptors to cache responses) will not work properly."
Title,
Title,"To enable auto-caching responses, just tie the CacheInterceptor where you want to cache data."
Title,typescript
Title,@Controller()
Title,@UseInterceptors(CacheInterceptor)
Title,export class AppController {
Title,@Get()
Title,findAll(): string[] {
Title,return [];
Title,}
Title,}
Title,
Title,"warningWarning Only GET endpoints are cached. Also, HTTP server routes that inject the native response object (@Res()) cannot use the Cache Interceptor. See"
Title,response mapping for more details.
Title,
Title,"To reduce the amount of required boilerplate, you can bind CacheInterceptor to all endpoints globally:"
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,"import { CacheModule, CacheInterceptor } from '@nestjs/cache-manager';"
Title,import { AppController } from './app.controller';
Title,import { APP_INTERCEPTOR } from '@nestjs/core';
Title,@Module({
Title,"imports: [CacheModule.register()],"
Title,"controllers: [AppController],"
Title,providers: [
Title,{
Title,"provide: APP_INTERCEPTOR,"
Title,"useClass: CacheInterceptor,"
Title,"},"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,Customize caching
Title,"All cached data has its own expiration time (TTL). To customize default values, pass the options object to the register() method."
Title,typescript
Title,CacheModule.register({
Title,"ttl: 5, // seconds"
Title,"max: 10, // maximum number of items in cache"
Title,});
Title,Use module globally
Title,"When you want to use CacheModule in other modules, you'll need to import it (as is standard with any Nest module). Alternatively, declare it as a global module by setting the options object's isGlobal property to true, as shown below. In that case, you will not need to import CacheModule in other modules once it's been loaded in the root module (e.g., AppModule)."
Title,typescript
Title,CacheModule.register({
Title,"isGlobal: true,"
Title,});
Title,Global cache overrides
Title,"While global cache is enabled, cache entries are stored under a CacheKey that is auto-generated based on the route path. You may override certain cache settings (@CacheKey() and @CacheTTL()) on a per-method basis, allowing customized caching strategies for individual controller methods. This may be most relevant while using different cache stores."
Title,"You can apply the @CacheTTL() decorator on a per-controller basis to set a caching TTL for the entire controller. In situations where both controller-level and method-level cache TTL settings are defined, the cache TTL settings specified at the method level will take priority over the ones set at the controller level."
Title,typescript
Title,@Controller()
Title,@CacheTTL(50)
Title,export class AppController {
Title,@CacheKey('custom_key')
Title,@CacheTTL(20)
Title,findAll(): string[] {
Title,return [];
Title,}
Title,}
Title,
Title,info Hint The @CacheKey() and @CacheTTL() decorators are imported from the @nestjs/cache-manager package.
Title,
Title,The @CacheKey() decorator may be used with or without a corresponding @CacheTTL() decorator and vice versa. One may choose to override only the @CacheKey() or only the @CacheTTL(). Settings that are not overridden with a decorator will use the default values as registered globally (see Customize caching).
Title,WebSockets and Microservices
Title,You can also apply the CacheInterceptor to WebSocket subscribers as well as Microservice's patterns (regardless of the transport method that is being used).
Title,typescript
Title,@@filename()
Title,@CacheKey('events')
Title,@UseInterceptors(CacheInterceptor)
Title,@SubscribeMessage('events')
Title,"handleEvent(client: Client, data: string[]): Observable<string[]> {"
Title,return [];
Title,}
Title,@@switch
Title,@CacheKey('events')
Title,@UseInterceptors(CacheInterceptor)
Title,@SubscribeMessage('events')
Title,"handleEvent(client, data) {"
Title,return [];
Title,}
Title,"However, the additional @CacheKey() decorator is required in order to specify a key used to subsequently store and retrieve cached data. Also, please note that you shouldn't cache everything. Actions which perform some business operations rather than simply querying the data should never be cached."
Title,"Additionally, you may specify a cache expiration time (TTL) by using the @CacheTTL() decorator, which will override the global default TTL value."
Title,typescript
Title,@@filename()
Title,@CacheTTL(10)
Title,@UseInterceptors(CacheInterceptor)
Title,@SubscribeMessage('events')
Title,"handleEvent(client: Client, data: string[]): Observable<string[]> {"
Title,return [];
Title,}
Title,@@switch
Title,@CacheTTL(10)
Title,@UseInterceptors(CacheInterceptor)
Title,@SubscribeMessage('events')
Title,"handleEvent(client, data) {"
Title,return [];
Title,}
Title,
Title,info Hint The @CacheTTL() decorator may be used with or without a corresponding @CacheKey() decorator.
Title,
Title,Adjust tracking
Title,"By default, Nest uses the request URL (in an HTTP app) or cache key (in websockets and microservices apps, set through the @CacheKey() decorator) to associate cache records with your endpoints. Nevertheless, sometimes you might want to set up tracking based on different factors, for example, using HTTP headers (e.g. Authorization to properly identify profile endpoints)."
Title,"In order to accomplish that, create a subclass of CacheInterceptor and override the trackBy() method."
Title,typescript
Title,@Injectable()
Title,class HttpCacheInterceptor extends CacheInterceptor {
Title,trackBy(context: ExecutionContext): string | undefined {
Title,return 'key';
Title,}
Title,}
Title,Different stores
Title,"The cache-manager package offers a variety of useful storage options, including the Redis store, which is the official package for integrating Redis with cache-manager. You can find a comprehensive list of supported stores here. To configure the Redis store, use the registerAsync() method to initialize it, as shown below:"
Title,```typescript
Title,import { redisStore } from 'cache-manager-redis-yet';
Title,import { Module } from '@nestjs/common';
Title,"import { CacheModule, CacheStore } from '@nestjs/cache-manager';"
Title,import { AppController } from './app.controller';
Title,@Module({
Title,imports: [
Title,CacheModule.registerAsync({
Title,useFactory: async () => {
Title,const store = await redisStore({
Title,socket: {
Title,"host: 'localhost',"
Title,"port: 6379,"
Title,"},"
Title,});
Title,return {
Title,"store: store as unknown as CacheStore,"
Title,"ttl: 3 * 60000, // 3 minutes (milliseconds)"
Title,};
Title,"},"
Title,"}),"
Title,
Title,"],"
Title,"controllers: [AppController],"
Title,})
Title,export class AppModule {}
Title,```
Title,
Title,warning Warning The cache-manager-redis-yet package requires the ttl (time-to-live) setting to be specified directly rather than as part of the module options.
Title,
Title,Async configuration
Title,"You may want to asynchronously pass in module options instead of passing them statically at compile time. In this case, use the registerAsync() method, which provides several ways to deal with async configuration."
Title,One approach is to use a factory function:
Title,typescript
Title,CacheModule.registerAsync({
Title,useFactory: () => ({
Title,"ttl: 5,"
Title,"}),"
Title,});
Title,Our factory behaves like all other asynchronous module factories (it can be async and is able to inject dependencies through inject).
Title,typescript
Title,CacheModule.registerAsync({
Title,"imports: [ConfigModule],"
Title,useFactory: async (configService: ConfigService) => ({
Title,"ttl: configService.get('CACHE_TTL'),"
Title,"}),"
Title,"inject: [ConfigService],"
Title,});
Title,"Alternatively, you can use the useClass method:"
Title,typescript
Title,CacheModule.registerAsync({
Title,"useClass: CacheConfigService,"
Title,});
Title,The above construction will instantiate CacheConfigService inside CacheModule and will use it to get the options object. The CacheConfigService has to implement the CacheOptionsFactory interface in order to provide the configuration options:
Title,typescript
Title,@Injectable()
Title,class CacheConfigService implements CacheOptionsFactory {
Title,createCacheOptions(): CacheModuleOptions {
Title,return {
Title,"ttl: 5,"
Title,};
Title,}
Title,}
Title,"If you wish to use an existing configuration provider imported from a different module, use the useExisting syntax:"
Title,typescript
Title,CacheModule.registerAsync({
Title,"imports: [ConfigModule],"
Title,"useExisting: ConfigService,"
Title,});
Title,"This works the same as useClass with one critical difference - CacheModule will lookup imported modules to reuse any already-created ConfigService, instead of instantiating its own."
Title,
Title,"info Hint CacheModule#register and CacheModule#registerAsync and CacheOptionsFactory has an optional generic (type argument) to narrow down store-specific configuration options, making it type safe."
Title,
Title,You can also pass so-called extraProviders to the registerAsync() method. These providers will be merged with the module providers.
Title,typescript
Title,CacheModule.registerAsync({
Title,"imports: [ConfigModule],"
Title,"useClass: ConfigService,"
Title,"extraProviders: [MyAdditionalProvider],"
Title,});
Title,This is useful when you want to provide additional dependencies to the factory function or the class constructor.
Title,Example
Title,A working example is available here.
Title,
Title,Compression
Title,"Compression can greatly decrease the size of the response body, thereby increasing the speed of a web app."
Title,"For high-traffic websites in production, it is strongly recommended to offload compression from the application server - typically in a reverse proxy (e.g., Nginx). In that case, you should not use compression middleware."
Title,Use with Express (default)
Title,Use the compression middleware package to enable gzip compression.
Title,First install the required package:
Title,bash
Title,$ npm i --save compression
Title,"Once the installation is complete, apply the compression middleware as global middleware."
Title,typescript
Title,import * as compression from 'compression';
Title,// somewhere in your initialization file
Title,app.use(compression());
Title,Use with Fastify
Title,"If using the FastifyAdapter, you'll want to use fastify-compress:"
Title,bash
Title,$ npm i --save @fastify/compress
Title,"Once the installation is complete, apply the @fastify/compress middleware as global middleware."
Title,typescript
Title,import compression from '@fastify/compress';
Title,// somewhere in your initialization file
Title,await app.register(compression);
Title,"By default, @fastify/compress will use Brotli compression (on Node >= 11.7.0) when browsers indicate support for the encoding. While Brotli can be quite efficient in terms of compression ratio, it can also be quite slow. By default, Brotli sets a maximum compression quality of 11, although it can be adjusted to reduce compression time in lieu of compression quality by adjusting the BROTLI_PARAM_QUALITY between 0 min and 11 max. This will require fine tuning to optimize space/time performance. An example with quality 4:"
Title,typescript
Title,import { constants } from 'zlib';
Title,// somewhere in your initialization file
Title,"await app.register(compression, { brotliOptions: { params: { [constants.BROTLI_PARAM_QUALITY]: 4 } } });"
Title,"To simplify, you may want to tell fastify-compress to only use deflate and gzip to compress responses; you'll end up with potentially larger responses but they'll be delivered much more quickly."
Title,"To specify encodings, provide a second argument to app.register:"
Title,typescript
Title,"await app.register(compression, { encodings: ['gzip', 'deflate'] });"
Title,"The above tells fastify-compress to only use gzip and deflate encodings, preferring gzip if the client supports both."
Title,
Title,Configuration
Title,"Applications often run in different environments. Depending on the environment, different configuration settings should be used. For example, usually the local environment relies on specific database credentials, valid only for the local DB instance. The production environment would use a separate set of DB credentials. Since configuration variables change, best practice is to store configuration variables in the environment."
Title,"Externally defined environment variables are visible inside Node.js through the process.env global. We could try to solve the problem of multiple environments by setting the environment variables separately in each environment. This can quickly get unwieldy, especially in the development and testing environments where these values need to be easily mocked and/or changed."
Title,"In Node.js applications, it's common to use .env files, holding key-value pairs where each key represents a particular value, to represent each environment. Running an app in different environments is then just a matter of swapping in the correct .env file."
Title,"A good approach for using this technique in Nest is to create a ConfigModule that exposes a ConfigService which loads the appropriate .env file. While you may choose to write such a module yourself, for convenience Nest provides the @nestjs/config package out-of-the box. We'll cover this package in the current chapter."
Title,Installation
Title,"To begin using it, we first install the required dependency."
Title,bash
Title,$ npm i --save @nestjs/config
Title,
Title,info Hint The @nestjs/config package internally uses dotenv.
Title,warning Note @nestjs/config requires TypeScript 4.1 or later.
Title,
Title,Getting started
Title,"Once the installation process is complete, we can import the ConfigModule. Typically, we'll import it into the root AppModule and control its behavior using the .forRoot() static method. During this step, environment variable key/value pairs are parsed and resolved. Later, we'll see several options for accessing the ConfigService class of the ConfigModule in our other feature modules."
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { ConfigModule } from '@nestjs/config';
Title,@Module({
Title,"imports: [ConfigModule.forRoot()],"
Title,})
Title,export class AppModule {}
Title,```
Title,"The above code will load and parse a .env file from the default location (the project root directory), merge key/value pairs from the .env file with environment variables assigned to process.env, and store the result in a private structure that you can access through the ConfigService. The forRoot() method registers the ConfigService provider, which provides a get() method for reading these parsed/merged configuration variables. Since @nestjs/config relies on dotenv, it uses that package's rules for resolving conflicts in environment variable names. When a key exists both in the runtime environment as an environment variable (e.g., via OS shell exports like export DATABASE_USER=test) and in a .env file, the runtime environment variable takes precedence."
Title,A sample .env file looks something like this:
Title,json
Title,DATABASE_USER=test
Title,DATABASE_PASSWORD=test
Title,Custom env file path
Title,"By default, the package looks for a .env file in the root directory of the application. To specify another path for the .env file, set the envFilePath property of an (optional) options object you pass to forRoot(), as follows:"
Title,typescript
Title,ConfigModule.forRoot({
Title,"envFilePath: '.development.env',"
Title,});
Title,You can also specify multiple paths for .env files like this:
Title,typescript
Title,ConfigModule.forRoot({
Title,"envFilePath: ['.env.development.local', '.env.development'],"
Title,});
Title,"If a variable is found in multiple files, the first one takes precedence."
Title,Disable env variables loading
Title,"If you don't want to load the .env file, but instead would like to simply access environment variables from the runtime environment (as with OS shell exports like export DATABASE_USER=test), set the options object's ignoreEnvFile property to true, as follows:"
Title,typescript
Title,ConfigModule.forRoot({
Title,"ignoreEnvFile: true,"
Title,});
Title,Use module globally
Title,"When you want to use ConfigModule in other modules, you'll need to import it (as is standard with any Nest module). Alternatively, declare it as a global module by setting the options object's isGlobal property to true, as shown below. In that case, you will not need to import ConfigModule in other modules once it's been loaded in the root module (e.g., AppModule)."
Title,typescript
Title,ConfigModule.forRoot({
Title,"isGlobal: true,"
Title,});
Title,Custom configuration files
Title,"For more complex projects, you may utilize custom configuration files to return nested configuration objects. This allows you to group related configuration settings by function (e.g., database-related settings), and to store related settings in individual files to help manage them independently."
Title,"A custom configuration file exports a factory function that returns a configuration object. The configuration object can be any arbitrarily nested plain JavaScript object. The process.env object will contain the fully resolved environment variable key/value pairs (with .env file and externally defined variables resolved and merged as described above). Since you control the returned configuration object, you can add any required logic to cast values to an appropriate type, set default values, etc. For example:"
Title,typescript
Title,@@filename(config/configuration)
Title,export default () => ({
Title,"port: parseInt(process.env.PORT, 10) || 3000,"
Title,database: {
Title,"host: process.env.DATABASE_HOST,"
Title,"port: parseInt(process.env.DATABASE_PORT, 10) || 5432"
Title,}
Title,});
Title,We load this file using the load property of the options object we pass to the ConfigModule.forRoot() method:
Title,```typescript
Title,import configuration from './config/configuration';
Title,@Module({
Title,imports: [
Title,ConfigModule.forRoot({
Title,"load: [configuration],"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,
Title,"info Notice The value assigned to the load property is an array, allowing you to load multiple configuration files (e.g. load: [databaseConfig, authConfig])"
Title,
Title,"With custom configuration files, we can also manage custom files such as YAML files. Here is an example of a configuration using YAML format:"
Title,```yaml
Title,http:
Title,host: 'localhost'
Title,port: 8080
Title,db:
Title,postgres:
Title,url: 'localhost'
Title,port: 5432
Title,database: 'yaml-db'
Title,sqlite:
Title,database: 'sqlite.db'
Title,```
Title,"To read and parse YAML files, we can leverage the js-yaml package."
Title,bash
Title,$ npm i js-yaml
Title,$ npm i -D @types/js-yaml
Title,"Once the package is installed, we use yaml#load function to load YAML file we just created above."
Title,```typescript
Title,@@filename(config/configuration)
Title,import { readFileSync } from 'fs';
Title,import * as yaml from 'js-yaml';
Title,import { join } from 'path';
Title,const YAML_CONFIG_FILENAME = 'config.yaml';
Title,export default () => {
Title,return yaml.load(
Title,"readFileSync(join(__dirname, YAML_CONFIG_FILENAME), 'utf8'),"
Title,) as Record;
Title,};
Title,```
Title,
Title,"warning Note Nest CLI does not automatically move your ""assets"" (non-TS files) to the dist folder during the build process. To make sure that your YAML files are copied, you have to specify this in the compilerOptions#assets object in the nest-cli.json file. As an example, if the config folder is at the same level as the src folder, add compilerOptions#assets with the value ""assets"": [{{ '{' }}""include"": ""../config/*.yaml"", ""outDir"": ""./dist/config""{{ '}' }}]. Read more here."
Title,
Title,"Just a quick note - configuration files aren't automatically validated, even if you're using the validationSchema option in NestJS's ConfigModule. If you need validation or want to apply any transformations, you'll have to handle that within the factory function where you have complete control over the configuration object. This allows you to implement any custom validation logic as needed."
Title,"For example, if you want to ensure that port is within a certain range, you can add a validation step to the factory function:"
Title,```typescript
Title,@@filename(config/configuration)
Title,export default () => {
Title,const config = yaml.load(
Title,"readFileSync(join(__dirname, YAML_CONFIG_FILENAME), 'utf8'),"
Title,) as Record;
Title,if (config.http.port < 1024 || config.http.port > 49151) {
Title,throw new Error('HTTP port must be between 1024 and 49151');
Title,}
Title,return config;
Title,};
Title,```
Title,"Now, if the port is outside the specified range, the application will throw an error during startup."
Title,
Title,Using the ConfigService
Title,"To access configuration values from our ConfigService, we first need to inject ConfigService. As with any provider, we need to import its containing module - the ConfigModule - into the module that will use it (unless you set the isGlobal property in the options object passed to the ConfigModule.forRoot() method to true). Import it into a feature module as shown below."
Title,typescript
Title,@@filename(feature.module)
Title,@Module({
Title,"imports: [ConfigModule],"
Title,// ...
Title,})
Title,Then we can inject it using standard constructor injection:
Title,typescript
Title,constructor(private configService: ConfigService) {}
Title,
Title,info Hint The ConfigService is imported from the @nestjs/config package.
Title,
Title,And use it in our class:
Title,```typescript
Title,// get an environment variable
Title,const dbUser = this.configService.get('DATABASE_USER');
Title,// get a custom configuration value
Title,const dbHost = this.configService.get('database.host');
Title,```
Title,"As shown above, use the configService.get() method to get a simple environment variable by passing the variable name. You can do TypeScript type hinting by passing the type, as shown above (e.g., get<string>(...)). The get() method can also traverse a nested custom configuration object (created via a Custom configuration file), as shown in the second example above."
Title,You can also get the whole nested custom configuration object using an interface as the type hint:
Title,```typescript
Title,interface DatabaseConfig {
Title,host: string;
Title,port: number;
Title,}
Title,const dbConfig = this.configService.get('database');
Title,// you can now use dbConfig.port and dbConfig.host
Title,const port = dbConfig.port;
Title,```
Title,"The get() method also takes an optional second argument defining a default value, which will be returned when the key doesn't exist, as shown below:"
Title,typescript
Title,"// use ""localhost"" when ""database.host"" is not defined"
Title,"const dbHost = this.configService.get<string>('database.host', 'localhost');"
Title,ConfigService has two optional generics (type arguments). The first one is to help prevent accessing a config property that does not exist. Use it as shown below:
Title,```typescript
Title,interface EnvironmentVariables {
Title,PORT: number;
Title,TIMEOUT: string;
Title,}
Title,// somewhere in the code
Title,constructor(private configService: ConfigService) {
Title,"const port = this.configService.get('PORT', { infer: true });"
Title,// TypeScript Error: this is invalid as the URL property is not defined in EnvironmentVariables
Title,"const url = this.configService.get('URL', { infer: true });"
Title,}
Title,```
Title,"With the infer property set to true, the ConfigService#get method will automatically infer the property type based on the interface, so for example, typeof port === ""number"" (if you're not using strictNullChecks flag from TypeScript) since PORT has a number type in the EnvironmentVariables interface."
Title,"Also, with the infer feature, you can infer the type of a nested custom configuration object's property, even when using dot notation, as follows:"
Title,typescript
Title,constructor(private configService: ConfigService<{ database: { host: string } }>) {
Title,"const dbHost = this.configService.get('database.host', { infer: true })!;"
Title,"// typeof dbHost === ""string""                                          |"
Title,//                                                                     +--> non-null assertion operator
Title,}
Title,"The second generic relies on the first one, acting as a type assertion to get rid of all undefined types that ConfigService's methods can return when strictNullChecks is on. For instance:"
Title,typescript
Title,// ...
Title,"constructor(private configService: ConfigService<{ PORT: number }, true>) {"
Title,//                                                               ^^^^
Title,"const port = this.configService.get('PORT', { infer: true });"
Title,//    ^^^ The type of port will be 'number' thus you don't need TS type assertions anymore
Title,}
Title,Configuration namespaces
Title,"The ConfigModule allows you to define and load multiple custom configuration files, as shown in Custom configuration files above. You can manage complex configuration object hierarchies with nested configuration objects as shown in that section. Alternatively, you can return a ""namespaced"" configuration object with the registerAs() function as follows:"
Title,typescript
Title,@@filename(config/database.config)
Title,"export default registerAs('database', () => ({"
Title,"host: process.env.DATABASE_HOST,"
Title,port: process.env.DATABASE_PORT || 5432
Title,}));
Title,"As with custom configuration files, inside your registerAs() factory function, the process.env object will contain the fully resolved environment variable key/value pairs (with .env file and externally defined variables resolved and merged as described above)."
Title,
Title,info Hint The registerAs function is exported from the @nestjs/config package.
Title,
Title,"Load a namespaced configuration with the load property of the forRoot() method's options object, in the same way you load a custom configuration file:"
Title,```typescript
Title,import databaseConfig from './config/database.config';
Title,@Module({
Title,imports: [
Title,ConfigModule.forRoot({
Title,"load: [databaseConfig],"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,"Now, to get the host value from the database namespace, use dot notation. Use 'database' as the prefix to the property name, corresponding to the name of the namespace (passed as the first argument to the registerAs() function):"
Title,typescript
Title,const dbHost = this.configService.get<string>('database.host');
Title,A reasonable alternative is to inject the database namespace directly. This allows us to benefit from strong typing:
Title,typescript
Title,constructor(
Title,@Inject(databaseConfig.KEY)
Title,"private dbConfig: ConfigType<typeof databaseConfig>,"
Title,) {}
Title,
Title,info Hint The ConfigType is exported from the @nestjs/config package.
Title,
Title,Namespaced configurations in modules
Title,"To use a namespaced configuration as a configuration object for another module in your application, you can utilize the .asProvider() method of the configuration object. This method converts your namespaced configuration into a provider, which can then be passed to the forRootAsync() (or any equivalent method) of the module you want to use."
Title,Here's an example:
Title,```typescript
Title,import databaseConfig from './config/database.config';
Title,@Module({
Title,imports: [
Title,"TypeOrmModule.forRootAsync(databaseConfig.asProvider()),"
Title,"],"
Title,})
Title,```
Title,"To understand how the .asProvider() method functions, let's examine the return value:"
Title,typescript
Title,// Return value of the .asProvider() method
Title,{
Title,"imports: [ConfigModule.forFeature(databaseConfig)],"
Title,"useFactory: (configuration: ConfigType<typeof databaseConfig>) => configuration,"
Title,inject: [databaseConfig.KEY]
Title,}
Title,"This structure allows you to seamlessly integrate namespaced configurations into your modules, ensuring that your application remains organized and modular, without writing boilerplate, repetitive code."
Title,Cache environment variables
Title,"As accessing process.env can be slow, you can set the cache property of the options object passed to ConfigModule.forRoot() to increase the performance of ConfigService#get method when it comes to variables stored in process.env."
Title,typescript
Title,ConfigModule.forRoot({
Title,"cache: true,"
Title,});
Title,Partial registration
Title,"Thus far, we've processed configuration files in our root module (e.g., AppModule), with the forRoot() method. Perhaps you have a more complex project structure, with feature-specific configuration files located in multiple different directories. Rather than load all these files in the root module, the @nestjs/config package provides a feature called partial registration, which references only the configuration files associated with each feature module. Use the forFeature() static method within a feature module to perform this partial registration, as follows:"
Title,```typescript
Title,import databaseConfig from './config/database.config';
Title,@Module({
Title,"imports: [ConfigModule.forFeature(databaseConfig)],"
Title,})
Title,export class DatabaseModule {}
Title,```
Title,
Title,"info Warning In some circumstances, you may need to access properties loaded via partial registration using the onModuleInit() hook, rather than in a constructor. This is because the forFeature() method is run during module initialization, and the order of module initialization is indeterminate. If you access values loaded this way by another module, in a constructor, the module that the configuration depends upon may not yet have initialized. The onModuleInit() method runs only after all modules it depends upon have been initialized, so this technique is safe."
Title,
Title,Schema validation
Title,It is standard practice to throw an exception during application startup if required environment variables haven't been provided or if they don't meet certain validation rules. The @nestjs/config package enables two different ways to do this:
Title,
Title,"Joi built-in validator. With Joi, you define an object schema and validate JavaScript objects against it."
Title,A custom validate() function which takes environment variables as an input.
Title,
Title,"To use Joi, we must install Joi package:"
Title,bash
Title,$ npm install --save joi
Title,"Now we can define a Joi validation schema and pass it via the validationSchema property of the forRoot() method's options object, as shown below:"
Title,```typescript
Title,@@filename(app.module)
Title,import * as Joi from 'joi';
Title,@Module({
Title,imports: [
Title,ConfigModule.forRoot({
Title,validationSchema: Joi.object({
Title,NODE_ENV: Joi.string()
Title,".valid('development', 'production', 'test', 'provision')"
Title,".default('development'),"
Title,"PORT: Joi.number().port().default(3000),"
Title,"}),"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,"By default, all schema keys are considered optional. Here, we set default values for NODE_ENV and PORT which will be used if we don't provide these variables in the environment (.env file or process environment). Alternatively, we can use the required() validation method to require that a value must be defined in the environment (.env file or process environment). In this case, the validation step will throw an exception if we don't provide the variable in the environment. See Joi validation methods for more on how to construct validation schemas."
Title,"By default, unknown environment variables (environment variables whose keys are not present in the schema) are allowed and do not trigger a validation exception. By default, all validation errors are reported. You can alter these behaviors by passing an options object via the validationOptions key of the forRoot() options object. This options object can contain any of the standard validation options properties provided by Joi validation options. For example, to reverse the two settings above, pass options like this:"
Title,```typescript
Title,@@filename(app.module)
Title,import * as Joi from 'joi';
Title,@Module({
Title,imports: [
Title,ConfigModule.forRoot({
Title,validationSchema: Joi.object({
Title,NODE_ENV: Joi.string()
Title,".valid('development', 'production', 'test', 'provision')"
Title,".default('development'),"
Title,"PORT: Joi.number().port().default(3000),"
Title,"}),"
Title,validationOptions: {
Title,"allowUnknown: false,"
Title,"abortEarly: true,"
Title,"},"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,The @nestjs/config package uses default settings of:
Title,
Title,allowUnknown: controls whether or not to allow unknown keys in the environment variables. Default is true
Title,"abortEarly: if true, stops validation on the first error; if false, returns all errors. Defaults to false."
Title,
Title,"Note that once you decide to pass a validationOptions object, any settings you do not explicitly pass will default to Joi standard defaults (not the @nestjs/config defaults). For example, if you leave allowUnknowns unspecified in your custom validationOptions object, it will have the Joi default value of false. Hence, it is probably safest to specify both of these settings in your custom object."
Title,Custom validate function
Title,"Alternatively, you can specify a synchronous validate function that takes an object containing the environment variables (from env file and process) and returns an object containing validated environment variables so that you can convert/mutate them if needed. If the function throws an error, it will prevent the application from bootstrapping."
Title,"In this example, we'll proceed with the class-transformer and class-validator packages. First, we have to define:"
Title,
Title,"a class with validation constraints,"
Title,a validate function that makes use of the plainToInstance and validateSync functions.
Title,
Title,```typescript
Title,@@filename(env.validation)
Title,import { plainToInstance } from 'class-transformer';
Title,"import { IsEnum, IsNumber, Max, Min, validateSync } from 'class-validator';"
Title,enum Environment {
Title,"Development = ""development"","
Title,"Production = ""production"","
Title,"Test = ""test"","
Title,"Provision = ""provision"","
Title,}
Title,class EnvironmentVariables {
Title,@IsEnum(Environment)
Title,NODE_ENV: Environment;
Title,@IsNumber()
Title,@Min(0)
Title,@Max(65535)
Title,PORT: number;
Title,}
Title,export function validate(config: Record) {
Title,const validatedConfig = plainToInstance(
Title,"EnvironmentVariables,"
Title,"config,"
Title,"{ enableImplicitConversion: true },"
Title,);
Title,"const errors = validateSync(validatedConfig, { skipMissingProperties: false });"
Title,if (errors.length > 0) {
Title,throw new Error(errors.toString());
Title,}
Title,return validatedConfig;
Title,}
Title,```
Title,"With this in place, use the validate function as a configuration option of the ConfigModule, as follows:"
Title,```typescript
Title,@@filename(app.module)
Title,import { validate } from './env.validation';
Title,@Module({
Title,imports: [
Title,ConfigModule.forRoot({
Title,"validate,"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,Custom getter functions
Title,ConfigService defines a generic get() method to retrieve a configuration value by key. We may also add getter functions to enable a little more natural coding style:
Title,```typescript
Title,@@filename()
Title,@Injectable()
Title,export class ApiConfigService {
Title,constructor(private configService: ConfigService) {}
Title,get isAuthEnabled(): boolean {
Title,return this.configService.get('AUTH_ENABLED') === 'true';
Title,}
Title,}
Title,@@switch
Title,@Dependencies(ConfigService)
Title,@Injectable()
Title,export class ApiConfigService {
Title,constructor(configService) {
Title,this.configService = configService;
Title,}
Title,get isAuthEnabled() {
Title,return this.configService.get('AUTH_ENABLED') === 'true';
Title,}
Title,}
Title,```
Title,Now we can use the getter function as follows:
Title,typescript
Title,@@filename(app.service)
Title,@Injectable()
Title,export class AppService {
Title,constructor(apiConfigService: ApiConfigService) {
Title,if (apiConfigService.isAuthEnabled) {
Title,// Authentication is enabled
Title,}
Title,}
Title,}
Title,@@switch
Title,@Dependencies(ApiConfigService)
Title,@Injectable()
Title,export class AppService {
Title,constructor(apiConfigService) {
Title,if (apiConfigService.isAuthEnabled) {
Title,// Authentication is enabled
Title,}
Title,}
Title,}
Title,Environment variables loaded hook
Title,"If a module configuration depends on the environment variables, and these variables are loaded from the .env file, you can use the ConfigModule.envVariablesLoaded hook to ensure that the file was loaded before interacting with the process.env object, see the following example:"
Title,typescript
Title,export async function getStorageModule() {
Title,await ConfigModule.envVariablesLoaded;
Title,return process.env.STORAGE === 'S3' ? S3StorageModule : DefaultStorageModule;
Title,}
Title,"This construction guarantees that after the ConfigModule.envVariablesLoaded Promise resolves, all configuration variables are loaded up."
Title,Conditional module configuration
Title,"There may be times where you want to conditionally load in a module and specify the condition in an env variable. Fortunately, @nestjs/config provides a ConditionalModule that allows you to do just that."
Title,typescript
Title,@Module({
Title,imports: [
Title,"ConfigModule.forRoot(),"
Title,"ConditionalModule.registerWhen(FooModule, 'USE_FOO'),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,"The above module would only load in the FooModule if in the .env file there is not a false value for the env variable USE_FOO. You can also pass a custom condition yourself, a function receiving the process.env reference that should return a boolean for the ConditionalModule to handle:"
Title,typescript
Title,@Module({
Title,imports: [
Title,"ConfigModule.forRoot(),"
Title,ConditionalModule.registerWhen(
Title,"FooBarModule,"
Title,"(env: NodeJS.ProcessEnv) => !!env['foo'] && !!env['bar'],"
Title,"),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,"It is important to be sure that when using the ConditionalModule you also have the ConfigModule loaded in the application, so that the ConfigModule.envVariablesLoaded hook can be properly referenced and utilized. If the hook is not flipped to true within 5 seconds, or a timeout in milliseconds, set by the user in the third options parameter of the registerWhen method, then the ConditionalModule will throw an error and Nest will abort starting the application."
Title,Expandable variables
Title,"The @nestjs/config package supports environment variable expansion. With this technique, you can create nested environment variables, where one variable is referred to within the definition of another. For example:"
Title,json
Title,APP_URL=mywebsite.com
Title,SUPPORT_EMAIL=support@${APP_URL}
Title,"With this construction, the variable SUPPORT_EMAIL resolves to 'support@mywebsite.com'. Note the use of the ${{ '{' }}...{{ '}' }} syntax to trigger resolving the value of the variable APP_URL inside the definition of SUPPORT_EMAIL."
Title,
Title,"info Hint For this feature, @nestjs/config package internally uses dotenv-expand."
Title,
Title,"Enable environment variable expansion using the expandVariables property in the options object passed to the forRoot() method of the ConfigModule, as shown below:"
Title,typescript
Title,@@filename(app.module)
Title,@Module({
Title,imports: [
Title,ConfigModule.forRoot({
Title,// ...
Title,"expandVariables: true,"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,Using in the main.ts
Title,"While our config is stored in a service, it can still be used in the main.ts file. This way, you can use it to store variables such as the application port or the CORS host."
Title,"To access it, you must use the app.get() method, followed by the service reference:"
Title,typescript
Title,const configService = app.get(ConfigService);
Title,"You can then use it as usual, by calling the get method with the configuration key:"
Title,typescript
Title,const port = configService.get('PORT');
Title,
Title,Cookies
Title,"An HTTP cookie is a small piece of data stored by the user's browser. Cookies were designed to be a reliable mechanism for websites to remember stateful information. When the user visits the website again, the cookie is automatically sent with the request."
Title,Use with Express (default)
Title,First install the required package (and its types for TypeScript users):
Title,shell
Title,$ npm i cookie-parser
Title,$ npm i -D @types/cookie-parser
Title,"Once the installation is complete, apply the cookie-parser middleware as global middleware (for example, in your main.ts file)."
Title,typescript
Title,import * as cookieParser from 'cookie-parser';
Title,// somewhere in your initialization file
Title,app.use(cookieParser());
Title,You can pass several options to the cookieParser middleware:
Title,
Title,"secret a string or array used for signing cookies. This is optional and if not specified, will not parse signed cookies. If a string is provided, this is used as the secret. If an array is provided, an attempt will be made to unsign the cookie with each secret in order."
Title,options an object that is passed to cookie.parse as the second option. See cookie for more information.
Title,
Title,"The middleware will parse the Cookie header on the request and expose the cookie data as the property req.cookies and, if a secret was provided, as the property req.signedCookies. These properties are name value pairs of the cookie name to cookie value."
Title,"When a secret is provided, this module will unsign and validate any signed cookie values and move those name value pairs from req.cookies into req.signedCookies. A signed cookie is a cookie that has a value prefixed with s:. Signed cookies that fail signature validation will have the value false instead of the tampered value."
Title,"With this in place, you can now read cookies from within the route handlers, as follows:"
Title,typescript
Title,@Get()
Title,findAll(@Req() request: Request) {
Title,"console.log(request.cookies); // or ""request.cookies['cookieKey']"""
Title,// or console.log(request.signedCookies);
Title,}
Title,
Title,"info Hint The @Req() decorator is imported from the @nestjs/common, while Request from the express package."
Title,
Title,"To attach a cookie to an outgoing response, use the Response#cookie() method:"
Title,typescript
Title,@Get()
Title,findAll(@Res({ passthrough: true }) response: Response) {
Title,"response.cookie('key', 'value')"
Title,}
Title,
Title,"warning Warning If you want to leave the response handling logic to the framework, remember to set the passthrough option to true, as shown above. Read more here."
Title,"info Hint The @Res() decorator is imported from the @nestjs/common, while Response from the express package."
Title,
Title,Use with Fastify
Title,First install the required package:
Title,shell
Title,$ npm i @fastify/cookie
Title,"Once the installation is complete, register the @fastify/cookie plugin:"
Title,```typescript
Title,import fastifyCookie from '@fastify/cookie';
Title,// somewhere in your initialization file
Title,"const app = await NestFactory.create(AppModule, new FastifyAdapter());"
Title,"await app.register(fastifyCookie, {"
Title,"secret: 'my-secret', // for cookies signature"
Title,});
Title,```
Title,"With this in place, you can now read cookies from within the route handlers, as follows:"
Title,typescript
Title,@Get()
Title,findAll(@Req() request: FastifyRequest) {
Title,"console.log(request.cookies); // or ""request.cookies['cookieKey']"""
Title,}
Title,
Title,"info Hint The @Req() decorator is imported from the @nestjs/common, while FastifyRequest from the fastify package."
Title,
Title,"To attach a cookie to an outgoing response, use the FastifyReply#setCookie() method:"
Title,typescript
Title,@Get()
Title,findAll(@Res({ passthrough: true }) response: FastifyReply) {
Title,"response.setCookie('key', 'value')"
Title,}
Title,"To read more about FastifyReply#setCookie() method, check out this page."
Title,
Title,"warning Warning If you want to leave the response handling logic to the framework, remember to set the passthrough option to true, as shown above. Read more here."
Title,"info Hint The @Res() decorator is imported from the @nestjs/common, while FastifyReply from the fastify package."
Title,
Title,Creating a custom decorator (cross-platform)
Title,"To provide a convenient, declarative way of accessing incoming cookies, we can create a custom decorator."
Title,```typescript
Title,"import { createParamDecorator, ExecutionContext } from '@nestjs/common';"
Title,"export const Cookies = createParamDecorator((data: string, ctx: ExecutionContext) => {"
Title,const request = ctx.switchToHttp().getRequest();
Title,return data ? request.cookies?.[data] : request.cookies;
Title,});
Title,```
Title,"The @Cookies() decorator will extract all cookies, or a named cookie from the req.cookies object and populate the decorated parameter with that value."
Title,"With this in place, we can now use the decorator in a route handler signature, as follows:"
Title,typescript
Title,@Get()
Title,findAll(@Cookies('name') name: string) {}
Title,
Title,Events
Title,"Event Emitter package (@nestjs/event-emitter) provides a simple observer implementation, allowing you to subscribe and listen for various events that occur in your application. Events serve as a great way to decouple various aspects of your application, since a single event can have multiple listeners that do not depend on each other."
Title,EventEmitterModule internally uses the eventemitter2 package.
Title,Getting started
Title,First install the required package:
Title,shell
Title,$ npm i --save @nestjs/event-emitter
Title,"Once the installation is complete, import the EventEmitterModule into the root AppModule and run the forRoot() static method as shown below:"
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { EventEmitterModule } from '@nestjs/event-emitter';
Title,@Module({
Title,imports: [
Title,EventEmitterModule.forRoot()
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,"The .forRoot() call initializes the event emitter and registers any declarative event listeners that exist within your app. Registration occurs when the onApplicationBootstrap lifecycle hook occurs, ensuring that all modules have loaded and declared any scheduled jobs."
Title,"To configure the underlying EventEmitter instance, pass the configuration object to the .forRoot() method, as follows:"
Title,typescript
Title,EventEmitterModule.forRoot({
Title,// set this to `true` to use wildcards
Title,"wildcard: false,"
Title,// the delimiter used to segment namespaces
Title,"delimiter: '.',"
Title,// set this to `true` if you want to emit the newListener event
Title,"newListener: false,"
Title,// set this to `true` if you want to emit the removeListener event
Title,"removeListener: false,"
Title,// the maximum amount of listeners that can be assigned to an event
Title,"maxListeners: 10,"
Title,// show event name in memory leak message when more than maximum amount of listeners is assigned
Title,"verboseMemoryLeak: false,"
Title,// disable throwing uncaughtException if an error event is emitted and it has no listeners
Title,"ignoreErrors: false,"
Title,});
Title,Dispatching events
Title,"To dispatch (i.e., fire) an event, first inject EventEmitter2 using standard constructor injection:"
Title,typescript
Title,constructor(private eventEmitter: EventEmitter2) {}
Title,
Title,info Hint Import the EventEmitter2 from the @nestjs/event-emitter package.
Title,
Title,Then use it in a class as follows:
Title,typescript
Title,this.eventEmitter.emit(
Title,"'order.created',"
Title,new OrderCreatedEvent({
Title,"orderId: 1,"
Title,"payload: {},"
Title,"}),"
Title,);
Title,Listening to events
Title,"To declare an event listener, decorate a method with the @OnEvent() decorator preceding the method definition containing the code to be executed, as follows:"
Title,typescript
Title,@OnEvent('order.created')
Title,handleOrderCreatedEvent(payload: OrderCreatedEvent) {
Title,"// handle and process ""OrderCreatedEvent"" event"
Title,}
Title,
Title,warning Warning Event subscribers cannot be request-scoped.
Title,
Title,The first argument can be a string or symbol for a simple event emitter and a string | symbol | Array<string | symbol> in a case of a wildcard emitter.
Title,The second argument (optional) is a listener options object as follows:
Title,```typescript
Title,export type OnEventOptions = OnOptions & {
Title,/*
Title,"* If ""true"", prepends (instead of append) the given listener to the array of listeners."
Title,*
Title,* @see https://github.com/EventEmitter2/EventEmitter2#emitterprependlistenerevent-listener-options
Title,*
Title,* @default false
Title,/
Title,prependListener?: boolean;
Title,/*
Title,"* If ""true"", the onEvent callback will not throw an error while handling the event. Otherwise, if ""false"" it will throw an error."
Title,*
Title,* @default true
Title,/
Title,suppressErrors?: boolean;
Title,};
Title,```
Title,
Title,info Hint Read more about the OnOptions options object from eventemitter2.
Title,
Title,typescript
Title,"@OnEvent('order.created', { async: true })"
Title,handleOrderCreatedEvent(payload: OrderCreatedEvent) {
Title,"// handle and process ""OrderCreatedEvent"" event"
Title,}
Title,"To use namespaces/wildcards, pass the wildcard option into the EventEmitterModule#forRoot() method. When namespaces/wildcards are enabled, events can either be strings (foo.bar) separated by a delimiter or arrays (['foo', 'bar']). The delimiter is also configurable as a configuration property (delimiter). With namespaces feature enabled, you can subscribe to events using a wildcard:"
Title,typescript
Title,@OnEvent('order.*')
Title,handleOrderEvents(payload: OrderCreatedEvent | OrderRemovedEvent | OrderUpdatedEvent) {
Title,// handle and process an event
Title,}
Title,"Note that such a wildcard only applies to one block. The argument order.* will match, for example, the events order.created and order.shipped but not order.delayed.out_of_stock. In order to listen to such events,"
Title,"use the multilevel wildcard pattern (i.e, **), described in the EventEmitter2 documentation."
Title,"With this pattern, you can, for example, create an event listener that catches all events."
Title,typescript
Title,@OnEvent('**')
Title,handleEverything(payload: any) {
Title,// handle and process an event
Title,}
Title,
Title,"info Hint EventEmitter2 class provides several useful methods for interacting with events, like waitFor and onAny. You can read more about them here."
Title,
Title,Preventing event loss
Title,Events triggered before or during the onApplicationBootstrap lifecycle hook—such as those from module constructors or the onModuleInit method—may be missed because the EventSubscribersLoader might not have finished setting up the listeners.
Title,"To avoid this issue, you can use the waitUntilReady method of the EventEmitterReadinessWatcher, which returns a promise that resolves once all listeners have been registered. This method can be called in the onApplicationBootstrap lifecycle hook of a module to ensure that all events are properly captured."
Title,typescript
Title,await this.eventEmitterReadinessWatcher.waitUntilReady();
Title,await this.eventEmitter.emit(
Title,"'order.created',"
Title,"new OrderCreatedEvent({ orderId: 1, payload: {} }),"
Title,);
Title,
Title,info Note This is only necessary for events emitted before the onApplicationBootstrap lifecycle hook is complete.
Title,
Title,Example
Title,A working example is available here.
Title,
Title,File upload
Title,"To handle file uploading, Nest provides a built-in module based on the multer middleware package for Express. Multer handles data posted in the multipart/form-data format, which is primarily used for uploading files via an HTTP POST request. This module is fully configurable and you can adjust its behavior to your application requirements."
Title,
Title,"warning Warning Multer cannot process data which is not in the supported multipart format (multipart/form-data). Also, note that this package is not compatible with the FastifyAdapter."
Title,
Title,"For better type safety, let's install Multer typings package:"
Title,shell
Title,$ npm i -D @types/multer
Title,"With this package installed, we can now use the Express.Multer.File type (you can import this type as follows: import {{ '{' }} Express {{ '}' }} from 'express')."
Title,Basic example
Title,"To upload a single file, simply tie the FileInterceptor() interceptor to the route handler and extract file from the request using the @UploadedFile() decorator."
Title,typescript
Title,@@filename()
Title,@Post('upload')
Title,@UseInterceptors(FileInterceptor('file'))
Title,uploadFile(@UploadedFile() file: Express.Multer.File) {
Title,console.log(file);
Title,}
Title,@@switch
Title,@Post('upload')
Title,@UseInterceptors(FileInterceptor('file'))
Title,@Bind(UploadedFile())
Title,uploadFile(file) {
Title,console.log(file);
Title,}
Title,
Title,info Hint The FileInterceptor() decorator is exported from the @nestjs/platform-express package. The @UploadedFile() decorator is exported from @nestjs/common.
Title,
Title,The FileInterceptor() decorator takes two arguments:
Title,
Title,fieldName: string that supplies the name of the field from the HTML form that holds a file
Title,options: optional object of type MulterOptions. This is the same object used by the multer constructor (more details here).
Title,
Title,
Title,warning Warning FileInterceptor() may not be compatible with third party cloud providers like Google Firebase or others.
Title,
Title,File validation
Title,"Often times it can be useful to validate incoming file metadata, like file size or file mime-type. For this, you can create your own Pipe and bind it to the parameter annotated with the UploadedFile decorator. The example below demonstrates how a basic file size validator pipe could be implemented:"
Title,```typescript
Title,"import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';"
Title,@Injectable()
Title,export class FileSizeValidationPipe implements PipeTransform {
Title,"transform(value: any, metadata: ArgumentMetadata) {"
Title,"// ""value"" is an object containing the file's attributes and metadata"
Title,const oneKb = 1000;
Title,return value.size < oneKb;
Title,}
Title,}
Title,```
Title,This can be used in conjunction with the FileInterceptor as follows:
Title,typescript
Title,@Post('file')
Title,@UseInterceptors(FileInterceptor('file'))
Title,uploadFileAndValidate(@UploadedFile(
Title,"new FileSizeValidationPipe(),"
Title,// other pipes can be added here
Title,") file: Express.Multer.File, ) {"
Title,return file;
Title,}
Title,"Nest provides a built-in pipe to handle common use cases and facilitate/standardize the addition of new ones. This pipe is called ParseFilePipe, and you can use it as follows:"
Title,typescript
Title,@Post('file')
Title,uploadFileAndPassValidation(
Title,"@Body() body: SampleDto,"
Title,@UploadedFile(
Title,new ParseFilePipe({
Title,validators: [
Title,// ... Set of file validator instances here
Title,]
Title,})
Title,)
Title,"file: Express.Multer.File,"
Title,) {
Title,return {
Title,"body,"
Title,"file: file.buffer.toString(),"
Title,};
Title,}
Title,"As you can see, it's required to specify an array of file validators that will be executed by the ParseFilePipe. We'll discuss the interface of a validator, but it's worth mentioning this pipe also has two additional optional options:"
Title,
Title,
Title,errorHttpStatusCode
Title,The HTTP status code to be thrown in case any validator fails. Default is 400 (BAD REQUEST)
Title,
Title,
Title,exceptionFactory
Title,A factory which receives the error message and returns an error.
Title,
Title,
Title,"Now, back to the FileValidator interface. To integrate validators with this pipe, you have to either use built-in implementations or provide your own custom FileValidator. See example below:"
Title,```typescript
Title,export abstract class FileValidator> {
Title,constructor(protected readonly validationOptions: TValidationOptions) {}
Title,/*
Title,"* Indicates if this file should be considered valid, according to the options passed in the constructor."
Title,* @param file the file from the request object
Title,/
Title,abstract isValid(file?: any): boolean | Promise;
Title,/*
Title,* Builds an error message in case the validation fails.
Title,* @param file the file from the request object
Title,/
Title,abstract buildErrorMessage(file: any): string;
Title,}
Title,```
Title,
Title,"info Hint The FileValidator interfaces supports async validation via its isValid function. To leverage type security, you can also type the file parameter as Express.Multer.File in case you are using express (default) as a driver."
Title,
Title,FileValidator is a regular class that has access to the file object and validates it according to the options provided by the client. Nest has two built-in FileValidator implementations you can use in your project:
Title,
Title,MaxFileSizeValidator - Checks if a given file's size is less than the provided value (measured in bytes)
Title,FileTypeValidator - Checks if a given file's mime-type matches the given value.
Title,
Title,
Title,"warning Warning To verify file type, FileTypeValidator class uses the type as detected by multer. By default, multer derives file type from file extension on user's device. However, it does not check actual file contents. As files can be renamed to arbitrary extensions, consider using a custom implementation (like checking the file's magic number) if your app requires a safer solution."
Title,
Title,"To understand how these can be used in conjunction with the aforementioned FileParsePipe, we'll use an altered snippet of the last presented example:"
Title,typescript
Title,@UploadedFile(
Title,new ParseFilePipe({
Title,validators: [
Title,"new MaxFileSizeValidator({ maxSize: 1000 }),"
Title,"new FileTypeValidator({ fileType: 'image/jpeg' }),"
Title,"],"
Title,"}),"
Title,)
Title,"file: Express.Multer.File,"
Title,
Title,"info Hint If the number of validators increase largely or their options are cluttering the file, you can define this array in a separate file and import it here as a named constant like fileValidators."
Title,
Title,"Finally, you can use the special ParseFilePipeBuilder class that lets you compose & construct your validators. By using it as shown below you can avoid manual instantiation of each validator and just pass their options directly:"
Title,typescript
Title,@UploadedFile(
Title,new ParseFilePipeBuilder()
Title,.addFileTypeValidator({
Title,"fileType: 'jpeg',"
Title,})
Title,.addMaxSizeValidator({
Title,maxSize: 1000
Title,})
Title,.build({
Title,errorHttpStatusCode: HttpStatus.UNPROCESSABLE_ENTITY
Title,"}),"
Title,)
Title,"file: Express.Multer.File,"
Title,
Title,"info Hint File presence is required by default, but you can make it optional by adding fileIsRequired: false parameter inside build function options (at the same level as errorHttpStatusCode)."
Title,
Title,Array of files
Title,"To upload an array of files (identified with a single field name), use the FilesInterceptor() decorator (note the plural Files in the decorator name). This decorator takes three arguments:"
Title,
Title,fieldName: as described above
Title,maxCount: optional number defining the maximum number of files to accept
Title,"options: optional MulterOptions object, as described above"
Title,
Title,"When using FilesInterceptor(), extract files from the request with the @UploadedFiles() decorator."
Title,typescript
Title,@@filename()
Title,@Post('upload')
Title,@UseInterceptors(FilesInterceptor('files'))
Title,uploadFile(@UploadedFiles() files: Array<Express.Multer.File>) {
Title,console.log(files);
Title,}
Title,@@switch
Title,@Post('upload')
Title,@UseInterceptors(FilesInterceptor('files'))
Title,@Bind(UploadedFiles())
Title,uploadFile(files) {
Title,console.log(files);
Title,}
Title,
Title,info Hint The FilesInterceptor() decorator is exported from the @nestjs/platform-express package. The @UploadedFiles() decorator is exported from @nestjs/common.
Title,
Title,Multiple files
Title,"To upload multiple files (all with different field name keys), use the FileFieldsInterceptor() decorator. This decorator takes two arguments:"
Title,
Title,"uploadedFields: an array of objects, where each object specifies a required name property with a string value specifying a field name, as described above, and an optional maxCount property, as described above"
Title,"options: optional MulterOptions object, as described above"
Title,
Title,"When using FileFieldsInterceptor(), extract files from the request with the @UploadedFiles() decorator."
Title,typescript
Title,@@filename()
Title,@Post('upload')
Title,@UseInterceptors(FileFieldsInterceptor([
Title,"{ name: 'avatar', maxCount: 1 },"
Title,"{ name: 'background', maxCount: 1 },"
Title,]))
Title,"uploadFile(@UploadedFiles() files: { avatar?: Express.Multer.File[], background?: Express.Multer.File[] }) {"
Title,console.log(files);
Title,}
Title,@@switch
Title,@Post('upload')
Title,@Bind(UploadedFiles())
Title,@UseInterceptors(FileFieldsInterceptor([
Title,"{ name: 'avatar', maxCount: 1 },"
Title,"{ name: 'background', maxCount: 1 },"
Title,]))
Title,uploadFile(files) {
Title,console.log(files);
Title,}
Title,Any files
Title,"To upload all fields with arbitrary field name keys, use the AnyFilesInterceptor() decorator. This decorator can accept an optional options object as described above."
Title,"When using AnyFilesInterceptor(), extract files from the request with the @UploadedFiles() decorator."
Title,typescript
Title,@@filename()
Title,@Post('upload')
Title,@UseInterceptors(AnyFilesInterceptor())
Title,uploadFile(@UploadedFiles() files: Array<Express.Multer.File>) {
Title,console.log(files);
Title,}
Title,@@switch
Title,@Post('upload')
Title,@Bind(UploadedFiles())
Title,@UseInterceptors(AnyFilesInterceptor())
Title,uploadFile(files) {
Title,console.log(files);
Title,}
Title,No files
Title,"To accept multipart/form-data but not allow any files to be uploaded, use the NoFilesInterceptor. This sets multipart data as attributes on the request body. Any files sent with the request will throw a BadRequestException."
Title,typescript
Title,@Post('upload')
Title,@UseInterceptors(NoFilesInterceptor())
Title,handleMultiPartData(@Body() body) {
Title,console.log(body)
Title,}
Title,Default options
Title,"You can specify multer options in the file interceptors as described above. To set default options, you can call the static register() method when you import the MulterModule, passing in supported options. You can use all options listed here."
Title,typescript
Title,MulterModule.register({
Title,"dest: './upload',"
Title,});
Title,
Title,info Hint The MulterModule class is exported from the @nestjs/platform-express package.
Title,
Title,Async configuration
Title,"When you need to set MulterModule options asynchronously instead of statically, use the registerAsync() method. As with most dynamic modules, Nest provides several techniques to deal with async configuration."
Title,One technique is to use a factory function:
Title,typescript
Title,MulterModule.registerAsync({
Title,useFactory: () => ({
Title,"dest: './upload',"
Title,"}),"
Title,});
Title,"Like other factory providers, our factory function can be async and can inject dependencies through inject."
Title,typescript
Title,MulterModule.registerAsync({
Title,"imports: [ConfigModule],"
Title,useFactory: async (configService: ConfigService) => ({
Title,"dest: configService.get<string>('MULTER_DEST'),"
Title,"}),"
Title,"inject: [ConfigService],"
Title,});
Title,"Alternatively, you can configure the MulterModule using a class instead of a factory, as shown below:"
Title,typescript
Title,MulterModule.registerAsync({
Title,"useClass: MulterConfigService,"
Title,});
Title,"The construction above instantiates MulterConfigService inside MulterModule, using it to create the required options object. Note that in this example, the MulterConfigService has to implement the MulterOptionsFactory interface, as shown below. The MulterModule will call the createMulterOptions() method on the instantiated object of the supplied class."
Title,typescript
Title,@Injectable()
Title,class MulterConfigService implements MulterOptionsFactory {
Title,createMulterOptions(): MulterModuleOptions {
Title,return {
Title,"dest: './upload',"
Title,};
Title,}
Title,}
Title,"If you want to reuse an existing options provider instead of creating a private copy inside the MulterModule, use the useExisting syntax."
Title,typescript
Title,MulterModule.registerAsync({
Title,"imports: [ConfigModule],"
Title,"useExisting: ConfigService,"
Title,});
Title,You can also pass so-called extraProviders to the registerAsync() method. These providers will be merged with the module providers.
Title,typescript
Title,MulterModule.registerAsync({
Title,"imports: [ConfigModule],"
Title,"useClass: ConfigService,"
Title,"extraProviders: [MyAdditionalProvider],"
Title,});
Title,This is useful when you want to provide additional dependencies to the factory function or the class constructor.
Title,Example
Title,A working example is available here.
Title,
Title,HTTP module
Title,"Axios is a richly featured HTTP client package that is widely used. Nest wraps Axios and exposes it via the built-in HttpModule. The HttpModule exports the HttpService class, which exposes Axios-based methods to perform HTTP requests. The library also transforms the resulting HTTP responses into Observables."
Title,
Title,"info Hint You can also use any general purpose Node.js HTTP client library directly, including got or undici."
Title,
Title,Installation
Title,"To begin using it, we first install required dependencies."
Title,bash
Title,$ npm i --save @nestjs/axios axios
Title,Getting started
Title,"Once the installation process is complete, to use the HttpService, first import HttpModule."
Title,typescript
Title,@Module({
Title,"imports: [HttpModule],"
Title,"providers: [CatsService],"
Title,})
Title,export class CatsModule {}
Title,"Next, inject HttpService using normal constructor injection."
Title,
Title,info Hint HttpModule and HttpService are imported from @nestjs/axios package.
Title,
Title,```typescript
Title,@@filename()
Title,@Injectable()
Title,export class CatsService {
Title,constructor(private readonly httpService: HttpService) {}
Title,findAll(): Observable> {
Title,return this.httpService.get('http://localhost:3000/cats');
Title,}
Title,}
Title,@@switch
Title,@Injectable()
Title,@Dependencies(HttpService)
Title,export class CatsService {
Title,constructor(httpService) {
Title,this.httpService = httpService;
Title,}
Title,findAll() {
Title,return this.httpService.get('http://localhost:3000/cats');
Title,}
Title,}
Title,```
Title,
Title,info Hint AxiosResponse is an interface exported from the axios package ($ npm i axios).
Title,
Title,All HttpService methods return an AxiosResponse wrapped in an Observable object.
Title,Configuration
Title,"Axios can be configured with a variety of options to customize the behavior of the HttpService. Read more about them here. To configure the underlying Axios instance, pass an optional options object to the register() method of HttpModule when importing it. This options object will be passed directly to the underlying Axios constructor."
Title,typescript
Title,@Module({
Title,imports: [
Title,HttpModule.register({
Title,"timeout: 5000,"
Title,"maxRedirects: 5,"
Title,"}),"
Title,"],"
Title,"providers: [CatsService],"
Title,})
Title,export class CatsModule {}
Title,Async configuration
Title,"When you need to pass module options asynchronously instead of statically, use the registerAsync() method. As with most dynamic modules, Nest provides several techniques to deal with async configuration."
Title,One technique is to use a factory function:
Title,typescript
Title,HttpModule.registerAsync({
Title,useFactory: () => ({
Title,"timeout: 5000,"
Title,"maxRedirects: 5,"
Title,"}),"
Title,});
Title,"Like other factory providers, our factory function can be async and can inject dependencies through inject."
Title,typescript
Title,HttpModule.registerAsync({
Title,"imports: [ConfigModule],"
Title,useFactory: async (configService: ConfigService) => ({
Title,"timeout: configService.get('HTTP_TIMEOUT'),"
Title,"maxRedirects: configService.get('HTTP_MAX_REDIRECTS'),"
Title,"}),"
Title,"inject: [ConfigService],"
Title,});
Title,"Alternatively, you can configure the HttpModule using a class instead of a factory, as shown below."
Title,typescript
Title,HttpModule.registerAsync({
Title,"useClass: HttpConfigService,"
Title,});
Title,"The construction above instantiates HttpConfigService inside HttpModule, using it to create an options object. Note that in this example, the HttpConfigService has to implement HttpModuleOptionsFactory interface as shown below. The HttpModule will call the createHttpOptions() method on the instantiated object of the supplied class."
Title,typescript
Title,@Injectable()
Title,class HttpConfigService implements HttpModuleOptionsFactory {
Title,createHttpOptions(): HttpModuleOptions {
Title,return {
Title,"timeout: 5000,"
Title,"maxRedirects: 5,"
Title,};
Title,}
Title,}
Title,"If you want to reuse an existing options provider instead of creating a private copy inside the HttpModule, use the useExisting syntax."
Title,typescript
Title,HttpModule.registerAsync({
Title,"imports: [ConfigModule],"
Title,"useExisting: HttpConfigService,"
Title,});
Title,You can also pass so-called extraProviders to the registerAsync() method. These providers will be merged with the module providers.
Title,typescript
Title,HttpModule.registerAsync({
Title,"imports: [ConfigModule],"
Title,"useClass: HttpConfigService,"
Title,"extraProviders: [MyAdditionalProvider],"
Title,});
Title,This is useful when you want to provide additional dependencies to the factory function or the class constructor.
Title,Using Axios directly
Title,"If you think that HttpModule.register's options are not enough for you, or if you just want to access the underlying Axios instance created by @nestjs/axios, you can access it via HttpService#axiosRef as follows:"
Title,```typescript
Title,@Injectable()
Title,export class CatsService {
Title,constructor(private readonly httpService: HttpService) {}
Title,findAll(): Promise> {
Title,return this.httpService.axiosRef.get('http://localhost:3000/cats');
Title,//                      ^ AxiosInstance interface
Title,}
Title,}
Title,```
Title,Full example
Title,"Since the return value of the HttpService methods is an Observable, we can use rxjs - firstValueFrom or lastValueFrom to retrieve the data of the request in the form of a promise."
Title,```typescript
Title,"import { catchError, firstValueFrom } from 'rxjs';"
Title,@Injectable()
Title,export class CatsService {
Title,private readonly logger = new Logger(CatsService.name);
Title,constructor(private readonly httpService: HttpService) {}
Title,async findAll(): Promise {
Title,const { data } = await firstValueFrom(
Title,this.httpService.get('http://localhost:3000/cats').pipe(
Title,catchError((error: AxiosError) => {
Title,this.logger.error(error.response.data);
Title,throw 'An error happened!';
Title,"}),"
Title,"),"
Title,);
Title,return data;
Title,}
Title,}
Title,```
Title,
Title,info Hint Visit RxJS's documentation on firstValueFrom and lastValueFrom for differences between them.
Title,
Title,
Title,Logger
Title,"Nest comes with a built-in text-based logger which is used during application bootstrapping and several other circumstances such as displaying caught exceptions (i.e., system logging). This functionality is provided via the Logger class in the @nestjs/common package. You can fully control the behavior of the logging system, including any of the following:"
Title,
Title,disable logging entirely
Title,"specify the log level of detail (e.g., display errors, warnings, debug information, etc.)"
Title,"override timestamp in the default logger (e.g., use ISO8601 standard as date format)"
Title,completely override the default logger
Title,customize the default logger by extending it
Title,make use of dependency injection to simplify composing and testing your application
Title,
Title,"You can also make use of the built-in logger, or create your own custom implementation, to log your own application-level events and messages."
Title,"For more advanced logging functionality, you can make use of any Node.js logging package, such as Winston, to implement a completely custom, production grade logging system."
Title,Basic customization
Title,"To disable logging, set the logger property to false in the (optional) Nest application options object passed as the second argument to the NestFactory.create() method."
Title,typescript
Title,"const app = await NestFactory.create(AppModule, {"
Title,"logger: false,"
Title,});
Title,await app.listen(process.env.PORT ?? 3000);
Title,"To enable specific logging levels, set the logger property to an array of strings specifying the log levels to display, as follows:"
Title,typescript
Title,"const app = await NestFactory.create(AppModule, {"
Title,"logger: ['error', 'warn'],"
Title,});
Title,await app.listen(process.env.PORT ?? 3000);
Title,"Values in the array can be any combination of 'log', 'fatal', 'error', 'warn', 'debug', and 'verbose'."
Title,
Title,"info Hint To disable color in the default logger's messages, set the NO_COLOR environment variable to some non-empty string."
Title,
Title,Custom implementation
Title,"You can provide a custom logger implementation to be used by Nest for system logging by setting the value of the logger property to an object that fulfills the LoggerService interface. For example, you can tell Nest to use the built-in global JavaScript console object (which implements the LoggerService interface), as follows:"
Title,typescript
Title,"const app = await NestFactory.create(AppModule, {"
Title,"logger: console,"
Title,});
Title,await app.listen(process.env.PORT ?? 3000);
Title,Implementing your own custom logger is straightforward. Simply implement each of the methods of the LoggerService interface as shown below.
Title,```typescript
Title,"import { LoggerService, Injectable } from '@nestjs/common';"
Title,@Injectable()
Title,export class MyLogger implements LoggerService {
Title,/*
Title,* Write a 'log' level log.
Title,/
Title,"log(message: any, ...optionalParams: any[]) {}"
Title,/*
Title,* Write a 'fatal' level log.
Title,/
Title,"fatal(message: any, ...optionalParams: any[]) {}"
Title,/*
Title,* Write an 'error' level log.
Title,/
Title,"error(message: any, ...optionalParams: any[]) {}"
Title,/*
Title,* Write a 'warn' level log.
Title,/
Title,"warn(message: any, ...optionalParams: any[]) {}"
Title,/*
Title,* Write a 'debug' level log.
Title,/
Title,"debug?(message: any, ...optionalParams: any[]) {}"
Title,/*
Title,* Write a 'verbose' level log.
Title,/
Title,"verbose?(message: any, ...optionalParams: any[]) {}"
Title,}
Title,```
Title,You can then supply an instance of MyLogger via the logger property of the Nest application options object.
Title,typescript
Title,"const app = await NestFactory.create(AppModule, {"
Title,"logger: new MyLogger(),"
Title,});
Title,await app.listen(process.env.PORT ?? 3000);
Title,"This technique, while simple, doesn't utilize dependency injection for the MyLogger class. This can pose some challenges, particularly for testing, and limit the reusability of MyLogger. For a better solution, see the Dependency Injection section below."
Title,Extend built-in logger
Title,"Rather than writing a logger from scratch, you may be able to meet your needs by extending the built-in ConsoleLogger class and overriding selected behavior of the default implementation."
Title,```typescript
Title,import { ConsoleLogger } from '@nestjs/common';
Title,export class MyLogger extends ConsoleLogger {
Title,"error(message: any, stack?: string, context?: string) {"
Title,// add your tailored logic here
Title,super.error(...arguments);
Title,}
Title,}
Title,```
Title,You can use such an extended logger in your feature modules as described in the Using the logger for application logging section below.
Title,"You can tell Nest to use your extended logger for system logging by passing an instance of it via the logger property of the application options object (as shown in the Custom implementation section above), or by using the technique shown in the Dependency Injection section below. If you do so, you should take care to call super, as shown in the sample code above, to delegate the specific log method call to the parent (built-in) class so that Nest can rely on the built-in features it expects."
Title,
Title,Dependency injection
Title,"For more advanced logging functionality, you'll want to take advantage of dependency injection. For example, you may want to inject a ConfigService into your logger to customize it, and in turn inject your custom logger into other controllers and/or providers. To enable dependency injection for your custom logger, create a class that implements LoggerService and register that class as a provider in some module. For example, you can"
Title,
Title,"Define a MyLogger class that either extends the built-in ConsoleLogger or completely overrides it, as shown in previous sections. Be sure to implement the LoggerService interface."
Title,"Create a LoggerModule as shown below, and provide MyLogger from that module."
Title,
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { MyLogger } from './my-logger.service';
Title,@Module({
Title,"providers: [MyLogger],"
Title,"exports: [MyLogger],"
Title,})
Title,export class LoggerModule {}
Title,```
Title,"With this construct, you are now providing your custom logger for use by any other module. Because your MyLogger class is part of a module, it can use dependency injection (for example, to inject a ConfigService). There's one more technique needed to provide this custom logger for use by Nest for system logging (e.g., for bootstrapping and error handling)."
Title,"Because application instantiation (NestFactory.create()) happens outside the context of any module, it doesn't participate in the normal Dependency Injection phase of initialization. So we must ensure that at least one application module imports the LoggerModule to trigger Nest to instantiate a singleton instance of our MyLogger class."
Title,We can then instruct Nest to use the same singleton instance of MyLogger with the following construction:
Title,typescript
Title,"const app = await NestFactory.create(AppModule, {"
Title,"bufferLogs: true,"
Title,});
Title,app.useLogger(app.get(MyLogger));
Title,await app.listen(process.env.PORT ?? 3000);
Title,
Title,"info Note In the example above, we set the bufferLogs to true to make sure all logs will be buffered until a custom logger is attached (MyLogger in this case) and the application initialisation process either completes or fails. If the initialisation process fails, Nest will fallback to the original ConsoleLogger to print out any reported error messages. Also, you can set the autoFlushLogs to false (default true) to manually flush logs (using the Logger.flush() method)."
Title,
Title,"Here we use the get() method on the NestApplication instance to retrieve the singleton instance of the MyLogger object. This technique is essentially a way to ""inject"" an instance of a logger for use by Nest. The app.get() call retrieves the singleton instance of MyLogger, and depends on that instance being first injected in another module, as described above."
Title,"You can also inject this MyLogger provider in your feature classes, thus ensuring consistent logging behavior across both Nest system logging and application logging. See Using the logger for application logging and Injecting a custom logger below for more information."
Title,Using the logger for application logging
Title,We can combine several of the techniques above to provide consistent behavior and formatting across both Nest system logging and our own application event/message logging.
Title,"A good practice is to instantiate Logger class from @nestjs/common in each of our services. We can supply our service name as the context argument in the Logger constructor, like so:"
Title,```typescript
Title,"import { Logger, Injectable } from '@nestjs/common';"
Title,@Injectable()
Title,class MyService {
Title,private readonly logger = new Logger(MyService.name);
Title,doSomething() {
Title,this.logger.log('Doing something...');
Title,}
Title,}
Title,```
Title,"In the default logger implementation, context is printed in the square brackets, like NestFactory in the example below:"
Title,bash
Title,"[Nest] 19096   - 12/08/2019, 7:12:59 AM   [NestFactory] Starting Nest application..."
Title,"If we supply a custom logger via app.useLogger(), it will actually be used by Nest internally. That means that our code remains implementation agnostic, while we can easily substitute the default logger for our custom one by calling app.useLogger()."
Title,"That way if we follow the steps from the previous section and call app.useLogger(app.get(MyLogger)), the following calls to this.logger.log() from MyService would result in calls to method log from MyLogger instance."
Title,"This should be suitable for most cases. But if you need more customization (like adding and calling custom methods), move to the next section."
Title,Logs with timestamps
Title,"To enable timestamp logging for every logged message, you can use the optional timestamp: true setting when creating the logger instance."
Title,```typescript
Title,"import { Logger, Injectable } from '@nestjs/common';"
Title,@Injectable()
Title,class MyService {
Title,"private readonly logger = new Logger(MyService.name, { timestamp: true });"
Title,doSomething() {
Title,this.logger.log('Doing something with timestamp here ->');
Title,}
Title,}
Title,```
Title,This will produce output in the following format:
Title,bash
Title,"[Nest] 19096   - 04/19/2024, 7:12:59 AM   [MyService] Doing something with timestamp here +5ms"
Title,"Note the +5ms at the end of the line. For each log statement, the time difference from the previous message is calculated and displayed at the end of the line."
Title,Injecting a custom logger
Title,"To start, extend the built-in logger with code like the following. We supply the scope option as configuration metadata for the ConsoleLogger class, specifying a transient scope, to ensure that we'll have a unique instance of the MyLogger in each feature module. In this example, we do not extend the individual ConsoleLogger methods (like log(), warn(), etc.), though you may choose to do so."
Title,```typescript
Title,"import { Injectable, Scope, ConsoleLogger } from '@nestjs/common';"
Title,@Injectable({ scope: Scope.TRANSIENT })
Title,export class MyLogger extends ConsoleLogger {
Title,customLog() {
Title,this.log('Please feed the cat!');
Title,}
Title,}
Title,```
Title,"Next, create a LoggerModule with a construction like this:"
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { MyLogger } from './my-logger.service';
Title,@Module({
Title,"providers: [MyLogger],"
Title,"exports: [MyLogger],"
Title,})
Title,export class LoggerModule {}
Title,```
Title,"Next, import the LoggerModule into your feature module. Since we extended default Logger we have the convenience of using setContext method. So we can start using the context-aware custom logger, like this:"
Title,```typescript
Title,import { Injectable } from '@nestjs/common';
Title,import { MyLogger } from './my-logger.service';
Title,@Injectable()
Title,export class CatsService {
Title,private readonly cats: Cat[] = [];
Title,constructor(private myLogger: MyLogger) {
Title,"// Due to transient scope, CatsService has its own unique instance of MyLogger,"
Title,// so setting context here will not affect other instances in other services
Title,this.myLogger.setContext('CatsService');
Title,}
Title,findAll(): Cat[] {
Title,// You can call all the default methods
Title,this.myLogger.warn('About to return cats!');
Title,// And your custom methods
Title,this.myLogger.customLog();
Title,return this.cats;
Title,}
Title,}
Title,```
Title,"Finally, instruct Nest to use an instance of the custom logger in your main.ts file as shown below. Of course in this example, we haven't actually customized the logger behavior (by extending the Logger methods like log(), warn(), etc.), so this step isn't actually needed. But it would be needed if you added custom logic to those methods and wanted Nest to use the same implementation."
Title,typescript
Title,"const app = await NestFactory.create(AppModule, {"
Title,"bufferLogs: true,"
Title,});
Title,app.useLogger(new MyLogger());
Title,await app.listen(process.env.PORT ?? 3000);
Title,
Title,"info Hint Alternatively, instead of setting bufferLogs to true, you could temporarily disable the logger with logger: false instruction. Be mindful that if you supply logger: false to NestFactory.create, nothing will be logged until you call useLogger, so you may miss some important initialization errors. If you don't mind that some of your initial messages will be logged with the default logger, you can just omit the logger: false option."
Title,
Title,Use external logger
Title,"Production applications often have specific logging requirements, including advanced filtering, formatting and centralized logging. Nest's built-in logger is used for monitoring Nest system behavior, and can also be useful for basic formatted text logging in your feature modules while in development, but production applications often take advantage of dedicated logging modules like Winston. As with any standard Node.js application, you can take full advantage of such modules in Nest."
Title,
Title,Mongo
Title,"Nest supports two methods for integrating with the MongoDB database. You can either use the built-in TypeORM module described here, which has a connector for MongoDB, or use Mongoose, the most popular MongoDB object modeling tool. In this chapter we'll describe the latter, using the dedicated @nestjs/mongoose package."
Title,Start by installing the required dependencies:
Title,bash
Title,$ npm i @nestjs/mongoose mongoose
Title,"Once the installation process is complete, we can import the MongooseModule into the root AppModule."
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { MongooseModule } from '@nestjs/mongoose';
Title,@Module({
Title,"imports: [MongooseModule.forRoot('mongodb://localhost/nest')],"
Title,})
Title,export class AppModule {}
Title,```
Title,"The forRoot() method accepts the same configuration object as mongoose.connect() from the Mongoose package, as described here."
Title,Model injection
Title,"With Mongoose, everything is derived from a Schema. Each schema maps to a MongoDB collection and defines the shape of the documents within that collection. Schemas are used to define Models. Models are responsible for creating and reading documents from the underlying MongoDB database."
Title,"Schemas can be created with NestJS decorators, or with Mongoose itself manually. Using decorators to create schemas greatly reduces boilerplate and improves overall code readability."
Title,Let's define the CatSchema:
Title,```typescript
Title,@@filename(schemas/cat.schema)
Title,"import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';"
Title,import { HydratedDocument } from 'mongoose';
Title,export type CatDocument = HydratedDocument;
Title,@Schema()
Title,export class Cat {
Title,@Prop()
Title,name: string;
Title,@Prop()
Title,age: number;
Title,@Prop()
Title,breed: string;
Title,}
Title,export const CatSchema = SchemaFactory.createForClass(Cat);
Title,```
Title,
Title,info Hint Note you can also generate a raw schema definition using the DefinitionsFactory class (from the nestjs/mongoose). This allows you to manually modify the schema definition generated based on the metadata you provided. This is useful for certain edge-cases where it may be hard to represent everything with decorators.
Title,
Title,"The @Schema() decorator marks a class as a schema definition. It maps our Cat class to a MongoDB collection of the same name, but with an additional “s” at the end - so the final mongo collection name will be cats. This decorator accepts a single optional argument which is a schema options object. Think of it as the object you would normally pass as a second argument of the mongoose.Schema class' constructor (e.g., new mongoose.Schema(_, options))). To learn more about available schema options, see this chapter."
Title,"The @Prop() decorator defines a property in the document. For example, in the schema definition above, we defined three properties: name, age, and breed. The schema types for these properties are automatically inferred thanks to TypeScript metadata (and reflection) capabilities. However, in more complex scenarios in which types cannot be implicitly reflected (for example, arrays or nested object structures), types must be indicated explicitly, as follows:"
Title,typescript
Title,@Prop([String])
Title,tags: string[];
Title,"Alternatively, the @Prop() decorator accepts an options object argument (read more about the available options). With this, you can indicate whether a property is required or not, specify a default value, or mark it as immutable. For example:"
Title,typescript
Title,@Prop({ required: true })
Title,name: string;
Title,"In case you want to specify relation to another model, later for populating, you can use @Prop() decorator as well. For example, if Cat has Owner which is stored in a different collection called owners, the property should have type and ref. For example:"
Title,```typescript
Title,import * as mongoose from 'mongoose';
Title,import { Owner } from '../owners/schemas/owner.schema';
Title,// inside the class definition
Title,"@Prop({ type: mongoose.Schema.Types.ObjectId, ref: 'Owner' })"
Title,owner: Owner;
Title,```
Title,"In case there are multiple owners, your property configuration should look as follows:"
Title,typescript
Title,"@Prop({ type: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Owner' }] })"
Title,owners: Owner[];
Title,"Finally, the raw schema definition can also be passed to the decorator. This is useful when, for example, a property represents a nested object which is not defined as a class. For this, use the raw() function from the @nestjs/mongoose package, as follows:"
Title,typescript
Title,@Prop(raw({
Title,"firstName: { type: String },"
Title,lastName: { type: String }
Title,}))
Title,"details: Record<string, any>;"
Title,"Alternatively, if you prefer not using decorators, you can define a schema manually. For example:"
Title,typescript
Title,export const CatSchema = new mongoose.Schema({
Title,"name: String,"
Title,"age: Number,"
Title,"breed: String,"
Title,});
Title,"The cat.schema file resides in a folder in the cats directory, where we also define the CatsModule. While you can store schema files wherever you prefer, we recommend storing them near their related domain objects, in the appropriate module directory."
Title,Let's look at the CatsModule:
Title,```typescript
Title,@@filename(cats.module)
Title,import { Module } from '@nestjs/common';
Title,import { MongooseModule } from '@nestjs/mongoose';
Title,import { CatsController } from './cats.controller';
Title,import { CatsService } from './cats.service';
Title,"import { Cat, CatSchema } from './schemas/cat.schema';"
Title,@Module({
Title,"imports: [MongooseModule.forFeature([{ name: Cat.name, schema: CatSchema }])],"
Title,"controllers: [CatsController],"
Title,"providers: [CatsService],"
Title,})
Title,export class CatsModule {}
Title,```
Title,"The MongooseModule provides the forFeature() method to configure the module, including defining which models should be registered in the current scope. If you also want to use the models in another module, add MongooseModule to the exports section of CatsModule and import CatsModule in the other module."
Title,"Once you've registered the schema, you can inject a Cat model into the CatsService using the @InjectModel() decorator:"
Title,```typescript
Title,@@filename(cats.service)
Title,import { Model } from 'mongoose';
Title,import { Injectable } from '@nestjs/common';
Title,import { InjectModel } from '@nestjs/mongoose';
Title,import { Cat } from './schemas/cat.schema';
Title,import { CreateCatDto } from './dto/create-cat.dto';
Title,@Injectable()
Title,export class CatsService {
Title,constructor(@InjectModel(Cat.name) private catModel: Model) {}
Title,async create(createCatDto: CreateCatDto): Promise {
Title,const createdCat = new this.catModel(createCatDto);
Title,return createdCat.save();
Title,}
Title,async findAll(): Promise {
Title,return this.catModel.find().exec();
Title,}
Title,}
Title,@@switch
Title,import { Model } from 'mongoose';
Title,"import { Injectable, Dependencies } from '@nestjs/common';"
Title,import { getModelToken } from '@nestjs/mongoose';
Title,import { Cat } from './schemas/cat.schema';
Title,@Injectable()
Title,@Dependencies(getModelToken(Cat.name))
Title,export class CatsService {
Title,constructor(catModel) {
Title,this.catModel = catModel;
Title,}
Title,async create(createCatDto) {
Title,const createdCat = new this.catModel(createCatDto);
Title,return createdCat.save();
Title,}
Title,async findAll() {
Title,return this.catModel.find().exec();
Title,}
Title,}
Title,```
Title,Connection
Title,"At times you may need to access the native Mongoose Connection object. For example, you may want to make native API calls on the connection object. You can inject the Mongoose Connection by using the @InjectConnection() decorator as follows:"
Title,```typescript
Title,import { Injectable } from '@nestjs/common';
Title,import { InjectConnection } from '@nestjs/mongoose';
Title,import { Connection } from 'mongoose';
Title,@Injectable()
Title,export class CatsService {
Title,constructor(@InjectConnection() private connection: Connection) {}
Title,}
Title,```
Title,Sessions
Title,"To start a session with Mongoose, it's recommended to inject the database connection using @InjectConnection rather than calling mongoose.startSession() directly. This approach allows better integration with the NestJS dependency injection system, ensuring proper connection management."
Title,Here's an example of how to start a session:
Title,```typescript
Title,import { InjectConnection } from '@nestjs/mongoose';
Title,import { Connection } from 'mongoose';
Title,@Injectable()
Title,export class CatsService {
Title,constructor(@InjectConnection() private readonly connection: Connection) {}
Title,async startTransaction() {
Title,const session = await this.connection.startSession();
Title,session.startTransaction();
Title,// Your transaction logic here
Title,}
Title,}
Title,```
Title,"In this example, @InjectConnection() is used to inject the Mongoose connection into the service. Once the connection is injected, you can use connection.startSession() to begin a new session. This session can be used to manage database transactions, ensuring atomic operations across multiple queries. After starting the session, remember to commit or abort the transaction based on your logic."
Title,Multiple databases
Title,"Some projects require multiple database connections. This can also be achieved with this module. To work with multiple connections, first create the connections. In this case, connection naming becomes mandatory."
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { MongooseModule } from '@nestjs/mongoose';
Title,@Module({
Title,imports: [
Title,"MongooseModule.forRoot('mongodb://localhost/test', {"
Title,"connectionName: 'cats',"
Title,"}),"
Title,"MongooseModule.forRoot('mongodb://localhost/users', {"
Title,"connectionName: 'users',"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,
Title,"warning Notice Please note that you shouldn't have multiple connections without a name, or with the same name, otherwise they will get overridden."
Title,
Title,"With this setup, you have to tell the MongooseModule.forFeature() function which connection should be used."
Title,typescript
Title,@Module({
Title,imports: [
Title,"MongooseModule.forFeature([{ name: Cat.name, schema: CatSchema }], 'cats'),"
Title,"],"
Title,})
Title,export class CatsModule {}
Title,You can also inject the Connection for a given connection:
Title,```typescript
Title,import { Injectable } from '@nestjs/common';
Title,import { InjectConnection } from '@nestjs/mongoose';
Title,import { Connection } from 'mongoose';
Title,@Injectable()
Title,export class CatsService {
Title,constructor(@InjectConnection('cats') private connection: Connection) {}
Title,}
Title,```
Title,"To inject a given Connection to a custom provider (for example, factory provider), use the getConnectionToken() function passing the name of the connection as an argument."
Title,typescript
Title,{
Title,"provide: CatsService,"
Title,useFactory: (catsConnection: Connection) => {
Title,return new CatsService(catsConnection);
Title,"},"
Title,"inject: [getConnectionToken('cats')],"
Title,}
Title,"If you are just looking to inject the model from a named database, you can use the connection name as a second parameter to the @InjectModel() decorator."
Title,typescript
Title,@@filename(cats.service)
Title,@Injectable()
Title,export class CatsService {
Title,"constructor(@InjectModel(Cat.name, 'cats') private catModel: Model<Cat>) {}"
Title,}
Title,@@switch
Title,@Injectable()
Title,"@Dependencies(getModelToken(Cat.name, 'cats'))"
Title,export class CatsService {
Title,constructor(catModel) {
Title,this.catModel = catModel;
Title,}
Title,}
Title,Hooks (middleware)
Title,"Middleware (also called pre and post hooks) are functions which are passed control during execution of asynchronous functions. Middleware is specified on the schema level and is useful for writing plugins (source). Calling pre() or post() after compiling a model does not work in Mongoose. To register a hook before model registration, use the forFeatureAsync() method of the MongooseModule along with a factory provider (i.e., useFactory). With this technique, you can access a schema object, then use the pre() or post() method to register a hook on that schema. See example below:"
Title,typescript
Title,@Module({
Title,imports: [
Title,MongooseModule.forFeatureAsync([
Title,{
Title,"name: Cat.name,"
Title,useFactory: () => {
Title,const schema = CatsSchema;
Title,"schema.pre('save', function () {"
Title,console.log('Hello from pre save');
Title,});
Title,return schema;
Title,"},"
Title,"},"
Title,"]),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,"Like other factory providers, our factory function can be async and can inject dependencies through inject."
Title,typescript
Title,@Module({
Title,imports: [
Title,MongooseModule.forFeatureAsync([
Title,{
Title,"name: Cat.name,"
Title,"imports: [ConfigModule],"
Title,useFactory: (configService: ConfigService) => {
Title,const schema = CatsSchema;
Title,"schema.pre('save', function() {"
Title,console.log(
Title,"`${configService.get('APP_NAME')}: Hello from pre save`,"
Title,"),"
Title,});
Title,return schema;
Title,"},"
Title,"inject: [ConfigService],"
Title,"},"
Title,"]),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,Plugins
Title,"To register a plugin for a given schema, use the forFeatureAsync() method."
Title,typescript
Title,@Module({
Title,imports: [
Title,MongooseModule.forFeatureAsync([
Title,{
Title,"name: Cat.name,"
Title,useFactory: () => {
Title,const schema = CatsSchema;
Title,schema.plugin(require('mongoose-autopopulate'));
Title,return schema;
Title,"},"
Title,"},"
Title,"]),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,"To register a plugin for all schemas at once, call the .plugin() method of the Connection object. You should access the connection before models are created; to do this, use the connectionFactory:"
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { MongooseModule } from '@nestjs/mongoose';
Title,@Module({
Title,imports: [
Title,"MongooseModule.forRoot('mongodb://localhost/test', {"
Title,connectionFactory: (connection) => {
Title,connection.plugin(require('mongoose-autopopulate'));
Title,return connection;
Title,}
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,Discriminators
Title,Discriminators are a schema inheritance mechanism. They enable you to have multiple models with overlapping schemas on top of the same underlying MongoDB collection.
Title,Suppose you wanted to track different types of events in a single collection. Every event will have a timestamp.
Title,```typescript
Title,@@filename(event.schema)
Title,@Schema({ discriminatorKey: 'kind' })
Title,export class Event {
Title,@Prop({
Title,"type: String,"
Title,"required: true,"
Title,"enum: [ClickedLinkEvent.name, SignUpEvent.name],"
Title,})
Title,kind: string;
Title,"@Prop({ type: Date, required: true })"
Title,time: Date;
Title,}
Title,export const EventSchema = SchemaFactory.createForClass(Event);
Title,```
Title,
Title,"info Hint The way mongoose tells the difference between the different discriminator models is by the ""discriminator key"", which is __t by default. Mongoose adds a String path called __t to your schemas that it uses to track which discriminator this document is an instance of."
Title,You may also use the discriminatorKey option to define the path for discrimination.
Title,
Title,SignedUpEvent and ClickedLinkEvent instances will be stored in the same collection as generic events.
Title,"Now, let's define the ClickedLinkEvent class, as follows:"
Title,```typescript
Title,@@filename(click-link-event.schema)
Title,@Schema()
Title,export class ClickedLinkEvent {
Title,kind: string;
Title,time: Date;
Title,"@Prop({ type: String, required: true })"
Title,url: string;
Title,}
Title,export const ClickedLinkEventSchema = SchemaFactory.createForClass(ClickedLinkEvent);
Title,```
Title,And SignUpEvent class:
Title,```typescript
Title,@@filename(sign-up-event.schema)
Title,@Schema()
Title,export class SignUpEvent {
Title,kind: string;
Title,time: Date;
Title,"@Prop({ type: String, required: true })"
Title,user: string;
Title,}
Title,export const SignUpEventSchema = SchemaFactory.createForClass(SignUpEvent);
Title,```
Title,"With this in place, use the discriminators option to register a discriminator for a given schema. It works on both MongooseModule.forFeature and MongooseModule.forFeatureAsync:"
Title,```typescript
Title,@@filename(event.module)
Title,import { Module } from '@nestjs/common';
Title,import { MongooseModule } from '@nestjs/mongoose';
Title,@Module({
Title,imports: [
Title,MongooseModule.forFeature([
Title,{
Title,"name: Event.name,"
Title,"schema: EventSchema,"
Title,discriminators: [
Title,"{ name: ClickedLinkEvent.name, schema: ClickedLinkEventSchema },"
Title,"{ name: SignUpEvent.name, schema: SignUpEventSchema },"
Title,"],"
Title,"},"
Title,"]),"
Title,]
Title,})
Title,export class EventsModule {}
Title,```
Title,Testing
Title,"When unit testing an application, we usually want to avoid any database connection, making our test suites simpler to set up and faster to execute. But our classes might depend on models that are pulled from the connection instance. How do we resolve these classes? The solution is to create mock models."
Title,"To make this easier, the @nestjs/mongoose package exposes a getModelToken() function that returns a prepared injection token based on a token name. Using this token, you can easily provide a mock implementation using any of the standard custom provider techniques, including useClass, useValue, and useFactory. For example:"
Title,typescript
Title,@Module({
Title,providers: [
Title,"CatsService,"
Title,{
Title,"provide: getModelToken(Cat.name),"
Title,"useValue: catModel,"
Title,"},"
Title,"],"
Title,})
Title,export class CatsModule {}
Title,"In this example, a hardcoded catModel (object instance) will be provided whenever any consumer injects a Model<Cat> using an @InjectModel() decorator."
Title,
Title,Async configuration
Title,"When you need to pass module options asynchronously instead of statically, use the forRootAsync() method. As with most dynamic modules, Nest provides several techniques to deal with async configuration."
Title,One technique is to use a factory function:
Title,typescript
Title,MongooseModule.forRootAsync({
Title,useFactory: () => ({
Title,"uri: 'mongodb://localhost/nest',"
Title,"}),"
Title,});
Title,"Like other factory providers, our factory function can be async and can inject dependencies through inject."
Title,typescript
Title,MongooseModule.forRootAsync({
Title,"imports: [ConfigModule],"
Title,useFactory: async (configService: ConfigService) => ({
Title,"uri: configService.get<string>('MONGODB_URI'),"
Title,"}),"
Title,"inject: [ConfigService],"
Title,});
Title,"Alternatively, you can configure the MongooseModule using a class instead of a factory, as shown below:"
Title,typescript
Title,MongooseModule.forRootAsync({
Title,"useClass: MongooseConfigService,"
Title,});
Title,"The construction above instantiates MongooseConfigService inside MongooseModule, using it to create the required options object. Note that in this example, the MongooseConfigService has to implement the MongooseOptionsFactory interface, as shown below. The MongooseModule will call the createMongooseOptions() method on the instantiated object of the supplied class."
Title,typescript
Title,@Injectable()
Title,export class MongooseConfigService implements MongooseOptionsFactory {
Title,createMongooseOptions(): MongooseModuleOptions {
Title,return {
Title,"uri: 'mongodb://localhost/nest',"
Title,};
Title,}
Title,}
Title,"If you want to reuse an existing options provider instead of creating a private copy inside the MongooseModule, use the useExisting syntax."
Title,typescript
Title,MongooseModule.forRootAsync({
Title,"imports: [ConfigModule],"
Title,"useExisting: ConfigService,"
Title,});
Title,Connection events
Title,"You can listen to Mongoose connection events by using the onConnectionCreate configuration option. This allows you to implement custom logic whenever a connection is established. For instance, you can register event listeners for the connected, open, disconnected, reconnected, and disconnecting events, as demonstrated below:"
Title,```typescript
Title,"MongooseModule.forRoot('mongodb://localhost/test', {"
Title,onConnectionCreate: (connection: Connection) => {
Title,"connection.on('connected', () => console.log('connected'));"
Title,"connection.on('open', () => console.log('open'));"
Title,"connection.on('disconnected', () => console.log('disconnected'));"
Title,"connection.on('reconnected', () => console.log('reconnected'));"
Title,"connection.on('disconnecting', () => console.log('disconnecting'));"
Title,return connection;
Title,
Title,"},"
Title,"}),"
Title,```
Title,"In this code snippet, we are establishing a connection to a MongoDB database at mongodb://localhost/test. The onConnectionCreate option enables you to set up specific event listeners for monitoring the connection's status:"
Title,
Title,connected: Triggered when the connection is successfully established.
Title,open: Fires when the connection is fully opened and ready for operations.
Title,disconnected: Called when the connection is lost.
Title,reconnected: Invoked when the connection is re-established after being disconnected.
Title,disconnecting: Occurs when the connection is in the process of closing.
Title,
Title,You can also incorporate the onConnectionCreate property into async configurations created with MongooseModule.forRootAsync():
Title,typescript
Title,MongooseModule.forRootAsync({
Title,useFactory: () => ({
Title,"uri: 'mongodb://localhost/test',"
Title,onConnectionCreate: (connection: Connection) => {
Title,// Register event listeners here
Title,return connection;
Title,"},"
Title,"}),"
Title,"}),"
Title,"This provides a flexible way to manage connection events, enabling you to handle changes in connection status effectively."
Title,Subdocuments
Title,"To nest subdocuments within a parent document, you can define your schemas as follows:"
Title,```typescript
Title,@@filename(name.schema)
Title,@Schema()
Title,export class Name {
Title,@Prop()
Title,firstName: string;
Title,@Prop()
Title,lastName: string;
Title,}
Title,export const NameSchema = SchemaFactory.createForClass(Name);
Title,```
Title,And then reference the subdocument in the parent schema:
Title,```typescript
Title,@@filename(person.schema)
Title,@Schema()
Title,export class Person {
Title,@Prop(NameSchema)
Title,name: Name;
Title,}
Title,export const PersonSchema = SchemaFactory.createForClass(Person);
Title,export type PersonDocumentOverride = {
Title,name: Types.Subdocument;
Title,};
Title,export type PersonDocument = HydratedDocument;
Title,```
Title,"If you want to include multiple subdocuments, you can use an array of subdocuments. It's important to override the type of the property accordingly:"
Title,```typescript
Title,@@filename(name.schema)
Title,@Schema()
Title,export class Person {
Title,@Prop([NameSchema])
Title,name: Name[];
Title,}
Title,export const PersonSchema = SchemaFactory.createForClass(Person);
Title,export type PersonDocumentOverride = {
Title,name: Types.DocumentArray;
Title,};
Title,export type PersonDocument = HydratedDocument;
Title,```
Title,Virtuals
Title,"In Mongoose, a virtual is a property that exists on a document but is not persisted to MongoDB. It is not stored in the database but is computed dynamically whenever it's accessed. Virtuals are typically used for derived or computed values, like combining fields (e.g., creating a fullName property by concatenating firstName and lastName), or for creating properties that rely on existing data in the document."
Title,```ts
Title,class Person {
Title,@Prop()
Title,firstName: string;
Title,@Prop()
Title,lastName: string;
Title,@Virtual({
Title,get: function (this: Person) {
Title,return ${this.firstName} ${this.lastName};
Title,"},"
Title,})
Title,fullName: string;
Title,}
Title,```
Title,
Title,info Hint The @Virtual() decorator is imported from the @nestjs/mongoose package.
Title,
Title,"In this example, the fullName virtual is derived from firstName and lastName. Even though it behaves like a normal property when accessed, it’s never saved to the MongoDB document.:"
Title,Example
Title,A working example is available here.
Title,
Title,Model-View-Controller
Title,"Nest, by default, makes use of the Express library under the hood. Hence, every technique for using the MVC (Model-View-Controller) pattern in Express applies to Nest as well."
Title,"First, let's scaffold a simple Nest application using the CLI tool:"
Title,bash
Title,$ npm i -g @nestjs/cli
Title,$ nest new project
Title,"In order to create an MVC app, we also need a template engine to render our HTML views:"
Title,bash
Title,$ npm install --save hbs
Title,"We've used the hbs (Handlebars) engine, though you can use whatever fits your requirements. Once the installation process is complete, we need to configure the express instance using the following code:"
Title,```typescript
Title,@@filename(main)
Title,import { NestFactory } from '@nestjs/core';
Title,import { NestExpressApplication } from '@nestjs/platform-express';
Title,import { join } from 'path';
Title,import { AppModule } from './app.module';
Title,async function bootstrap() {
Title,const app = await NestFactory.create(
Title,"AppModule,"
Title,);
Title,"app.useStaticAssets(join(__dirname, '..', 'public'));"
Title,"app.setBaseViewsDir(join(__dirname, '..', 'views'));"
Title,app.setViewEngine('hbs');
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,bootstrap();
Title,@@switch
Title,import { NestFactory } from '@nestjs/core';
Title,import { join } from 'path';
Title,import { AppModule } from './app.module';
Title,async function bootstrap() {
Title,const app = await NestFactory.create(
Title,"AppModule,"
Title,);
Title,"app.useStaticAssets(join(__dirname, '..', 'public'));"
Title,"app.setBaseViewsDir(join(__dirname, '..', 'views'));"
Title,app.setViewEngine('hbs');
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,bootstrap();
Title,```
Title,"We told Express that the public directory will be used for storing static assets, views will contain templates, and the hbs template engine should be used to render HTML output."
Title,Template rendering
Title,"Now, let's create a views directory and index.hbs template inside it. In the template, we'll print a message passed from the controller:"
Title,```html
Title,
Title,
Title,
Title,
Title,App
Title,
Title,
Title,"{{ ""{{ message }\}"" }}"
Title,
Title,
Title,```
Title,"Next, open the app.controller file and replace the root() method with the following code:"
Title,```typescript
Title,@@filename(app.controller)
Title,"import { Get, Controller, Render } from '@nestjs/common';"
Title,@Controller()
Title,export class AppController {
Title,@Get()
Title,@Render('index')
Title,root() {
Title,return { message: 'Hello world!' };
Title,}
Title,}
Title,```
Title,"In this code, we are specifying the template to use in the @Render() decorator, and the return value of the route handler method is passed to the template for rendering. Notice that the return value is an object with a property message, matching the message placeholder we created in the template."
Title,"While the application is running, open your browser and navigate to http://localhost:3000. You should see the Hello world! message."
Title,Dynamic template rendering
Title,"If the application logic must dynamically decide which template to render, then we should use the @Res() decorator, and supply the view name in our route handler, rather than in the @Render() decorator:"
Title,
Title,"info Hint When Nest detects the @Res() decorator, it injects the library-specific response object. We can use this object to dynamically render the template. Learn more about the response object API here."
Title,
Title,```typescript
Title,@@filename(app.controller)
Title,"import { Get, Controller, Res, Render } from '@nestjs/common';"
Title,import { Response } from 'express';
Title,import { AppService } from './app.service';
Title,@Controller()
Title,export class AppController {
Title,constructor(private appService: AppService) {}
Title,@Get()
Title,root(@Res() res: Response) {
Title,return res.render(
Title,"this.appService.getViewName(),"
Title,"{ message: 'Hello world!' },"
Title,);
Title,}
Title,}
Title,```
Title,Example
Title,A working example is available here.
Title,Fastify
Title,"As mentioned in this chapter, we are able to use any compatible HTTP provider together with Nest. One such library is Fastify. In order to create an MVC application with Fastify, we have to install the following packages:"
Title,bash
Title,$ npm i --save @fastify/static @fastify/view handlebars
Title,"The next steps cover almost the same process used with Express, with minor differences specific to the platform. Once the installation process is complete, open the main.ts file and update its contents:"
Title,```typescript
Title,@@filename(main)
Title,import { NestFactory } from '@nestjs/core';
Title,"import { NestFastifyApplication, FastifyAdapter } from '@nestjs/platform-fastify';"
Title,import { AppModule } from './app.module';
Title,import { join } from 'path';
Title,async function bootstrap() {
Title,const app = await NestFactory.create(
Title,"AppModule,"
Title,"new FastifyAdapter(),"
Title,);
Title,app.useStaticAssets({
Title,"root: join(__dirname, '..', 'public'),"
Title,"prefix: '/public/',"
Title,});
Title,app.setViewEngine({
Title,engine: {
Title,"handlebars: require('handlebars'),"
Title,"},"
Title,"templates: join(__dirname, '..', 'views'),"
Title,});
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,bootstrap();
Title,@@switch
Title,import { NestFactory } from '@nestjs/core';
Title,import { FastifyAdapter } from '@nestjs/platform-fastify';
Title,import { AppModule } from './app.module';
Title,import { join } from 'path';
Title,async function bootstrap() {
Title,"const app = await NestFactory.create(AppModule, new FastifyAdapter());"
Title,app.useStaticAssets({
Title,"root: join(__dirname, '..', 'public'),"
Title,"prefix: '/public/',"
Title,});
Title,app.setViewEngine({
Title,engine: {
Title,"handlebars: require('handlebars'),"
Title,"},"
Title,"templates: join(__dirname, '..', 'views'),"
Title,});
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,bootstrap();
Title,```
Title,"The Fastify API has a few differences, but the end result of these method calls is the same. One notable difference is that when using Fastify, the template name you pass into the @Render() decorator must include the file extension."
Title,Here’s how you can set it up:
Title,```typescript
Title,@@filename(app.controller)
Title,"import { Get, Controller, Render } from '@nestjs/common';"
Title,@Controller()
Title,export class AppController {
Title,@Get()
Title,@Render('index.hbs')
Title,root() {
Title,return { message: 'Hello world!' };
Title,}
Title,}
Title,```
Title,"Alternatively, you can use the @Res() decorator to directly inject the response and specify the view you want to render, as shown below:"
Title,```typescript
Title,import { Res } from '@nestjs/common';
Title,import { FastifyReply } from 'fastify';
Title,@Get()
Title,root(@Res() res: FastifyReply) {
Title,"return res.view('index.hbs', { title: 'Hello world!' });"
Title,}
Title,```
Title,"While the application is running, open your browser and navigate to http://localhost:3000. You should see the Hello world! message."
Title,Example
Title,A working example is available here.
Title,
Title,Performance (Fastify)
Title,"By default, Nest makes use of the Express framework. As mentioned earlier, Nest also provides compatibility with other libraries such as, for example, Fastify. Nest achieves this framework independence by implementing a framework adapter whose primary function is to proxy middleware and handlers to appropriate library-specific implementations."
Title,
Title,"info Hint Note that in order for a framework adapter to be implemented, the target library has to provide similar request/response pipeline processing as found in Express."
Title,
Title,"Fastify provides a good alternative framework for Nest because it solves design issues in a similar manner to Express. However, fastify is much faster than Express, achieving almost two times better benchmarks results. A fair question is why does Nest use Express as the default HTTP provider? The reason is that Express is widely-used, well-known, and has an enormous set of compatible middleware, which is available to Nest users out-of-the-box."
Title,"But since Nest provides framework-independence, you can easily migrate between them. Fastify can be a better choice when you place high value on very fast performance. To utilize Fastify, simply choose the built-in FastifyAdapter as shown in this chapter."
Title,Installation
Title,"First, we need to install the required package:"
Title,bash
Title,$ npm i --save @nestjs/platform-fastify
Title,Adapter
Title,"Once the Fastify platform is installed, we can use the FastifyAdapter."
Title,```typescript
Title,@@filename(main)
Title,import { NestFactory } from '@nestjs/core';
Title,import {
Title,"FastifyAdapter,"
Title,"NestFastifyApplication,"
Title,} from '@nestjs/platform-fastify';
Title,import { AppModule } from './app.module';
Title,async function bootstrap() {
Title,const app = await NestFactory.create(
Title,"AppModule,"
Title,new FastifyAdapter()
Title,);
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,bootstrap();
Title,```
Title,"By default, Fastify listens only on the localhost 127.0.0.1 interface (read more). If you want to accept connections on other hosts, you should specify '0.0.0.0' in the listen() call:"
Title,typescript
Title,async function bootstrap() {
Title,const app = await NestFactory.create<NestFastifyApplication>(
Title,"AppModule,"
Title,"new FastifyAdapter(),"
Title,);
Title,"await app.listen(3000, '0.0.0.0');"
Title,}
Title,Platform specific packages
Title,"Keep in mind that when you use the FastifyAdapter, Nest uses Fastify as the HTTP provider. This means that each recipe that relies on Express may no longer work. You should, instead, use Fastify equivalent packages."
Title,Redirect response
Title,"Fastify handles redirect responses slightly differently than Express. To do a proper redirect with Fastify, return both the status code and the URL, as follows:"
Title,typescript
Title,@Get()
Title,index(@Res() res) {
Title,res.status(302).redirect('/login');
Title,}
Title,Fastify options
Title,You can pass options into the Fastify constructor through the FastifyAdapter constructor. For example:
Title,typescript
Title,new FastifyAdapter({ logger: true });
Title,Middleware
Title,"Middleware functions retrieve the raw req and res objects instead of Fastify's wrappers. This is how the middie package works (that's used under the hood) and fastify - check out this page for more information,"
Title,```typescript
Title,@@filename(logger.middleware)
Title,"import { Injectable, NestMiddleware } from '@nestjs/common';"
Title,"import { FastifyRequest, FastifyReply } from 'fastify';"
Title,@Injectable()
Title,export class LoggerMiddleware implements NestMiddleware {
Title,"use(req: FastifyRequest['raw'], res: FastifyReply['raw'], next: () => void) {"
Title,console.log('Request...');
Title,next();
Title,}
Title,}
Title,@@switch
Title,import { Injectable } from '@nestjs/common';
Title,@Injectable()
Title,export class LoggerMiddleware {
Title,"use(req, res, next) {"
Title,console.log('Request...');
Title,next();
Title,}
Title,}
Title,```
Title,Route Config
Title,You can use the route config feature of Fastify with the @RouteConfig() decorator.
Title,typescript
Title,@RouteConfig({ output: 'hello world' })
Title,@Get()
Title,index(@Req() req) {
Title,return req.routeConfig.output;
Title,}
Title,Route Constraints
Title,"As of v10.3.0, @nestjs/platform-fastify supports route constraints feature of Fastify with @RouteConstraints decorator."
Title,typescript
Title,@RouteConstraints({ version: '1.2.x' })
Title,newFeature() {
Title,return 'This works only for version >= 1.2.x';
Title,}
Title,
Title,info Hint @RouteConfig() and @RouteConstraints are imported from @nestjs/platform-fastify.
Title,
Title,Example
Title,A working example is available here.
Title,
Title,Queues
Title,Queues are a powerful design pattern that help you deal with common application scaling and performance challenges. Some examples of problems that Queues can help you solve are:
Title,
Title,"Smooth out processing peaks. For example, if users can initiate resource-intensive tasks at arbitrary times, you can add these tasks to a queue instead of performing them synchronously. Then you can have worker processes pull tasks from the queue in a controlled manner. You can easily add new Queue consumers to scale up the back-end task handling as the application scales up."
Title,"Break up monolithic tasks that may otherwise block the Node.js event loop. For example, if a user request requires CPU intensive work like audio transcoding, you can delegate this task to other processes, freeing up user-facing processes to remain responsive."
Title,"Provide a reliable communication channel across various services. For example, you can queue tasks (jobs) in one process or service, and consume them in another. You can be notified (by listening for status events) upon completion, error or other state changes in the job life cycle from any process or service. When Queue producers or consumers fail, their state is preserved and task handling can restart automatically when nodes are restarted."
Title,
Title,"Nest provides the @nestjs/bullmq package for BullMQ integration and @nestjs/bull package for Bull integration. Both packages are abstractions/wrappers on top of their respective libraries, which were developed by the same team. Bull is currently in maintenance mode, with the team focusing on fixing bugs, while BullMQ is actively developed, featuring a modern TypeScript implementation and a different set of features. If Bull meets your requirements, it remains a reliable and battle-tested choice. The Nest packages make it easy to integrate both, BullMQ or Bull Queues, into your Nest application in a friendly way."
Title,"Both BullMQ and Bull use Redis to persist job data, so you'll need to have Redis installed on your system. Because they are Redis-backed, your Queue architecture can be completely distributed and platform-independent. For example, you can have some Queue producers and consumers and listeners running in Nest on one (or several) nodes, and other producers, consumers and listeners running on other Node.js platforms on other network nodes."
Title,This chapter covers the @nestjs/bullmq and @nestjs/bull packages. We also recommend reading the BullMQ and Bull documentation for more background and specific implementation details.
Title,BullMQ installation
Title,"To begin using BullMQ, we first install the required dependencies."
Title,bash
Title,$ npm install --save @nestjs/bullmq bullmq
Title,"Once the installation process is complete, we can import the BullModule into the root AppModule."
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { BullModule } from '@nestjs/bullmq';
Title,@Module({
Title,imports: [
Title,BullModule.forRoot({
Title,connection: {
Title,"host: 'localhost',"
Title,"port: 6379,"
Title,"},"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,"The forRoot() method is used to register a bullmq package configuration object that will be used by all queues registered in the application (unless specified otherwise). For your reference, the following are a few of the properties within a configuration object:"
Title,
Title,connection: ConnectionOptions - Options to configure the Redis connection. See Connections for more information. Optional.
Title,prefix: string - Prefix for all queue keys. Optional.
Title,defaultJobOptions: JobOpts - Options to control the default settings for new jobs. See JobOpts for more information. Optional.
Title,settings: AdvancedSettings - Advanced Queue configuration settings. These should usually not be changed. See AdvancedSettings for more information. Optional.
Title,
Title,"All the options are optional, providing detailed control over queue behavior. These are passed directly to the BullMQ Queue constructor. Read more about these options and other options here."
Title,"To register a queue, import the BullModule.registerQueue() dynamic module, as follows:"
Title,typescript
Title,BullModule.registerQueue({
Title,"name: 'audio',"
Title,});
Title,
Title,info Hint Create multiple queues by passing multiple comma-separated configuration objects to the registerQueue() method.
Title,
Title,"The registerQueue() method is used to instantiate and/or register queues. Queues are shared across modules and processes that connect to the same underlying Redis database with the same credentials. Each queue is unique by its name property. A queue name is used as both an injection token (for injecting the queue into controllers/providers), and as an argument to decorators to associate consumer classes and listeners with queues."
Title,"You can also override some of the pre-configured options for a specific queue, as follows:"
Title,typescript
Title,BullModule.registerQueue({
Title,"name: 'audio',"
Title,connection: {
Title,"port: 6380,"
Title,"},"
Title,});
Title,BullMQ also supports parent - child relationships between jobs. This functionality enables the creation of flows where jobs are the node of trees of arbitrary depth. To read more about them check here.
Title,"To add a flow, you can do the following:"
Title,typescript
Title,BullModule.registerFlowProducer({
Title,"name: 'flowProducerName',"
Title,});
Title,"Since jobs are persisted in Redis, each time a specific named queue is instantiated (e.g., when an app is started/restarted), it attempts to process any old jobs that may exist from a previous unfinished session."
Title,"Each queue can have one or many producers, consumers, and listeners. Consumers retrieve jobs from the queue in a specific order: FIFO (the default), LIFO, or according to priorities. Controlling queue processing order is discussed here."
Title,
Title,Named configurations
Title,"If your queues connect to multiple different Redis instances, you can use a technique called named configurations. This feature allows you to register several configurations under specified keys, which then you can refer to in the queue options."
Title,"For example, assuming that you have an additional Redis instance (apart from the default one) used by a few queues registered in your application, you can register its configuration as follows:"
Title,typescript
Title,"BullModule.forRoot('alternative-config', {"
Title,connection: {
Title,"port: 6381,"
Title,"},"
Title,});
Title,"In the example above, 'alternative-config' is just a configuration key (it can be any arbitrary string)."
Title,"With this in place, you can now point to this configuration in the registerQueue() options object:"
Title,typescript
Title,BullModule.registerQueue({
Title,"configKey: 'alternative-config',"
Title,"name: 'video',"
Title,});
Title,Producers
Title,"Job producers add jobs to queues. Producers are typically application services (Nest providers). To add jobs to a queue, first inject the queue into the service as follows:"
Title,```typescript
Title,import { Injectable } from '@nestjs/common';
Title,import { Queue } from 'bullmq';
Title,import { InjectQueue } from '@nestjs/bullmq';
Title,@Injectable()
Title,export class AudioService {
Title,constructor(@InjectQueue('audio') private audioQueue: Queue) {}
Title,}
Title,```
Title,
Title,"info Hint The @InjectQueue() decorator identifies the queue by its name, as provided in the registerQueue() method call (e.g., 'audio')."
Title,
Title,"Now, add a job by calling the queue's add() method, passing a user-defined job object. Jobs are represented as serializable JavaScript objects (since that is how they are stored in the Redis database). The shape of the job you pass is arbitrary; use it to represent the semantics of your job object. You also need to give it a name. This allows you to create specialized consumers that will only process jobs with a given name."
Title,typescript
Title,"const job = await this.audioQueue.add('transcode', {"
Title,"foo: 'bar',"
Title,});
Title,Job options
Title,Jobs can have additional options associated with them. Pass an options object after the job argument in the Queue.add() method. Some of the job options properties are:
Title,
Title,"priority: number - Optional priority value. Ranges from 1 (highest priority) to MAX_INT (lowest priority). Note that using priorities has a slight impact on performance, so use them with caution."
Title,"delay: number - An amount of time (milliseconds) to wait until this job can be processed. Note that for accurate delays, both server and clients should have their clocks synchronized."
Title,attempts: number - The total number of attempts to try the job until it completes.
Title,repeat: RepeatOpts - Repeat job according to a cron specification. See RepeatOpts.
Title,backoff: number | BackoffOpts - Backoff setting for automatic retries if the job fails. See BackoffOpts.
Title,"lifo: boolean - If true, adds the job to the right end of the queue instead of the left (default false)."
Title,"jobId: number | string - Override the job ID - by default, the job ID is a unique"
Title,"integer, but you can use this setting to override it. If you use this option, it is up to you to ensure the jobId is unique. If you attempt to add a job with an id that already exists, it will not be added."
Title,"removeOnComplete: boolean | number - If true, removes the job when it successfully completes. A number specifies the amount of jobs to keep. Default behavior is to keep the job in the completed set."
Title,"removeOnFail: boolean | number - If true, removes the job when it fails after all attempts. A number specifies the amount of jobs to keep. Default behavior is to keep the job in the failed set."
Title,stackTraceLimit: number - Limits the amount of stack trace lines that will be recorded in the stacktrace.
Title,
Title,Here are a few examples of customizing jobs with job options.
Title,"To delay the start of a job, use the delay configuration property."
Title,typescript
Title,const job = await this.audioQueue.add(
Title,"'transcode',"
Title,{
Title,"foo: 'bar',"
Title,"},"
Title,"{ delay: 3000 }, // 3 seconds delayed"
Title,);
Title,"To add a job to the right end of the queue (process the job as LIFO (Last In First Out)), set the lifo property of the configuration object to true."
Title,typescript
Title,const job = await this.audioQueue.add(
Title,"'transcode',"
Title,{
Title,"foo: 'bar',"
Title,"},"
Title,"{ lifo: true },"
Title,);
Title,"To prioritize a job, use the priority property."
Title,typescript
Title,const job = await this.audioQueue.add(
Title,"'transcode',"
Title,{
Title,"foo: 'bar',"
Title,"},"
Title,"{ priority: 2 },"
Title,);
Title,"For a full list of options, check the API documentation here and here."
Title,Consumers
Title,"A consumer is a class defining methods that either process jobs added into the queue, or listen for events on the queue, or both. Declare a consumer class using the @Processor() decorator as follows:"
Title,```typescript
Title,import { Processor } from '@nestjs/bullmq';
Title,@Processor('audio')
Title,export class AudioConsumer {}
Title,```
Title,
Title,info Hint Consumers must be registered as providers so the @nestjs/bullmq package can pick them up.
Title,
Title,"Where the decorator's string argument (e.g., 'audio') is the name of the queue to be associated with the class methods."
Title,```typescript
Title,"import { Processor, WorkerHost } from '@nestjs/bullmq';"
Title,import { Job } from 'bullmq';
Title,@Processor('audio')
Title,export class AudioConsumer extends WorkerHost {
Title,async process(job: Job): Promise {
Title,let progress = 0;
Title,for (i = 0; i < 100; i++) {
Title,await doSomething(job.data);
Title,progress += 1;
Title,await job.progress(progress);
Title,}
Title,return {};
Title,}
Title,}
Title,```
Title,"The process method is called whenever the worker is idle and there are jobs to process in the queue. This handler method receives the job object as its only argument. The value returned by the handler method is stored in the job object and can be accessed later on, for example in a listener for the completed event."
Title,"Job objects have multiple methods that allow you to interact with their state. For example, the above code uses the progress() method to update the job's progress. See here for the complete Job object API reference."
Title,"In the older version, Bull, you could designate that a job handler method will handle only jobs of a certain type (jobs with a specific name) by passing that name to the @Process() decorator as shown below."
Title,
Title,"warning Warning This doesn't work with BullMQ, keep reading."
Title,
Title,typescript
Title,@Process('transcode')
Title,async transcode(job: Job<unknown>) { ... }
Title,"This behavior is not supported in BullMQ due to confusions it generated. Instead, you need switch cases to call different services or logic for each job name:"
Title,```typescript
Title,"import { Processor, WorkerHost } from '@nestjs/bullmq';"
Title,import { Job } from 'bullmq';
Title,@Processor('audio')
Title,export class AudioConsumer extends WorkerHost {
Title,async process(job: Job): Promise {
Title,switch (job.name) {
Title,case 'transcode': {
Title,let progress = 0;
Title,for (i = 0; i < 100; i++) {
Title,await doSomething(job.data);
Title,progress += 1;
Title,await job.progress(progress);
Title,}
Title,return {};
Title,}
Title,case 'concatenate': {
Title,await doSomeLogic2();
Title,break;
Title,}
Title,}
Title,}
Title,}
Title,```
Title,This is covered in the named processor section of the BullMQ documentation.
Title,Request-scoped consumers
Title,"When a consumer is flagged as request-scoped (learn more about the injection scopes here), a new instance of the class will be created exclusively for each job. The instance will be garbage-collected after the job has completed."
Title,typescript
Title,@Processor({
Title,"name: 'audio',"
Title,"scope: Scope.REQUEST,"
Title,})
Title,"Since request-scoped consumer classes are instantiated dynamically and scoped to a single job, you can inject a JOB_REF through the constructor using a standard approach."
Title,typescript
Title,constructor(@Inject(JOB_REF) jobRef: Job) {
Title,console.log(jobRef);
Title,}
Title,
Title,info Hint The JOB_REF token is imported from the @nestjs/bullmq package.
Title,
Title,Event listeners
Title,"BullMQ generates a set of useful events when queue and/or job state changes occur. These events can be subscribed to at the Worker level using the @OnWorkerEvent(event) decorator, or at the Queue level with a dedicated listener class and the @OnQueueEvent(event) decorator."
Title,"Worker events must be declared within a consumer class (i.e., within a class decorated with the @Processor() decorator). To listen for an event, use the @OnWorkerEvent(event) decorator with the event you want to be handled. For example, to listen to the event emitted when a job enters the active state in the audio queue, use the following construct:"
Title,```typescript
Title,"import { Processor, Process, OnWorkerEvent } from '@nestjs/bullmq';"
Title,import { Job } from 'bullmq';
Title,@Processor('audio')
Title,export class AudioConsumer {
Title,@OnWorkerEvent('active')
Title,onActive(job: Job) {
Title,console.log(
Title,"Processing job ${job.id} of type ${job.name} with data ${job.data}...,"
Title,);
Title,}
Title,// ...
Title,}
Title,```
Title,You can see the complete list of events and their arguments as properties of WorkerListener here.
Title,"QueueEvent listeners must use the @QueueEventsListener(queue) decorator and extend the QueueEventsHost class provided by @nestjs/bullmq. To listen for an event, use the @OnQueueEvent(event) decorator with the event you want to be handled. For example, to listen to the event emitted when a job enters the active state in the audio queue, use the following construct:"
Title,```typescript
Title,import {
Title,"QueueEventsHost,"
Title,"QueueEventsListener,"
Title,"OnQueueEvent,"
Title,} from '@nestjs/bullmq';
Title,@QueueEventsListener('audio')
Title,export class AudioEventsListener extends QueueEventsHost {
Title,@OnQueueEvent('active')
Title,onActive(job: { jobId: string; prev?: string }) {
Title,console.log(Processing job ${job.jobId}...);
Title,}
Title,// ...
Title,}
Title,```
Title,
Title,info Hint QueueEvent Listeners must be registered as providers so the @nestjs/bullmq package can pick them up.
Title,
Title,You can see the complete list of events and their arguments as properties of QueueEventsListener here.
Title,Queue management
Title,"Queues have an API that allows you to perform management functions like pausing and resuming, retrieving the count of jobs in various states, and several more. You can find the full queue API here. Invoke any of these methods directly on the Queue object, as shown below with the pause/resume examples."
Title,"Pause a queue with the pause() method call. A paused queue will not process new jobs until resumed, but current jobs being processed will continue until they are finalized."
Title,typescript
Title,await audioQueue.pause();
Title,"To resume a paused queue, use the resume() method, as follows:"
Title,typescript
Title,await audioQueue.resume();
Title,Separate processes
Title,Job handlers can also be run in a separate (forked) process (source). This has several advantages:
Title,
Title,The process is sandboxed so if it crashes it does not affect the worker.
Title,You can run blocking code without affecting the queue (jobs will not stall).
Title,Much better utilization of multi-core CPUs.
Title,Less connections to redis.
Title,
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { BullModule } from '@nestjs/bullmq';
Title,import { join } from 'path';
Title,@Module({
Title,imports: [
Title,BullModule.registerQueue({
Title,"name: 'audio',"
Title,"processors: [join(__dirname, 'processor.js')],"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,
Title,"warning Warning Please note that because your function is being executed in a forked process, Dependency Injection (and IoC container) won't be available. That means that your processor function will need to contain (or create) all instances of external dependencies it needs."
Title,
Title,Async configuration
Title,"You may want to pass bullmq options asynchronously instead of statically. In this case, use the forRootAsync() method which provides several ways to deal with async configuration. Likewise, if you want to pass queue options asynchronously, use the registerQueueAsync() method."
Title,One approach is to use a factory function:
Title,typescript
Title,BullModule.forRootAsync({
Title,useFactory: () => ({
Title,connection: {
Title,"host: 'localhost',"
Title,"port: 6379,"
Title,"},"
Title,"}),"
Title,});
Title,"Our factory behaves like any other asynchronous provider (e.g., it can be async and it's able to inject dependencies through inject)."
Title,typescript
Title,BullModule.forRootAsync({
Title,"imports: [ConfigModule],"
Title,useFactory: async (configService: ConfigService) => ({
Title,connection: {
Title,"host: configService.get('QUEUE_HOST'),"
Title,"port: configService.get('QUEUE_PORT'),"
Title,"},"
Title,"}),"
Title,"inject: [ConfigService],"
Title,});
Title,"Alternatively, you can use the useClass syntax:"
Title,typescript
Title,BullModule.forRootAsync({
Title,"useClass: BullConfigService,"
Title,});
Title,"The construction above will instantiate BullConfigService inside BullModule and use it to provide an options object by calling createSharedConfiguration(). Note that this means that the BullConfigService has to implement the SharedBullConfigurationFactory interface, as shown below:"
Title,typescript
Title,@Injectable()
Title,class BullConfigService implements SharedBullConfigurationFactory {
Title,createSharedConfiguration(): BullModuleOptions {
Title,return {
Title,connection: {
Title,"host: 'localhost',"
Title,"port: 6379,"
Title,"},"
Title,};
Title,}
Title,}
Title,"In order to prevent the creation of BullConfigService inside BullModule and use a provider imported from a different module, you can use the useExisting syntax."
Title,typescript
Title,BullModule.forRootAsync({
Title,"imports: [ConfigModule],"
Title,"useExisting: ConfigService,"
Title,});
Title,This construction works the same as useClass with one critical difference - BullModule will lookup imported modules to reuse an existing ConfigService instead of instantiating a new one.
Title,"Likewise, if you want to pass queue options asynchronously, use the registerQueueAsync() method, just keep in mind to specify the name attribute outside the factory function."
Title,typescript
Title,BullModule.registerQueueAsync({
Title,"name: 'audio',"
Title,useFactory: () => ({
Title,redis: {
Title,"host: 'localhost',"
Title,"port: 6379,"
Title,"},"
Title,"}),"
Title,});
Title,Bull installation
Title,
Title,"warning Note If you decided to use BullMQ, skip this section and the following chapters."
Title,
Title,"To begin using Bull, we first install the required dependencies."
Title,bash
Title,$ npm install --save @nestjs/bull bull
Title,"Once the installation process is complete, we can import the BullModule into the root AppModule."
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { BullModule } from '@nestjs/bull';
Title,@Module({
Title,imports: [
Title,BullModule.forRoot({
Title,redis: {
Title,"host: 'localhost',"
Title,"port: 6379,"
Title,"},"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,The forRoot() method is used to register a bull package configuration object that will be used by all queues registered in the application (unless specified otherwise). A configuration object consists of the following properties:
Title,
Title,limiter: RateLimiter - Options to control the rate at which the queue's jobs are processed. See RateLimiter for more information. Optional.
Title,redis: RedisOpts - Options to configure the Redis connection. See RedisOpts for more information. Optional.
Title,prefix: string - Prefix for all queue keys. Optional.
Title,defaultJobOptions: JobOpts - Options to control the default settings for new jobs. See JobOpts for more information. Optional. Note: These do not take effect if you schedule jobs via a FlowProducer. See bullmq#1034 for explanation.
Title,settings: AdvancedSettings - Advanced Queue configuration settings. These should usually not be changed. See AdvancedSettings for more information. Optional.
Title,
Title,"All the options are optional, providing detailed control over queue behavior. These are passed directly to the Bull Queue constructor. Read more about these options here."
Title,"To register a queue, import the BullModule.registerQueue() dynamic module, as follows:"
Title,typescript
Title,BullModule.registerQueue({
Title,"name: 'audio',"
Title,});
Title,
Title,info Hint Create multiple queues by passing multiple comma-separated configuration objects to the registerQueue() method.
Title,
Title,"The registerQueue() method is used to instantiate and/or register queues. Queues are shared across modules and processes that connect to the same underlying Redis database with the same credentials. Each queue is unique by its name property. A queue name is used as both an injection token (for injecting the queue into controllers/providers), and as an argument to decorators to associate consumer classes and listeners with queues."
Title,"You can also override some of the pre-configured options for a specific queue, as follows:"
Title,typescript
Title,BullModule.registerQueue({
Title,"name: 'audio',"
Title,redis: {
Title,"port: 6380,"
Title,"},"
Title,});
Title,"Since jobs are persisted in Redis, each time a specific named queue is instantiated (e.g., when an app is started/restarted), it attempts to process any old jobs that may exist from a previous unfinished session."
Title,"Each queue can have one or many producers, consumers, and listeners. Consumers retrieve jobs from the queue in a specific order: FIFO (the default), LIFO, or according to priorities. Controlling queue processing order is discussed here."
Title,
Title,Named configurations
Title,"If your queues connect to multiple Redis instances, you can use a technique called named configurations. This feature allows you to register several configurations under specified keys, which then you can refer to in the queue options."
Title,"For example, assuming that you have an additional Redis instance (apart from the default one) used by a few queues registered in your application, you can register its configuration as follows:"
Title,typescript
Title,"BullModule.forRoot('alternative-config', {"
Title,redis: {
Title,"port: 6381,"
Title,"},"
Title,});
Title,"In the example above, 'alternative-config' is just a configuration key (it can be any arbitrary string)."
Title,"With this in place, you can now point to this configuration in the registerQueue() options object:"
Title,typescript
Title,BullModule.registerQueue({
Title,"configKey: 'alternative-config',"
Title,"name: 'video',"
Title,});
Title,Producers
Title,"Job producers add jobs to queues. Producers are typically application services (Nest providers). To add jobs to a queue, first inject the queue into the service as follows:"
Title,```typescript
Title,import { Injectable } from '@nestjs/common';
Title,import { Queue } from 'bull';
Title,import { InjectQueue } from '@nestjs/bull';
Title,@Injectable()
Title,export class AudioService {
Title,constructor(@InjectQueue('audio') private audioQueue: Queue) {}
Title,}
Title,```
Title,
Title,"info Hint The @InjectQueue() decorator identifies the queue by its name, as provided in the registerQueue() method call (e.g., 'audio')."
Title,
Title,"Now, add a job by calling the queue's add() method, passing a user-defined job object. Jobs are represented as serializable JavaScript objects (since that is how they are stored in the Redis database). The shape of the job you pass is arbitrary; use it to represent the semantics of your job object."
Title,typescript
Title,const job = await this.audioQueue.add({
Title,"foo: 'bar',"
Title,});
Title,Named jobs
Title,Jobs may have unique names. This allows you to create specialized consumers that will only process jobs with a given name.
Title,typescript
Title,"const job = await this.audioQueue.add('transcode', {"
Title,"foo: 'bar',"
Title,});
Title,
Title,"Warning Warning When using named jobs, you must create processors for each unique name added to a queue, or the queue will complain that you are missing a processor for the given job. See here for more information on consuming named jobs."
Title,
Title,Job options
Title,Jobs can have additional options associated with them. Pass an options object after the job argument in the Queue.add() method. Job options properties are:
Title,
Title,"priority: number - Optional priority value. Ranges from 1 (highest priority) to MAX_INT (lowest priority). Note that using priorities has a slight impact on performance, so use them with caution."
Title,"delay: number - An amount of time (milliseconds) to wait until this job can be processed. Note that for accurate delays, both server and clients should have their clocks synchronized."
Title,attempts: number - The total number of attempts to try the job until it completes.
Title,repeat: RepeatOpts - Repeat job according to a cron specification. See RepeatOpts.
Title,backoff: number | BackoffOpts - Backoff setting for automatic retries if the job fails. See BackoffOpts.
Title,"lifo: boolean - If true, adds the job to the right end of the queue instead of the left (default false)."
Title,timeout: number - The number of milliseconds after which the job should fail with a timeout error.
Title,"jobId: number | string - Override the job ID - by default, the job ID is a unique"
Title,"integer, but you can use this setting to override it. If you use this option, it is up to you to ensure the jobId is unique. If you attempt to add a job with an id that already exists, it will not be added."
Title,"removeOnComplete: boolean | number - If true, removes the job when it successfully completes. A number specifies the amount of jobs to keep. Default behavior is to keep the job in the completed set."
Title,"removeOnFail: boolean | number - If true, removes the job when it fails after all attempts. A number specifies the amount of jobs to keep. Default behavior is to keep the job in the failed set."
Title,stackTraceLimit: number - Limits the amount of stack trace lines that will be recorded in the stacktrace.
Title,
Title,Here are a few examples of customizing jobs with job options.
Title,"To delay the start of a job, use the delay configuration property."
Title,typescript
Title,const job = await this.audioQueue.add(
Title,{
Title,"foo: 'bar',"
Title,"},"
Title,"{ delay: 3000 }, // 3 seconds delayed"
Title,);
Title,"To add a job to the right end of the queue (process the job as LIFO (Last In First Out)), set the lifo property of the configuration object to true."
Title,typescript
Title,const job = await this.audioQueue.add(
Title,{
Title,"foo: 'bar',"
Title,"},"
Title,"{ lifo: true },"
Title,);
Title,"To prioritize a job, use the priority property."
Title,typescript
Title,const job = await this.audioQueue.add(
Title,{
Title,"foo: 'bar',"
Title,"},"
Title,"{ priority: 2 },"
Title,);
Title,Consumers
Title,"A consumer is a class defining methods that either process jobs added into the queue, or listen for events on the queue, or both. Declare a consumer class using the @Processor() decorator as follows:"
Title,```typescript
Title,import { Processor } from '@nestjs/bull';
Title,@Processor('audio')
Title,export class AudioConsumer {}
Title,```
Title,
Title,info Hint Consumers must be registered as providers so the @nestjs/bull package can pick them up.
Title,
Title,"Where the decorator's string argument (e.g., 'audio') is the name of the queue to be associated with the class methods."
Title,"Within a consumer class, declare job handlers by decorating handler methods with the @Process() decorator."
Title,```typescript
Title,"import { Processor, Process } from '@nestjs/bull';"
Title,import { Job } from 'bull';
Title,@Processor('audio')
Title,export class AudioConsumer {
Title,@Process()
Title,async transcode(job: Job) {
Title,let progress = 0;
Title,for (let i = 0; i < 100; i++) {
Title,await doSomething(job.data);
Title,progress += 1;
Title,await job.progress(progress);
Title,}
Title,return {};
Title,}
Title,}
Title,```
Title,"The decorated method (e.g., transcode()) is called whenever the worker is idle and there are jobs to process in the queue. This handler method receives the job object as its only argument. The value returned by the handler method is stored in the job object and can be accessed later on, for example in a listener for the completed event."
Title,"Job objects have multiple methods that allow you to interact with their state. For example, the above code uses the progress() method to update the job's progress. See here for the complete Job object API reference."
Title,"You can designate that a job handler method will handle only jobs of a certain type (jobs with a specific name) by passing that name to the @Process() decorator as shown below. You can have multiple @Process() handlers in a given consumer class, corresponding to each job type (name). When you use named jobs, be sure to have a handler corresponding to each name."
Title,typescript
Title,@Process('transcode')
Title,async transcode(job: Job<unknown>) { ... }
Title,
Title,"warning Warning When defining multiple consumers for the same queue, the concurrency option in @Process({{ '{' }} concurrency: 1 {{ '}' }}) won't take effect. The minimum concurrency will match the number of consumers defined. This also applies even if @Process() handlers use a different name to handle named jobs."
Title,
Title,Request-scoped consumers
Title,"When a consumer is flagged as request-scoped (learn more about the injection scopes here), a new instance of the class will be created exclusively for each job. The instance will be garbage-collected after the job has completed."
Title,typescript
Title,@Processor({
Title,"name: 'audio',"
Title,"scope: Scope.REQUEST,"
Title,})
Title,"Since request-scoped consumer classes are instantiated dynamically and scoped to a single job, you can inject a JOB_REF through the constructor using a standard approach."
Title,typescript
Title,constructor(@Inject(JOB_REF) jobRef: Job) {
Title,console.log(jobRef);
Title,}
Title,
Title,info Hint The JOB_REF token is imported from the @nestjs/bull package.
Title,
Title,Event listeners
Title,Bull generates a set of useful events when queue and/or job state changes occur. Nest provides a set of decorators that allow subscribing to a core set of standard events. These are exported from the @nestjs/bull package.
Title,"Event listeners must be declared within a consumer class (i.e., within a class decorated with the @Processor() decorator). To listen for an event, use one of the decorators in the table below to declare a handler for the event. For example, to listen to the event emitted when a job enters the active state in the audio queue, use the following construct:"
Title,```typescript
Title,"import { Processor, Process, OnQueueActive } from '@nestjs/bull';"
Title,import { Job } from 'bull';
Title,@Processor('audio')
Title,export class AudioConsumer {
Title,@OnQueueActive()
Title,onActive(job: Job) {
Title,console.log(
Title,"Processing job ${job.id} of type ${job.name} with data ${job.data}...,"
Title,);
Title,}
Title,...
Title,```
Title,"Since Bull operates in a distributed (multi-node) environment, it defines the concept of event locality. This concept recognizes that events may be triggered either entirely within a single process, or on shared queues from different processes. A local event is one that is produced when an action or state change is triggered on a queue in the local process. In other words, when your event producers and consumers are local to a single process, all events happening on queues are local."
Title,"When a queue is shared across multiple processes, we encounter the possibility of global events. For a listener in one process to receive an event notification triggered by another process, it must register for a global event."
Title,"Event handlers are invoked whenever their corresponding event is emitted. The handler is called with the signature shown in the table below, providing access to information relevant to the event. We discuss one key difference between local and global event handler signatures below."
Title,
Title,
Title,Local event listeners
Title,Global event listeners
Title,Handler method signature / When fired
Title,
Title,
Title,@OnQueueError()@OnGlobalQueueError()handler(error: Error) - An error occurred. error contains the triggering error.
Title,
Title,
Title,@OnQueueWaiting()@OnGlobalQueueWaiting()handler(jobId: number | string) - A Job is waiting to be processed as soon as a worker is idling. jobId contains the id for the job that has entered this state.
Title,
Title,
Title,@OnQueueActive()@OnGlobalQueueActive()handler(job: Job) - Job jobhas started.
Title,
Title,
Title,@OnQueueStalled()@OnGlobalQueueStalled()handler(job: Job) - Job job has been marked as stalled. This is useful for debugging job workers that crash or pause the event loop.
Title,
Title,
Title,"@OnQueueProgress()@OnGlobalQueueProgress()handler(job: Job, progress: number) - Job job's progress was updated to value progress."
Title,
Title,
Title,"@OnQueueCompleted()@OnGlobalQueueCompleted()handler(job: Job, result: any) Job job successfully completed with a result result."
Title,
Title,
Title,"@OnQueueFailed()@OnGlobalQueueFailed()handler(job: Job, err: Error) Job job failed with reason err."
Title,
Title,
Title,@OnQueuePaused()@OnGlobalQueuePaused()handler() The queue has been paused.
Title,
Title,
Title,@OnQueueResumed()@OnGlobalQueueResumed()handler(job: Job) The queue has been resumed.
Title,
Title,
Title,"@OnQueueCleaned()@OnGlobalQueueCleaned()handler(jobs: Job[], type: string) Old jobs have been cleaned from the queue. jobs is an array of cleaned jobs, and type is the type of jobs cleaned."
Title,
Title,
Title,@OnQueueDrained()@OnGlobalQueueDrained()handler() Emitted whenever the queue has processed all the waiting jobs (even if there can be some delayed jobs not yet processed).
Title,
Title,
Title,@OnQueueRemoved()@OnGlobalQueueRemoved()handler(job: Job) Job job was successfully removed.
Title,
Title,
Title,"When listening for global events, the method signatures can be slightly different from their local counterpart. Specifically, any method signature that receives job objects in the local version, instead receives a jobId (number) in the global version. To get a reference to the actual job object in such a case, use the Queue#getJob method. This call should be awaited, and therefore the handler should be declared async. For example:"
Title,typescript
Title,@OnGlobalQueueCompleted()
Title,"async onGlobalCompleted(jobId: number, result: any) {"
Title,const job = await this.immediateQueue.getJob(jobId);
Title,"console.log('(Global) on completed: job ', job.id, ' -> result: ', result);"
Title,}
Title,
Title,"info Hint To access the Queue object (to make a getJob() call), you must of course inject it. Also, the Queue must be registered in the module where you are injecting it."
Title,
Title,"In addition to the specific event listener decorators, you can also use the generic @OnQueueEvent() decorator in combination with either BullQueueEvents or BullQueueGlobalEvents enums. Read more about events here."
Title,Queue management
Title,"Queue's have an API that allows you to perform management functions like pausing and resuming, retrieving the count of jobs in various states, and several more. You can find the full queue API here. Invoke any of these methods directly on the Queue object, as shown below with the pause/resume examples."
Title,"Pause a queue with the pause() method call. A paused queue will not process new jobs until resumed, but current jobs being processed will continue until they are finalized."
Title,typescript
Title,await audioQueue.pause();
Title,"To resume a paused queue, use the resume() method, as follows:"
Title,typescript
Title,await audioQueue.resume();
Title,Separate processes
Title,Job handlers can also be run in a separate (forked) process (source). This has several advantages:
Title,
Title,The process is sandboxed so if it crashes it does not affect the worker.
Title,You can run blocking code without affecting the queue (jobs will not stall).
Title,Much better utilization of multi-core CPUs.
Title,Less connections to redis.
Title,
Title,```ts
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { BullModule } from '@nestjs/bull';
Title,import { join } from 'path';
Title,@Module({
Title,imports: [
Title,BullModule.registerQueue({
Title,"name: 'audio',"
Title,"processors: [join(__dirname, 'processor.js')],"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,"Please note that because your function is being executed in a forked process, Dependency Injection (and IoC container) won't be available. That means that your processor function will need to contain (or create) all instances of external dependencies it needs."
Title,```ts
Title,@@filename(processor)
Title,"import { Job, DoneCallback } from 'bull';"
Title,"export default function (job: Job, cb: DoneCallback) {"
Title,console.log([${process.pid}] ${JSON.stringify(job.data)});
Title,"cb(null, 'It works');"
Title,}
Title,```
Title,Async configuration
Title,"You may want to pass bull options asynchronously instead of statically. In this case, use the forRootAsync() method which provides several ways to deal with async configuration."
Title,One approach is to use a factory function:
Title,typescript
Title,BullModule.forRootAsync({
Title,useFactory: () => ({
Title,redis: {
Title,"host: 'localhost',"
Title,"port: 6379,"
Title,"},"
Title,"}),"
Title,});
Title,"Our factory behaves like any other asynchronous provider (e.g., it can be async and it's able to inject dependencies through inject)."
Title,typescript
Title,BullModule.forRootAsync({
Title,"imports: [ConfigModule],"
Title,useFactory: async (configService: ConfigService) => ({
Title,redis: {
Title,"host: configService.get('QUEUE_HOST'),"
Title,"port: configService.get('QUEUE_PORT'),"
Title,"},"
Title,"}),"
Title,"inject: [ConfigService],"
Title,});
Title,"Alternatively, you can use the useClass syntax:"
Title,typescript
Title,BullModule.forRootAsync({
Title,"useClass: BullConfigService,"
Title,});
Title,"The construction above will instantiate BullConfigService inside BullModule and use it to provide an options object by calling createSharedConfiguration(). Note that this means that the BullConfigService has to implement the SharedBullConfigurationFactory interface, as shown below:"
Title,typescript
Title,@Injectable()
Title,class BullConfigService implements SharedBullConfigurationFactory {
Title,createSharedConfiguration(): BullModuleOptions {
Title,return {
Title,redis: {
Title,"host: 'localhost',"
Title,"port: 6379,"
Title,"},"
Title,};
Title,}
Title,}
Title,"In order to prevent the creation of BullConfigService inside BullModule and use a provider imported from a different module, you can use the useExisting syntax."
Title,typescript
Title,BullModule.forRootAsync({
Title,"imports: [ConfigModule],"
Title,"useExisting: ConfigService,"
Title,});
Title,This construction works the same as useClass with one critical difference - BullModule will lookup imported modules to reuse an existing ConfigService instead of instantiating a new one.
Title,"Likewise, if you want to pass queue options asynchronously, use the registerQueueAsync() method, just keep in mind to specify the name attribute outside the factory function."
Title,typescript
Title,BullModule.registerQueueAsync({
Title,"name: 'audio',"
Title,useFactory: () => ({
Title,redis: {
Title,"host: 'localhost',"
Title,"port: 6379,"
Title,"},"
Title,"}),"
Title,});
Title,Example
Title,A working example is available here.
Title,
Title,Serialization
Title,"Serialization is a process that happens before objects are returned in a network response. This is an appropriate place to provide rules for transforming and sanitizing the data to be returned to the client. For example, sensitive data like passwords should always be excluded from the response. Or, certain properties might require additional transformation, such as sending only a subset of properties of an entity. Performing these transformations manually can be tedious and error prone, and can leave you uncertain that all cases have been covered."
Title,Overview
Title,"Nest provides a built-in capability to help ensure that these operations can be performed in a straightforward way. The ClassSerializerInterceptor interceptor uses the powerful class-transformer package to provide a declarative and extensible way of transforming objects. The basic operation it performs is to take the value returned by a method handler and apply the instanceToPlain() function from class-transformer. In doing so, it can apply rules expressed by class-transformer decorators on an entity/DTO class, as described below."
Title,
Title,info Hint The serialization does not apply to StreamableFile responses.
Title,
Title,Exclude properties
Title,Let's assume that we want to automatically exclude a password property from a user entity. We annotate the entity as follows:
Title,```typescript
Title,import { Exclude } from 'class-transformer';
Title,export class UserEntity {
Title,id: number;
Title,firstName: string;
Title,lastName: string;
Title,@Exclude()
Title,password: string;
Title,constructor(partial: Partial) {
Title,"Object.assign(this, partial);"
Title,}
Title,}
Title,```
Title,Now consider a controller with a method handler that returns an instance of this class.
Title,typescript
Title,@UseInterceptors(ClassSerializerInterceptor)
Title,@Get()
Title,findOne(): UserEntity {
Title,return new UserEntity({
Title,"id: 1,"
Title,"firstName: 'John',"
Title,"lastName: 'Doe',"
Title,"password: 'password',"
Title,});
Title,}
Title,
Title,"Warning Note that we must return an instance of the class. If you return a plain JavaScript object, for example, {{ '{' }} user: new UserEntity() {{ '}' }}, the object won't be properly serialized."
Title,info Hint The ClassSerializerInterceptor is imported from @nestjs/common.
Title,
Title,"When this endpoint is requested, the client receives the following response:"
Title,json
Title,{
Title,"""id"": 1,"
Title,"""firstName"": ""John"","
Title,"""lastName"": ""Doe"""
Title,}
Title,Note that the interceptor can be applied application-wide (as covered here). The combination of the interceptor and the entity class declaration ensures that any method that returns a UserEntity will be sure to remove the password property. This gives you a measure of centralized enforcement of this business rule.
Title,Expose properties
Title,"You can use the @Expose() decorator to provide alias names for properties, or to execute a function to calculate a property value (analogous to getter functions), as shown below."
Title,typescript
Title,@Expose()
Title,get fullName(): string {
Title,return `${this.firstName} ${this.lastName}`;
Title,}
Title,Transform
Title,"You can perform additional data transformation using the @Transform() decorator. For example, the following construct returns the name property of the RoleEntity instead of returning the whole object."
Title,typescript
Title,@Transform(({ value }) => value.name)
Title,role: RoleEntity;
Title,Pass options
Title,"You may want to modify the default behavior of the transformation functions. To override default settings, pass them in an options object with the @SerializeOptions() decorator."
Title,typescript
Title,@SerializeOptions({
Title,"excludePrefixes: ['_'],"
Title,})
Title,@Get()
Title,findOne(): UserEntity {
Title,return new UserEntity();
Title,}
Title,
Title,info Hint The @SerializeOptions() decorator is imported from @nestjs/common.
Title,
Title,"Options passed via @SerializeOptions() are passed as the second argument of the underlying instanceToPlain() function. In this example, we are automatically excluding all properties that begin with the _ prefix."
Title,Transform plain objects
Title,"You can enforce transformations at the controller level by using the @SerializeOptions decorator. This ensures that all responses are transformed into instances of the specified class, applying any decorators from class-validator or class-transformer, even when plain objects are returned. This approach leads to cleaner code without the need to repeatedly instantiate the class or call plainToInstance."
Title,"In the example below, despite returning plain JavaScript objects in both conditional branches, they will be automatically converted into UserEntity instances, with the relevant decorators applied:"
Title,```typescript
Title,@UseInterceptors(ClassSerializerInterceptor)
Title,@SerializeOptions({ type: UserEntity })
Title,@Get()
Title,findOne(@Query() { id }: { id: number }): UserEntity {
Title,if (id === 1) {
Title,return {
Title,"id: 1,"
Title,"firstName: 'John',"
Title,"lastName: 'Doe',"
Title,"password: 'password',"
Title,};
Title,}
Title,return {
Title,"id: 2,"
Title,"firstName: 'Kamil',"
Title,"lastName: 'Mysliwiec',"
Title,"password: 'password2',"
Title,};
Title,}
Title,```
Title,
Title,"info Hint By specifying the expected return type for the controller, you can leverage TypeScript's type-checking capabilities to ensure that the returned plain object adheres to the shape of the DTO or entity. The plainToInstance function doesn't provide this level of type hinting, which can lead to potential bugs if the plain object doesn't match the expected DTO or entity structure."
Title,
Title,Example
Title,A working example is available here.
Title,WebSockets and Microservices
Title,"While this chapter shows examples using HTTP style applications (e.g., Express or Fastify), the ClassSerializerInterceptor works the same for WebSockets and Microservices, regardless of the transport method that is used."
Title,Learn more
Title,Read more about available decorators and options as provided by the class-transformer package here.
Title,
Title,Server-Sent Events
Title,Server-Sent Events (SSE) is a server push technology enabling a client to receive automatic updates from a server via HTTP connection. Each notification is sent as a block of text terminated by a pair of newlines (learn more here).
Title,Usage
Title,"To enable Server-Sent events on a route (route registered within a controller class), annotate the method handler with the @Sse() decorator."
Title,typescript
Title,@Sse('sse')
Title,sse(): Observable<MessageEvent> {
Title,return interval(1000).pipe(map((_) => ({ data: { hello: 'world' } })));
Title,}
Title,
Title,"info Hint The @Sse() decorator and MessageEvent interface are imported from the @nestjs/common, while Observable, interval, and map are imported from the rxjs package."
Title,warning Warning Server-Sent Events routes must return an Observable stream.
Title,
Title,"In the example above, we defined a route named sse that will allow us to propagate real-time updates. These events can be listened to using the EventSource API."
Title,"The sse method returns an Observable that emits multiple MessageEvent (in this example, it emits a new MessageEvent every second). The MessageEvent object should respect the following interface to match the specification:"
Title,typescript
Title,export interface MessageEvent {
Title,data: string | object;
Title,id?: string;
Title,type?: string;
Title,retry?: number;
Title,}
Title,"With this in place, we can now create an instance of the EventSource class in our client-side application, passing the /sse route (which matches the endpoint we have passed into the @Sse() decorator above) as a constructor argument."
Title,"EventSource instance opens a persistent connection to an HTTP server, which sends events in text/event-stream format. The connection remains open until closed by calling EventSource.close()."
Title,"Once the connection is opened, incoming messages from the server are delivered to your code in the form of events. If there is an event field in the incoming message, the triggered event is the same as the event field value. If no event field is present, then a generic message event is fired (source)."
Title,javascript
Title,const eventSource = new EventSource('/sse');
Title,eventSource.onmessage = ({ data }) => {
Title,"console.log('New message', JSON.parse(data));"
Title,};
Title,Example
Title,A working example is available here.
Title,
Title,Session
Title,"HTTP sessions provide a way to store information about the user across multiple requests, which is particularly useful for MVC applications."
Title,Use with Express (default)
Title,First install the required package (and its types for TypeScript users):
Title,shell
Title,$ npm i express-session
Title,$ npm i -D @types/express-session
Title,"Once the installation is complete, apply the express-session middleware as global middleware (for example, in your main.ts file)."
Title,typescript
Title,import * as session from 'express-session';
Title,// somewhere in your initialization file
Title,app.use(
Title,session({
Title,"secret: 'my-secret',"
Title,"resave: false,"
Title,"saveUninitialized: false,"
Title,"}),"
Title,);
Title,
Title,"warning Notice The default server-side session storage is purposely not designed for a production environment. It will leak memory under most conditions, does not scale past a single process, and is meant for debugging and developing. Read more in the official repository."
Title,
Title,"The secret is used to sign the session ID cookie. This can be either a string for a single secret, or an array of multiple secrets. If an array of secrets is provided, only the first element will be used to sign the session ID cookie, while all the elements will be considered when verifying the signature in requests. The secret itself should be not easily parsed by a human and would best be a random set of characters."
Title,"Enabling the resave option forces the session to be saved back to the session store, even if the session was never modified during the request. The default value is true, but using the default has been deprecated, as the default will change in the future."
Title,"Likewise, enabling the saveUninitialized option Forces a session that is ""uninitialized"" to be saved to the store. A session is uninitialized when it is new but not modified. Choosing false is useful for implementing login sessions, reducing server storage usage, or complying with laws that require permission before setting a cookie. Choosing false will also help with race conditions where a client makes multiple parallel requests without a session (source)."
Title,"You can pass several other options to the session middleware, read more about them in the API documentation."
Title,
Title,"info Hint Please note that secure: true is a recommended option. However, it requires an https-enabled website, i.e., HTTPS is necessary for secure cookies. If secure is set, and you access your site over HTTP, the cookie will not be set. If you have your node.js behind a proxy and are using secure: true, you need to set ""trust proxy"" in express."
Title,
Title,"With this in place, you can now set and read session values from within the route handlers, as follows:"
Title,typescript
Title,@Get()
Title,findAll(@Req() request: Request) {
Title,request.session.visits = request.session.visits ? request.session.visits + 1 : 1;
Title,}
Title,
Title,"info Hint The @Req() decorator is imported from the @nestjs/common, while Request from the express package."
Title,
Title,"Alternatively, you can use the @Session() decorator to extract a session object from the request, as follows:"
Title,typescript
Title,@Get()
Title,"findAll(@Session() session: Record<string, any>) {"
Title,session.visits = session.visits ? session.visits + 1 : 1;
Title,}
Title,
Title,info Hint The @Session() decorator is imported from the @nestjs/common package.
Title,
Title,Use with Fastify
Title,First install the required package:
Title,shell
Title,$ npm i @fastify/secure-session
Title,"Once the installation is complete, register the fastify-secure-session plugin:"
Title,```typescript
Title,import secureSession from '@fastify/secure-session';
Title,// somewhere in your initialization file
Title,const app = await NestFactory.create(
Title,"AppModule,"
Title,"new FastifyAdapter(),"
Title,);
Title,"await app.register(secureSession, {"
Title,"secret: 'averylogphrasebiggerthanthirtytwochars',"
Title,"salt: 'mq9hDxBVDbspDR6n',"
Title,});
Title,```
Title,
Title,info Hint You can also pregenerate a key (see instructions) or use keys rotation.
Title,
Title,Read more about the available options in the official repository.
Title,"With this in place, you can now set and read session values from within the route handlers, as follows:"
Title,typescript
Title,@Get()
Title,findAll(@Req() request: FastifyRequest) {
Title,const visits = request.session.get('visits');
Title,"request.session.set('visits', visits ? visits + 1 : 1);"
Title,}
Title,"Alternatively, you can use the @Session() decorator to extract a session object from the request, as follows:"
Title,typescript
Title,@Get()
Title,findAll(@Session() session: secureSession.Session) {
Title,const visits = session.get('visits');
Title,"session.set('visits', visits ? visits + 1 : 1);"
Title,}
Title,
Title,"info Hint The @Session() decorator is imported from the @nestjs/common, while secureSession.Session from the @fastify/secure-session package (import statement: import * as secureSession from '@fastify/secure-session')."
Title,
Title,
Title,Database
Title,"Nest is database agnostic, allowing you to easily integrate with any SQL or NoSQL database. You have a number of options available to you, depending on your preferences. At the most general level, connecting Nest to a database is simply a matter of loading an appropriate Node.js driver for the database, just as you would with Express or Fastify."
Title,"You can also directly use any general purpose Node.js database integration library or ORM, such as MikroORM (see MikroORM recipe), Sequelize (see Sequelize integration), Knex.js (see Knex.js tutorial), TypeORM, and Prisma (see Prisma recipe), to operate at a higher level of abstraction."
Title,"For convenience, Nest provides tight integration with TypeORM and Sequelize out-of-the-box with the @nestjs/typeorm and @nestjs/sequelize packages respectively, which we'll cover in the current chapter, and Mongoose with @nestjs/mongoose, which is covered in this chapter. These integrations provide additional NestJS-specific features, such as model/repository injection, testability, and asynchronous configuration to make accessing your chosen database even easier."
Title,TypeORM Integration
Title,"For integrating with SQL and NoSQL databases, Nest provides the @nestjs/typeorm package. TypeORM is the most mature Object Relational Mapper (ORM) available for TypeScript. Since it's written in TypeScript, it integrates well with the Nest framework."
Title,"To begin using it, we first install the required dependencies. In this chapter, we'll demonstrate using the popular MySQL Relational DBMS, but TypeORM provides support for many relational databases, such as PostgreSQL, Oracle, Microsoft SQL Server, SQLite, and even NoSQL databases like MongoDB. The procedure we walk through in this chapter will be the same for any database supported by TypeORM. You'll simply need to install the associated client API libraries for your selected database."
Title,bash
Title,$ npm install --save @nestjs/typeorm typeorm mysql2
Title,"Once the installation process is complete, we can import the TypeOrmModule into the root AppModule."
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { TypeOrmModule } from '@nestjs/typeorm';
Title,@Module({
Title,imports: [
Title,TypeOrmModule.forRoot({
Title,"type: 'mysql',"
Title,"host: 'localhost',"
Title,"port: 3306,"
Title,"username: 'root',"
Title,"password: 'root',"
Title,"database: 'test',"
Title,"entities: [],"
Title,"synchronize: true,"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,
Title,warning Warning Setting synchronize: true shouldn't be used in production - otherwise you can lose production data.
Title,
Title,"The forRoot() method supports all the configuration properties exposed by the DataSource constructor from the TypeORM package. In addition, there are several extra configuration properties described below."
Title,
Title,
Title,retryAttempts
Title,Number of attempts to connect to the database (default: 10)
Title,
Title,
Title,retryDelay
Title,Delay between connection retry attempts (ms) (default: 3000)
Title,
Title,
Title,autoLoadEntities
Title,"If true, entities will be loaded automatically (default: false)"
Title,
Title,
Title,
Title,info Hint Learn more about the data source options here.
Title,
Title,"Once this is done, the TypeORM DataSource and EntityManager objects will be available to inject across the entire project (without needing to import any modules), for example:"
Title,```typescript
Title,@@filename(app.module)
Title,import { DataSource } from 'typeorm';
Title,@Module({
Title,"imports: [TypeOrmModule.forRoot(), UsersModule],"
Title,})
Title,export class AppModule {
Title,constructor(private dataSource: DataSource) {}
Title,}
Title,@@switch
Title,import { DataSource } from 'typeorm';
Title,@Dependencies(DataSource)
Title,@Module({
Title,"imports: [TypeOrmModule.forRoot(), UsersModule],"
Title,})
Title,export class AppModule {
Title,constructor(dataSource) {
Title,this.dataSource = dataSource;
Title,}
Title,}
Title,```
Title,Repository pattern
Title,"TypeORM supports the repository design pattern, so each entity has its own repository. These repositories can be obtained from the database data source."
Title,"To continue the example, we need at least one entity. Let's define the User entity."
Title,```typescript
Title,@@filename(user.entity)
Title,"import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';"
Title,@Entity()
Title,export class User {
Title,@PrimaryGeneratedColumn()
Title,id: number;
Title,@Column()
Title,firstName: string;
Title,@Column()
Title,lastName: string;
Title,@Column({ default: true })
Title,isActive: boolean;
Title,}
Title,```
Title,
Title,info Hint Learn more about entities in the TypeORM documentation.
Title,
Title,"The User entity file sits in the users directory. This directory contains all files related to the UsersModule. You can decide where to keep your model files, however, we recommend creating them near their domain, in the corresponding module directory."
Title,"To begin using the User entity, we need to let TypeORM know about it by inserting it into the entities array in the module forRoot() method options (unless you use a static glob path):"
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { TypeOrmModule } from '@nestjs/typeorm';
Title,import { User } from './users/user.entity';
Title,@Module({
Title,imports: [
Title,TypeOrmModule.forRoot({
Title,"type: 'mysql',"
Title,"host: 'localhost',"
Title,"port: 3306,"
Title,"username: 'root',"
Title,"password: 'root',"
Title,"database: 'test',"
Title,"entities: [User],"
Title,"synchronize: true,"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,"Next, let's look at the UsersModule:"
Title,```typescript
Title,@@filename(users.module)
Title,import { Module } from '@nestjs/common';
Title,import { TypeOrmModule } from '@nestjs/typeorm';
Title,import { UsersService } from './users.service';
Title,import { UsersController } from './users.controller';
Title,import { User } from './user.entity';
Title,@Module({
Title,"imports: [TypeOrmModule.forFeature([User])],"
Title,"providers: [UsersService],"
Title,"controllers: [UsersController],"
Title,})
Title,export class UsersModule {}
Title,```
Title,"This module uses the forFeature() method to define which repositories are registered in the current scope. With that in place, we can inject the UsersRepository into the UsersService using the @InjectRepository() decorator:"
Title,```typescript
Title,@@filename(users.service)
Title,import { Injectable } from '@nestjs/common';
Title,import { InjectRepository } from '@nestjs/typeorm';
Title,import { Repository } from 'typeorm';
Title,import { User } from './user.entity';
Title,@Injectable()
Title,export class UsersService {
Title,constructor(
Title,@InjectRepository(User)
Title,"private usersRepository: Repository,"
Title,) {}
Title,findAll(): Promise {
Title,return this.usersRepository.find();
Title,}
Title,findOne(id: number): Promise {
Title,return this.usersRepository.findOneBy({ id });
Title,}
Title,async remove(id: number): Promise {
Title,await this.usersRepository.delete(id);
Title,}
Title,}
Title,@@switch
Title,"import { Injectable, Dependencies } from '@nestjs/common';"
Title,import { getRepositoryToken } from '@nestjs/typeorm';
Title,import { User } from './user.entity';
Title,@Injectable()
Title,@Dependencies(getRepositoryToken(User))
Title,export class UsersService {
Title,constructor(usersRepository) {
Title,this.usersRepository = usersRepository;
Title,}
Title,findAll() {
Title,return this.usersRepository.find();
Title,}
Title,findOne(id) {
Title,return this.usersRepository.findOneBy({ id });
Title,}
Title,async remove(id) {
Title,await this.usersRepository.delete(id);
Title,}
Title,}
Title,```
Title,
Title,warning Notice Don't forget to import the UsersModule into the root AppModule.
Title,
Title,"If you want to use the repository outside of the module which imports TypeOrmModule.forFeature, you'll need to re-export the providers generated by it."
Title,"You can do this by exporting the whole module, like this:"
Title,```typescript
Title,@@filename(users.module)
Title,import { Module } from '@nestjs/common';
Title,import { TypeOrmModule } from '@nestjs/typeorm';
Title,import { User } from './user.entity';
Title,@Module({
Title,"imports: [TypeOrmModule.forFeature([User])],"
Title,exports: [TypeOrmModule]
Title,})
Title,export class UsersModule {}
Title,```
Title,"Now if we import UsersModule in UserHttpModule, we can use @InjectRepository(User) in the providers of the latter module."
Title,```typescript
Title,@@filename(users-http.module)
Title,import { Module } from '@nestjs/common';
Title,import { UsersModule } from './users.module';
Title,import { UsersService } from './users.service';
Title,import { UsersController } from './users.controller';
Title,@Module({
Title,"imports: [UsersModule],"
Title,"providers: [UsersService],"
Title,controllers: [UsersController]
Title,})
Title,export class UserHttpModule {}
Title,```
Title,Relations
Title,"Relations are associations established between two or more tables. Relations are based on common fields from each table, often involving primary and foreign keys."
Title,There are three types of relations:
Title,
Title,
Title,One-to-one
Title,Every row in the primary table has one and only one associated row in the foreign table.  Use the @OneToOne() decorator to define this type of relation.
Title,
Title,
Title,One-to-many / Many-to-one
Title,Every row in the primary table has one or more related rows in the foreign table. Use the @OneToMany() and @ManyToOne() decorators to define this type of relation.
Title,
Title,
Title,Many-to-many
Title,"Every row in the primary table has many related rows in the foreign table, and every record in the foreign table has many related rows in the primary table. Use the @ManyToMany() decorator to define this type of relation."
Title,
Title,
Title,"To define relations in entities, use the corresponding decorators. For example, to define that each User can have multiple photos, use the @OneToMany() decorator."
Title,```typescript
Title,@@filename(user.entity)
Title,"import { Entity, Column, PrimaryGeneratedColumn, OneToMany } from 'typeorm';"
Title,import { Photo } from '../photos/photo.entity';
Title,@Entity()
Title,export class User {
Title,@PrimaryGeneratedColumn()
Title,id: number;
Title,@Column()
Title,firstName: string;
Title,@Column()
Title,lastName: string;
Title,@Column({ default: true })
Title,isActive: boolean;
Title,"@OneToMany(type => Photo, photo => photo.user)"
Title,photos: Photo[];
Title,}
Title,```
Title,
Title,"info Hint To learn more about relations in TypeORM, visit the TypeORM documentation."
Title,
Title,Auto-load entities
Title,"Manually adding entities to the entities array of the data source options can be tedious. In addition, referencing entities from the root module breaks application domain boundaries and causes leaking implementation details to other parts of the application. To address this issue, an alternative solution is provided. To automatically load entities, set the autoLoadEntities property of the configuration object (passed into the forRoot() method) to true, as shown below:"
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { TypeOrmModule } from '@nestjs/typeorm';
Title,@Module({
Title,imports: [
Title,TypeOrmModule.forRoot({
Title,...
Title,"autoLoadEntities: true,"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,"With that option specified, every entity registered through the forFeature() method will be automatically added to the entities array of the configuration object."
Title,
Title,"warning Warning Note that entities that aren't registered through the forFeature() method, but are only referenced from the entity (via a relationship), won't be included by way of the autoLoadEntities setting."
Title,
Title,Separating entity definition
Title,"You can define an entity and its columns right in the model, using decorators. But some people prefer to define entities and their columns inside separate files using the ""entity schemas""."
Title,```typescript
Title,import { EntitySchema } from 'typeorm';
Title,import { User } from './user.entity';
Title,export const UserSchema = new EntitySchema({
Title,"name: 'User',"
Title,"target: User,"
Title,columns: {
Title,id: {
Title,"type: Number,"
Title,"primary: true,"
Title,"generated: true,"
Title,"},"
Title,firstName: {
Title,"type: String,"
Title,"},"
Title,lastName: {
Title,"type: String,"
Title,"},"
Title,isActive: {
Title,"type: Boolean,"
Title,"default: true,"
Title,"},"
Title,"},"
Title,relations: {
Title,photos: {
Title,"type: 'one-to-many',"
Title,"target: 'Photo', // the name of the PhotoSchema"
Title,"},"
Title,"},"
Title,});
Title,```
Title,
Title,"warning error Warning If you provide the target option, the name option value has to be the same as the name of the target class."
Title,If you do not provide the target you can use any name.
Title,
Title,"Nest allows you to use an EntitySchema instance wherever an Entity is expected, for example:"
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { TypeOrmModule } from '@nestjs/typeorm';
Title,import { UserSchema } from './user.schema';
Title,import { UsersController } from './users.controller';
Title,import { UsersService } from './users.service';
Title,@Module({
Title,"imports: [TypeOrmModule.forFeature([UserSchema])],"
Title,"providers: [UsersService],"
Title,"controllers: [UsersController],"
Title,})
Title,export class UsersModule {}
Title,```
Title,TypeORM Transactions
Title,"A database transaction symbolizes a unit of work performed within a database management system against a database, and treated in a coherent and reliable way independent of other transactions. A transaction generally represents any change in a database (learn more)."
Title,There are many different strategies to handle TypeORM transactions. We recommend using the QueryRunner class because it gives full control over the transaction.
Title,"First, we need to inject the DataSource object into a class in the normal way:"
Title,typescript
Title,@Injectable()
Title,export class UsersService {
Title,constructor(private dataSource: DataSource) {}
Title,}
Title,
Title,info Hint The DataSource class is imported from the typeorm package.
Title,
Title,"Now, we can use this object to create a transaction."
Title,```typescript
Title,async createMany(users: User[]) {
Title,const queryRunner = this.dataSource.createQueryRunner();
Title,await queryRunner.connect();
Title,await queryRunner.startTransaction();
Title,try {
Title,await queryRunner.manager.save(users[0]);
Title,await queryRunner.manager.save(users[1]);
Title,await queryRunner.commitTransaction();
Title,
Title,} catch (err) {
Title,// since we have errors lets rollback the changes we made
Title,await queryRunner.rollbackTransaction();
Title,} finally {
Title,// you need to release a queryRunner which was manually instantiated
Title,await queryRunner.release();
Title,}
Title,}
Title,```
Title,
Title,"info Hint Note that the dataSource is used only to create the QueryRunner. However, to test this class would require mocking the entire DataSource object (which exposes several methods). Thus, we recommend using a helper factory class (e.g., QueryRunnerFactory) and defining an interface with a limited set of methods required to maintain transactions. This technique makes mocking these methods pretty straightforward."
Title,
Title,
Title,"Alternatively, you can use the callback-style approach with the transaction method of the DataSource object (read more)."
Title,typescript
Title,async createMany(users: User[]) {
Title,await this.dataSource.transaction(async manager => {
Title,await manager.save(users[0]);
Title,await manager.save(users[1]);
Title,});
Title,}
Title,Subscribers
Title,"With TypeORM subscribers, you can listen to specific entity events."
Title,```typescript
Title,import {
Title,"DataSource,"
Title,"EntitySubscriberInterface,"
Title,"EventSubscriber,"
Title,"InsertEvent,"
Title,} from 'typeorm';
Title,import { User } from './user.entity';
Title,@EventSubscriber()
Title,export class UserSubscriber implements EntitySubscriberInterface {
Title,constructor(dataSource: DataSource) {
Title,dataSource.subscribers.push(this);
Title,}
Title,listenTo() {
Title,return User;
Title,}
Title,beforeInsert(event: InsertEvent) {
Title,"console.log(BEFORE USER INSERTED:, event.entity);"
Title,}
Title,}
Title,```
Title,
Title,error Warning Event subscribers can not be request-scoped.
Title,
Title,"Now, add the UserSubscriber class to the providers array:"
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { TypeOrmModule } from '@nestjs/typeorm';
Title,import { User } from './user.entity';
Title,import { UsersController } from './users.controller';
Title,import { UsersService } from './users.service';
Title,import { UserSubscriber } from './user.subscriber';
Title,@Module({
Title,"imports: [TypeOrmModule.forFeature([User])],"
Title,"providers: [UsersService, UserSubscriber],"
Title,"controllers: [UsersController],"
Title,})
Title,export class UsersModule {}
Title,```
Title,
Title,info Hint Learn more about entity subscribers here.
Title,
Title,Migrations
Title,"Migrations provide a way to incrementally update the database schema to keep it in sync with the application's data model while preserving existing data in the database. To generate, run, and revert migrations, TypeORM provides a dedicated CLI."
Title,"Migration classes are separate from the Nest application source code. Their lifecycle is maintained by the TypeORM CLI. Therefore, you are not able to leverage dependency injection and other Nest specific features with migrations. To learn more about migrations, follow the guide in the TypeORM documentation."
Title,Multiple databases
Title,"Some projects require multiple database connections. This can also be achieved with this module. To work with multiple connections, first create the connections. In this case, data source naming becomes mandatory."
Title,Suppose you have an Album entity stored in its own database.
Title,```typescript
Title,const defaultOptions = {
Title,"type: 'postgres',"
Title,"port: 5432,"
Title,"username: 'user',"
Title,"password: 'password',"
Title,"database: 'db',"
Title,"synchronize: true,"
Title,};
Title,@Module({
Title,imports: [
Title,TypeOrmModule.forRoot({
Title,"...defaultOptions,"
Title,"host: 'user_db_host',"
Title,"entities: [User],"
Title,"}),"
Title,TypeOrmModule.forRoot({
Title,"...defaultOptions,"
Title,"name: 'albumsConnection',"
Title,"host: 'album_db_host',"
Title,"entities: [Album],"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,
Title,"warning Notice If you don't set the name for a data source, its name is set to default. Please note that you shouldn't have multiple connections without a name, or with the same name, otherwise they will get overridden."
Title,"warning Notice If you are using TypeOrmModule.forRootAsync, you have to also set the data source name outside useFactory. For example:"
Title,typescript
Title,TypeOrmModule.forRootAsync({
Title,"name: 'albumsConnection',"
Title,"useFactory: ...,"
Title,"inject: ...,"
Title,"}),"
Title,See this issue for more details.
Title,
Title,"At this point, you have User and Album entities registered with their own data source. With this setup, you have to tell the TypeOrmModule.forFeature() method and the @InjectRepository() decorator which data source should be used. If you do not pass any data source name, the default data source is used."
Title,typescript
Title,@Module({
Title,imports: [
Title,"TypeOrmModule.forFeature([User]),"
Title,"TypeOrmModule.forFeature([Album], 'albumsConnection'),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,You can also inject the DataSource or EntityManager for a given data source:
Title,typescript
Title,@Injectable()
Title,export class AlbumsService {
Title,constructor(
Title,@InjectDataSource('albumsConnection')
Title,"private dataSource: DataSource,"
Title,@InjectEntityManager('albumsConnection')
Title,"private entityManager: EntityManager,"
Title,) {}
Title,}
Title,It's also possible to inject any DataSource to the providers:
Title,typescript
Title,@Module({
Title,providers: [
Title,{
Title,"provide: AlbumsService,"
Title,useFactory: (albumsConnection: DataSource) => {
Title,return new AlbumsService(albumsConnection);
Title,"},"
Title,"inject: [getDataSourceToken('albumsConnection')],"
Title,"},"
Title,"],"
Title,})
Title,export class AlbumsModule {}
Title,Testing
Title,"When it comes to unit testing an application, we usually want to avoid making a database connection, keeping our test suites independent and their execution process as fast as possible. But our classes might depend on repositories that are pulled from the data source (connection) instance. How do we handle that? The solution is to create mock repositories. In order to achieve that, we set up custom providers. Each registered repository is automatically represented by an <EntityName>Repository token, where EntityName is the name of your entity class."
Title,The @nestjs/typeorm package exposes the getRepositoryToken() function which returns a prepared token based on a given entity.
Title,typescript
Title,@Module({
Title,providers: [
Title,"UsersService,"
Title,{
Title,"provide: getRepositoryToken(User),"
Title,"useValue: mockRepository,"
Title,"},"
Title,"],"
Title,})
Title,export class UsersModule {}
Title,"Now a substitute mockRepository will be used as the UsersRepository. Whenever any class asks for UsersRepository using an @InjectRepository() decorator, Nest will use the registered mockRepository object."
Title,Async configuration
Title,"You may want to pass your repository module options asynchronously instead of statically. In this case, use the forRootAsync() method, which provides several ways to deal with async configuration."
Title,One approach is to use a factory function:
Title,typescript
Title,TypeOrmModule.forRootAsync({
Title,useFactory: () => ({
Title,"type: 'mysql',"
Title,"host: 'localhost',"
Title,"port: 3306,"
Title,"username: 'root',"
Title,"password: 'root',"
Title,"database: 'test',"
Title,"entities: [],"
Title,"synchronize: true,"
Title,"}),"
Title,});
Title,"Our factory behaves like any other asynchronous provider (e.g., it can be async and it's able to inject dependencies through inject)."
Title,typescript
Title,TypeOrmModule.forRootAsync({
Title,"imports: [ConfigModule],"
Title,useFactory: (configService: ConfigService) => ({
Title,"type: 'mysql',"
Title,"host: configService.get('HOST'),"
Title,"port: +configService.get('PORT'),"
Title,"username: configService.get('USERNAME'),"
Title,"password: configService.get('PASSWORD'),"
Title,"database: configService.get('DATABASE'),"
Title,"entities: [],"
Title,"synchronize: true,"
Title,"}),"
Title,"inject: [ConfigService],"
Title,});
Title,"Alternatively, you can use the useClass syntax:"
Title,typescript
Title,TypeOrmModule.forRootAsync({
Title,"useClass: TypeOrmConfigService,"
Title,});
Title,"The construction above will instantiate TypeOrmConfigService inside TypeOrmModule and use it to provide an options object by calling createTypeOrmOptions(). Note that this means that the TypeOrmConfigService has to implement the TypeOrmOptionsFactory interface, as shown below:"
Title,typescript
Title,@Injectable()
Title,export class TypeOrmConfigService implements TypeOrmOptionsFactory {
Title,createTypeOrmOptions(): TypeOrmModuleOptions {
Title,return {
Title,"type: 'mysql',"
Title,"host: 'localhost',"
Title,"port: 3306,"
Title,"username: 'root',"
Title,"password: 'root',"
Title,"database: 'test',"
Title,"entities: [],"
Title,"synchronize: true,"
Title,};
Title,}
Title,}
Title,"In order to prevent the creation of TypeOrmConfigService inside TypeOrmModule and use a provider imported from a different module, you can use the useExisting syntax."
Title,typescript
Title,TypeOrmModule.forRootAsync({
Title,"imports: [ConfigModule],"
Title,"useExisting: ConfigService,"
Title,});
Title,This construction works the same as useClass with one critical difference - TypeOrmModule will lookup imported modules to reuse an existing ConfigService instead of instantiating a new one.
Title,
Title,"info Hint Make sure that the name property is defined at the same level as the useFactory, useClass, or useValue property. This will allow Nest to properly register the data source under the appropriate injection token."
Title,
Title,Custom DataSource Factory
Title,"In conjunction with async configuration using useFactory, useClass, or useExisting, you can optionally specify a dataSourceFactory function which will allow you to provide your own TypeORM data source rather than allowing TypeOrmModule to create the data source."
Title,"dataSourceFactory receives the TypeORM DataSourceOptions configured during async configuration using useFactory, useClass, or useExisting and returns a Promise that resolves a TypeORM DataSource."
Title,typescript
Title,TypeOrmModule.forRootAsync({
Title,"imports: [ConfigModule],"
Title,"inject: [ConfigService],"
Title,"// Use useFactory, useClass, or useExisting"
Title,// to configure the DataSourceOptions.
Title,useFactory: (configService: ConfigService) => ({
Title,"type: 'mysql',"
Title,"host: configService.get('HOST'),"
Title,"port: +configService.get('PORT'),"
Title,"username: configService.get('USERNAME'),"
Title,"password: configService.get('PASSWORD'),"
Title,"database: configService.get('DATABASE'),"
Title,"entities: [],"
Title,"synchronize: true,"
Title,"}),"
Title,// dataSource receives the configured DataSourceOptions
Title,// and returns a Promise<DataSource>.
Title,dataSourceFactory: async (options) => {
Title,const dataSource = await new DataSource(options).initialize();
Title,return dataSource;
Title,"},"
Title,});
Title,
Title,info Hint The DataSource class is imported from the typeorm package.
Title,
Title,Example
Title,A working example is available here.
Title,
Title,Sequelize Integration
Title,"An alternative to using TypeORM is to use the Sequelize ORM with the @nestjs/sequelize package. In addition, we leverage the sequelize-typescript package which provides a set of additional decorators to declaratively define entities."
Title,"To begin using it, we first install the required dependencies. In this chapter, we'll demonstrate using the popular MySQL Relational DBMS, but Sequelize provides support for many relational databases, such as PostgreSQL, MySQL, Microsoft SQL Server, SQLite, and MariaDB. The procedure we walk through in this chapter will be the same for any database supported by Sequelize. You'll simply need to install the associated client API libraries for your selected database."
Title,bash
Title,$ npm install --save @nestjs/sequelize sequelize sequelize-typescript mysql2
Title,$ npm install --save-dev @types/sequelize
Title,"Once the installation process is complete, we can import the SequelizeModule into the root AppModule."
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { SequelizeModule } from '@nestjs/sequelize';
Title,@Module({
Title,imports: [
Title,SequelizeModule.forRoot({
Title,"dialect: 'mysql',"
Title,"host: 'localhost',"
Title,"port: 3306,"
Title,"username: 'root',"
Title,"password: 'root',"
Title,"database: 'test',"
Title,"models: [],"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,"The forRoot() method supports all the configuration properties exposed by the Sequelize constructor (read more). In addition, there are several extra configuration properties described below."
Title,
Title,
Title,retryAttempts
Title,Number of attempts to connect to the database (default: 10)
Title,
Title,
Title,retryDelay
Title,Delay between connection retry attempts (ms) (default: 3000)
Title,
Title,
Title,autoLoadModels
Title,"If true, models will be loaded automatically (default: false)"
Title,
Title,
Title,keepConnectionAlive
Title,"If true, connection will not be closed on the application shutdown (default: false)"
Title,
Title,
Title,synchronize
Title,"If true, automatically loaded models will be synchronized (default: true)"
Title,
Title,
Title,"Once this is done, the Sequelize object will be available to inject across the entire project (without needing to import any modules), for example:"
Title,```typescript
Title,@@filename(app.service)
Title,import { Injectable } from '@nestjs/common';
Title,import { Sequelize } from 'sequelize-typescript';
Title,@Injectable()
Title,export class AppService {
Title,constructor(private sequelize: Sequelize) {}
Title,}
Title,@@switch
Title,import { Injectable } from '@nestjs/common';
Title,import { Sequelize } from 'sequelize-typescript';
Title,@Dependencies(Sequelize)
Title,@Injectable()
Title,export class AppService {
Title,constructor(sequelize) {
Title,this.sequelize = sequelize;
Title,}
Title,}
Title,```
Title,Models
Title,"Sequelize implements the Active Record pattern. With this pattern, you use model classes directly to interact with the database. To continue the example, we need at least one model. Let's define the User model."
Title,```typescript
Title,@@filename(user.model)
Title,"import { Column, Model, Table } from 'sequelize-typescript';"
Title,@Table
Title,export class User extends Model {
Title,@Column
Title,firstName: string;
Title,@Column
Title,lastName: string;
Title,@Column({ defaultValue: true })
Title,isActive: boolean;
Title,}
Title,```
Title,
Title,info Hint Learn more about the available decorators here.
Title,
Title,"The User model file sits in the users directory. This directory contains all files related to the UsersModule. You can decide where to keep your model files, however, we recommend creating them near their domain, in the corresponding module directory."
Title,"To begin using the User model, we need to let Sequelize know about it by inserting it into the models array in the module forRoot() method options:"
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { SequelizeModule } from '@nestjs/sequelize';
Title,import { User } from './users/user.model';
Title,@Module({
Title,imports: [
Title,SequelizeModule.forRoot({
Title,"dialect: 'mysql',"
Title,"host: 'localhost',"
Title,"port: 3306,"
Title,"username: 'root',"
Title,"password: 'root',"
Title,"database: 'test',"
Title,"models: [User],"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,"Next, let's look at the UsersModule:"
Title,```typescript
Title,@@filename(users.module)
Title,import { Module } from '@nestjs/common';
Title,import { SequelizeModule } from '@nestjs/sequelize';
Title,import { User } from './user.model';
Title,import { UsersController } from './users.controller';
Title,import { UsersService } from './users.service';
Title,@Module({
Title,"imports: [SequelizeModule.forFeature([User])],"
Title,"providers: [UsersService],"
Title,"controllers: [UsersController],"
Title,})
Title,export class UsersModule {}
Title,```
Title,"This module uses the forFeature() method to define which models are registered in the current scope. With that in place, we can inject the UserModel into the UsersService using the @InjectModel() decorator:"
Title,```typescript
Title,@@filename(users.service)
Title,import { Injectable } from '@nestjs/common';
Title,import { InjectModel } from '@nestjs/sequelize';
Title,import { User } from './user.model';
Title,@Injectable()
Title,export class UsersService {
Title,constructor(
Title,@InjectModel(User)
Title,"private userModel: typeof User,"
Title,) {}
Title,async findAll(): Promise {
Title,return this.userModel.findAll();
Title,}
Title,findOne(id: string): Promise {
Title,return this.userModel.findOne({
Title,where: {
Title,"id,"
Title,"},"
Title,});
Title,}
Title,async remove(id: string): Promise {
Title,const user = await this.findOne(id);
Title,await user.destroy();
Title,}
Title,}
Title,@@switch
Title,"import { Injectable, Dependencies } from '@nestjs/common';"
Title,import { getModelToken } from '@nestjs/sequelize';
Title,import { User } from './user.model';
Title,@Injectable()
Title,@Dependencies(getModelToken(User))
Title,export class UsersService {
Title,constructor(usersRepository) {
Title,this.usersRepository = usersRepository;
Title,}
Title,async findAll() {
Title,return this.userModel.findAll();
Title,}
Title,findOne(id) {
Title,return this.userModel.findOne({
Title,where: {
Title,"id,"
Title,"},"
Title,});
Title,}
Title,async remove(id) {
Title,const user = await this.findOne(id);
Title,await user.destroy();
Title,}
Title,}
Title,```
Title,
Title,warning Notice Don't forget to import the UsersModule into the root AppModule.
Title,
Title,"If you want to use the repository outside of the module which imports SequelizeModule.forFeature, you'll need to re-export the providers generated by it."
Title,"You can do this by exporting the whole module, like this:"
Title,```typescript
Title,@@filename(users.module)
Title,import { Module } from '@nestjs/common';
Title,import { SequelizeModule } from '@nestjs/sequelize';
Title,import { User } from './user.entity';
Title,@Module({
Title,"imports: [SequelizeModule.forFeature([User])],"
Title,exports: [SequelizeModule]
Title,})
Title,export class UsersModule {}
Title,```
Title,"Now if we import UsersModule in UserHttpModule, we can use @InjectModel(User) in the providers of the latter module."
Title,```typescript
Title,@@filename(users-http.module)
Title,import { Module } from '@nestjs/common';
Title,import { UsersModule } from './users.module';
Title,import { UsersService } from './users.service';
Title,import { UsersController } from './users.controller';
Title,@Module({
Title,"imports: [UsersModule],"
Title,"providers: [UsersService],"
Title,controllers: [UsersController]
Title,})
Title,export class UserHttpModule {}
Title,```
Title,Relations
Title,"Relations are associations established between two or more tables. Relations are based on common fields from each table, often involving primary and foreign keys."
Title,There are three types of relations:
Title,
Title,
Title,One-to-one
Title,Every row in the primary table has one and only one associated row in the foreign table
Title,
Title,
Title,One-to-many / Many-to-one
Title,Every row in the primary table has one or more related rows in the foreign table
Title,
Title,
Title,Many-to-many
Title,"Every row in the primary table has many related rows in the foreign table, and every record in the foreign table has many related rows in the primary table"
Title,
Title,
Title,"To define relations in models, use the corresponding decorators. For example, to define that each User can have multiple photos, use the @HasMany() decorator."
Title,```typescript
Title,@@filename(user.model)
Title,"import { Column, Model, Table, HasMany } from 'sequelize-typescript';"
Title,import { Photo } from '../photos/photo.model';
Title,@Table
Title,export class User extends Model {
Title,@Column
Title,firstName: string;
Title,@Column
Title,lastName: string;
Title,@Column({ defaultValue: true })
Title,isActive: boolean;
Title,@HasMany(() => Photo)
Title,photos: Photo[];
Title,}
Title,```
Title,
Title,"info Hint To learn more about associations in Sequelize, read this chapter."
Title,
Title,Auto-load models
Title,"Manually adding models to the models array of the connection options can be tedious. In addition, referencing models from the root module breaks application domain boundaries and causes leaking implementation details to other parts of the application. To solve this issue, automatically load models by setting both autoLoadModels and synchronize properties of the configuration object (passed into the forRoot() method) to true, as shown below:"
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { SequelizeModule } from '@nestjs/sequelize';
Title,@Module({
Title,imports: [
Title,SequelizeModule.forRoot({
Title,...
Title,"autoLoadModels: true,"
Title,"synchronize: true,"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,"With that option specified, every model registered through the forFeature() method will be automatically added to the models array of the configuration object."
Title,
Title,"warning Warning Note that models that aren't registered through the forFeature() method, but are only referenced from the model (via an association), won't be included."
Title,
Title,Sequelize Transactions
Title,"A database transaction symbolizes a unit of work performed within a database management system against a database, and treated in a coherent and reliable way independent of other transactions. A transaction generally represents any change in a database (learn more)."
Title,There are many different strategies to handle Sequelize transactions. Below is a sample implementation of a managed transaction (auto-callback).
Title,"First, we need to inject the Sequelize object into a class in the normal way:"
Title,typescript
Title,@Injectable()
Title,export class UsersService {
Title,constructor(private sequelize: Sequelize) {}
Title,}
Title,
Title,info Hint The Sequelize class is imported from the sequelize-typescript package.
Title,
Title,"Now, we can use this object to create a transaction."
Title,```typescript
Title,async createMany() {
Title,try {
Title,await this.sequelize.transaction(async t => {
Title,const transactionHost = { transaction: t };
Title,await this.userModel.create(
Title,"{ firstName: 'Abraham', lastName: 'Lincoln' },"
Title,"transactionHost,"
Title,);
Title,await this.userModel.create(
Title,"{ firstName: 'John', lastName: 'Boothe' },"
Title,"transactionHost,"
Title,);
Title,});
Title,
Title,} catch (err) {
Title,// Transaction has been rolled back
Title,// err is whatever rejected the promise chain returned to the transaction callback
Title,}
Title,}
Title,```
Title,
Title,"info Hint Note that the Sequelize instance is used only to start the transaction. However, to test this class would require mocking the entire Sequelize object (which exposes several methods). Thus, we recommend using a helper factory class (e.g., TransactionRunner) and defining an interface with a limited set of methods required to maintain transactions. This technique makes mocking these methods pretty straightforward."
Title,
Title,Migrations
Title,"Migrations provide a way to incrementally update the database schema to keep it in sync with the application's data model while preserving existing data in the database. To generate, run, and revert migrations, Sequelize provides a dedicated CLI."
Title,"Migration classes are separate from the Nest application source code. Their lifecycle is maintained by the Sequelize CLI. Therefore, you are not able to leverage dependency injection and other Nest specific features with migrations. To learn more about migrations, follow the guide in the Sequelize documentation."
Title,
Title,Multiple databases
Title,"Some projects require multiple database connections. This can also be achieved with this module. To work with multiple connections, first create the connections. In this case, connection naming becomes mandatory."
Title,Suppose you have an Album entity stored in its own database.
Title,```typescript
Title,const defaultOptions = {
Title,"dialect: 'postgres',"
Title,"port: 5432,"
Title,"username: 'user',"
Title,"password: 'password',"
Title,"database: 'db',"
Title,"synchronize: true,"
Title,};
Title,@Module({
Title,imports: [
Title,SequelizeModule.forRoot({
Title,"...defaultOptions,"
Title,"host: 'user_db_host',"
Title,"models: [User],"
Title,"}),"
Title,SequelizeModule.forRoot({
Title,"...defaultOptions,"
Title,"name: 'albumsConnection',"
Title,"host: 'album_db_host',"
Title,"models: [Album],"
Title,"}),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,
Title,"warning Notice If you don't set the name for a connection, its name is set to default. Please note that you shouldn't have multiple connections without a name, or with the same name, otherwise they will get overridden."
Title,
Title,"At this point, you have User and Album models registered with their own connection. With this setup, you have to tell the SequelizeModule.forFeature() method and the @InjectModel() decorator which connection should be used. If you do not pass any connection name, the default connection is used."
Title,typescript
Title,@Module({
Title,imports: [
Title,"SequelizeModule.forFeature([User]),"
Title,"SequelizeModule.forFeature([Album], 'albumsConnection'),"
Title,"],"
Title,})
Title,export class AppModule {}
Title,You can also inject the Sequelize instance for a given connection:
Title,typescript
Title,@Injectable()
Title,export class AlbumsService {
Title,constructor(
Title,@InjectConnection('albumsConnection')
Title,"private sequelize: Sequelize,"
Title,) {}
Title,}
Title,It's also possible to inject any Sequelize instance to the providers:
Title,typescript
Title,@Module({
Title,providers: [
Title,{
Title,"provide: AlbumsService,"
Title,useFactory: (albumsSequelize: Sequelize) => {
Title,return new AlbumsService(albumsSequelize);
Title,"},"
Title,"inject: [getDataSourceToken('albumsConnection')],"
Title,"},"
Title,"],"
Title,})
Title,export class AlbumsModule {}
Title,Testing
Title,"When it comes to unit testing an application, we usually want to avoid making a database connection, keeping our test suites independent and their execution process as fast as possible. But our classes might depend on models that are pulled from the connection instance. How do we handle that? The solution is to create mock models. In order to achieve that, we set up custom providers. Each registered model is automatically represented by a <ModelName>Model token, where ModelName is the name of your model class."
Title,The @nestjs/sequelize package exposes the getModelToken() function which returns a prepared token based on a given model.
Title,typescript
Title,@Module({
Title,providers: [
Title,"UsersService,"
Title,{
Title,"provide: getModelToken(User),"
Title,"useValue: mockModel,"
Title,"},"
Title,"],"
Title,})
Title,export class UsersModule {}
Title,"Now a substitute mockModel will be used as the UserModel. Whenever any class asks for UserModel using an @InjectModel() decorator, Nest will use the registered mockModel object."
Title,Async configuration
Title,"You may want to pass your SequelizeModule options asynchronously instead of statically. In this case, use the forRootAsync() method, which provides several ways to deal with async configuration."
Title,One approach is to use a factory function:
Title,typescript
Title,SequelizeModule.forRootAsync({
Title,useFactory: () => ({
Title,"dialect: 'mysql',"
Title,"host: 'localhost',"
Title,"port: 3306,"
Title,"username: 'root',"
Title,"password: 'root',"
Title,"database: 'test',"
Title,"models: [],"
Title,"}),"
Title,});
Title,"Our factory behaves like any other asynchronous provider (e.g., it can be async and it's able to inject dependencies through inject)."
Title,typescript
Title,SequelizeModule.forRootAsync({
Title,"imports: [ConfigModule],"
Title,useFactory: (configService: ConfigService) => ({
Title,"dialect: 'mysql',"
Title,"host: configService.get('HOST'),"
Title,"port: +configService.get('PORT'),"
Title,"username: configService.get('USERNAME'),"
Title,"password: configService.get('PASSWORD'),"
Title,"database: configService.get('DATABASE'),"
Title,"models: [],"
Title,"}),"
Title,"inject: [ConfigService],"
Title,});
Title,"Alternatively, you can use the useClass syntax:"
Title,typescript
Title,SequelizeModule.forRootAsync({
Title,"useClass: SequelizeConfigService,"
Title,});
Title,"The construction above will instantiate SequelizeConfigService inside SequelizeModule and use it to provide an options object by calling createSequelizeOptions(). Note that this means that the SequelizeConfigService has to implement the SequelizeOptionsFactory interface, as shown below:"
Title,typescript
Title,@Injectable()
Title,class SequelizeConfigService implements SequelizeOptionsFactory {
Title,createSequelizeOptions(): SequelizeModuleOptions {
Title,return {
Title,"dialect: 'mysql',"
Title,"host: 'localhost',"
Title,"port: 3306,"
Title,"username: 'root',"
Title,"password: 'root',"
Title,"database: 'test',"
Title,"models: [],"
Title,};
Title,}
Title,}
Title,"In order to prevent the creation of SequelizeConfigService inside SequelizeModule and use a provider imported from a different module, you can use the useExisting syntax."
Title,typescript
Title,SequelizeModule.forRootAsync({
Title,"imports: [ConfigModule],"
Title,"useExisting: ConfigService,"
Title,});
Title,This construction works the same as useClass with one critical difference - SequelizeModule will lookup imported modules to reuse an existing ConfigService instead of instantiating a new one.
Title,Example
Title,A working example is available here.
Title,
Title,Streaming files
Title,
Title,info Note This chapter shows how you can stream files from your HTTP application. The examples presented below do not apply to GraphQL or Microservice applications.
Title,
Title,"There may be times where you would like to send back a file from your REST API to the client. To do this with Nest, normally you'd do the following:"
Title,ts
Title,@Controller('file')
Title,export class FileController {
Title,@Get()
Title,getFile(@Res() res: Response) {
Title,"const file = createReadStream(join(process.cwd(), 'package.json'));"
Title,file.pipe(res);
Title,}
Title,}
Title,"But in doing so you end up losing access to your post-controller interceptor logic. To handle this, you can return a StreamableFile instance and under the hood, the framework will take care of piping the response."
Title,Streamable File class
Title,"A StreamableFile is a class that holds onto the stream that is to be returned. To create a new StreamableFile, you can pass either a Buffer or a Stream to the StreamableFile constructor."
Title,
Title,info hint The StreamableFile class can be imported from @nestjs/common.
Title,
Title,Cross-platform support
Title,"Fastify, by default, can support sending files without needing to call stream.pipe(res), so you don't need to use the StreamableFile class at all. However, Nest supports the use of StreamableFile in both platform types, so if you end up switching between Express and Fastify there's no need to worry about compatibility between the two engines."
Title,Example
Title,"You can find a simple example of returning the package.json as a file instead of a JSON below, but the idea extends out naturally to images, documents, and any other file type."
Title,```ts
Title,"import { Controller, Get, StreamableFile } from '@nestjs/common';"
Title,import { createReadStream } from 'fs';
Title,import { join } from 'path';
Title,@Controller('file')
Title,export class FileController {
Title,@Get()
Title,getFile(): StreamableFile {
Title,"const file = createReadStream(join(process.cwd(), 'package.json'));"
Title,return new StreamableFile(file);
Title,}
Title,}
Title,```
Title,"The default content type (the value for Content-Type HTTP response header) is application/octet-stream. If you need to customize this value you can use the type option from StreamableFile, or use the res.set method or the @Header() decorator, like this:"
Title,```ts
Title,"import { Controller, Get, StreamableFile, Res } from '@nestjs/common';"
Title,import { createReadStream } from 'fs';
Title,import { join } from 'path';
Title,import type { Response } from 'express'; // Assuming that we are using the ExpressJS HTTP Adapter
Title,@Controller('file')
Title,export class FileController {
Title,@Get()
Title,getFile(): StreamableFile {
Title,"const file = createReadStream(join(process.cwd(), 'package.json'));"
Title,"return new StreamableFile(file, {"
Title,"type: 'application/json',"
Title,"disposition: 'attachment; filename=""package.json""',"
Title,// If you want to define the Content-Length value to another value instead of file's length:
Title,"// length: 123,"
Title,});
Title,}
Title,// Or even:
Title,@Get()
Title,getFileChangingResponseObjDirectly(@Res({ passthrough: true }) res: Response): StreamableFile {
Title,"const file = createReadStream(join(process.cwd(), 'package.json'));"
Title,res.set({
Title,"'Content-Type': 'application/json',"
Title,"'Content-Disposition': 'attachment; filename=""package.json""',"
Title,});
Title,return new StreamableFile(file);
Title,}
Title,// Or even:
Title,@Get()
Title,"@Header('Content-Type', 'application/json')"
Title,"@Header('Content-Disposition', 'attachment; filename=""package.json""')"
Title,getFileUsingStaticValues(): StreamableFile {
Title,"const file = createReadStream(join(process.cwd(), 'package.json'));"
Title,return new StreamableFile(file);
Title,}
Title,}
Title,```
Title,
Title,Task Scheduling
Title,"Task scheduling allows you to schedule arbitrary code (methods/functions) to execute at a fixed date/time, at recurring intervals, or once after a specified interval. In the Linux world, this is often handled by packages like cron at the OS level. For Node.js apps, there are several packages that emulate cron-like functionality. Nest provides the @nestjs/schedule package, which integrates with the popular Node.js cron package. We'll cover this package in the current chapter."
Title,Installation
Title,"To begin using it, we first install the required dependencies."
Title,bash
Title,$ npm install --save @nestjs/schedule
Title,"To activate job scheduling, import the ScheduleModule into the root AppModule and run the forRoot() static method as shown below:"
Title,```typescript
Title,@@filename(app.module)
Title,import { Module } from '@nestjs/common';
Title,import { ScheduleModule } from '@nestjs/schedule';
Title,@Module({
Title,imports: [
Title,ScheduleModule.forRoot()
Title,"],"
Title,})
Title,export class AppModule {}
Title,```
Title,"The .forRoot() call initializes the scheduler and registers any declarative cron jobs, timeouts and intervals that exist within your app. Registration occurs when the onApplicationBootstrap lifecycle hook occurs, ensuring that all modules have loaded and declared any scheduled jobs."
Title,Declarative cron jobs
Title,A cron job schedules an arbitrary function (method call) to run automatically. Cron jobs can run:
Title,
Title,"Once, at a specified date/time."
Title,"On a recurring basis; recurring jobs can run at a specified instant within a specified interval (for example, once per hour, once per week, once every 5 minutes)"
Title,
Title,"Declare a cron job with the @Cron() decorator preceding the method definition containing the code to be executed, as follows:"
Title,```typescript
Title,"import { Injectable, Logger } from '@nestjs/common';"
Title,import { Cron } from '@nestjs/schedule';
Title,@Injectable()
Title,export class TasksService {
Title,private readonly logger = new Logger(TasksService.name);
Title,@Cron('45 * * * * *')
Title,handleCron() {
Title,this.logger.debug('Called when the current second is 45');
Title,}
Title,}
Title,```
Title,"In this example, the handleCron() method will be called each time the current second is 45. In other words, the method will be run once per minute, at the 45 second mark."
Title,The @Cron() decorator supports the following standard cron patterns:
Title,
Title,Asterisk (e.g. *)
Title,"Ranges (e.g. 1-3,5)"
Title,Steps (e.g. */2)
Title,
Title,"In the example above, we passed 45 * * * * * to the decorator. The following key shows how each position in the cron pattern string is interpreted:"
Title,
Title,* * * * * *
Title,| | | | | |
Title,| | | | | day of week
Title,| | | | months
Title,| | | day of month
Title,| | hours
Title,| minutes
Title,seconds (optional)
Title,
Title,Some sample cron patterns are:
Title,
Title,
Title,
Title,* * * * * *
Title,every second
Title,
Title,
Title,45 * * * * *
Title,"every minute, on the 45th second"
Title,
Title,
Title,0 10 * * * *
Title,"every hour, at the start of the 10th minute"
Title,
Title,
Title,0 */30 9-17 * * *
Title,every 30 minutes between 9am and 5pm
Title,
Title,
Title,0 30 11 * * 1-5
Title,Monday to Friday at 11:30am
Title,
Title,
Title,
Title,The @nestjs/schedule package provides a convenient enum with commonly used cron patterns. You can use this enum as follows:
Title,```typescript
Title,"import { Injectable, Logger } from '@nestjs/common';"
Title,"import { Cron, CronExpression } from '@nestjs/schedule';"
Title,@Injectable()
Title,export class TasksService {
Title,private readonly logger = new Logger(TasksService.name);
Title,@Cron(CronExpression.EVERY_30_SECONDS)
Title,handleCron() {
Title,this.logger.debug('Called every 30 seconds');
Title,}
Title,}
Title,```
Title,"In this example, the handleCron() method will be called every 30 seconds. If an exception occurs, it will be logged to the console, as every method annotated with @Cron() is automatically wrapped in a try-catch block."
Title,"Alternatively, you can supply a JavaScript Date object to the @Cron() decorator. Doing so causes the job to execute exactly once, at the specified date."
Title,
Title,"info Hint Use JavaScript date arithmetic to schedule jobs relative to the current date. For example, @Cron(new Date(Date.now() + 10 * 1000)) to schedule a job to run 10 seconds after the app starts."
Title,
Title,"Also, you can supply additional options as the second parameter to the @Cron() decorator."
Title,
Title,
Title,
Title,name
Title,
Title,Useful to access and control a cron job after it's been declared.
Title,
Title,
Title,
Title,timeZone
Title,
Title,"Specify the timezone for the execution. This will modify the actual time relative to your timezone. If the timezone is invalid, an error is thrown. You can check all timezones available at Moment Timezone website."
Title,
Title,
Title,
Title,utcOffset
Title,
Title,This allows you to specify the offset of your timezone rather than using the timeZone param.
Title,
Title,
Title,
Title,disabled
Title,
Title,This indicates whether the job will be executed at all.
Title,
Title,
Title,
Title,
Title,```typescript
Title,import { Injectable } from '@nestjs/common';
Title,"import { Cron, CronExpression } from '@nestjs/schedule';"
Title,@Injectable()
Title,export class NotificationService {
Title,"@Cron(' * 0 * * ', {"
Title,"name: 'notifications',"
Title,"timeZone: 'Europe/Paris',"
Title,})
Title,triggerNotifications() {}
Title,}
Title,```
Title,"You can access and control a cron job after it's been declared, or dynamically create a cron job (where its cron pattern is defined at runtime) with the Dynamic API. To access a declarative cron job via the API, you must associate the job with a name by passing the name property in an optional options object as the second argument of the decorator."
Title,Declarative intervals
Title,"To declare that a method should run at a (recurring) specified interval, prefix the method definition with the @Interval() decorator. Pass the interval value, as a number in milliseconds, to the decorator as shown below:"
Title,typescript
Title,@Interval(10000)
Title,handleInterval() {
Title,this.logger.debug('Called every 10 seconds');
Title,}
Title,
Title,info Hint This mechanism uses the JavaScript setInterval() function under the hood. You can also utilize a cron job to schedule recurring jobs.
Title,
Title,"If you want to control your declarative interval from outside the declaring class via the Dynamic API, associate the interval with a name using the following construction:"
Title,typescript
Title,"@Interval('notifications', 2500)"
Title,handleInterval() {}
Title,"If an exception occurs, it will be logged to the console, as every method annotated with @Interval() is automatically wrapped in a try-catch block."
Title,"The Dynamic API also enables creating dynamic intervals, where the interval's properties are defined at runtime, and listing and deleting them."
Title,
Title,Declarative timeouts
Title,"To declare that a method should run (once) at a specified timeout, prefix the method definition with the @Timeout() decorator. Pass the relative time offset (in milliseconds), from application startup, to the decorator as shown below:"
Title,typescript
Title,@Timeout(5000)
Title,handleTimeout() {
Title,this.logger.debug('Called once after 5 seconds');
Title,}
Title,
Title,info Hint This mechanism uses the JavaScript setTimeout() function under the hood.
Title,
Title,"If an exception occurs, it will be logged to the console, as every method annotated with @Timeout() is automatically wrapped in a try-catch block."
Title,"If you want to control your declarative timeout from outside the declaring class via the Dynamic API, associate the timeout with a name using the following construction:"
Title,typescript
Title,"@Timeout('notifications', 2500)"
Title,handleTimeout() {}
Title,"The Dynamic API also enables creating dynamic timeouts, where the timeout's properties are defined at runtime, and listing and deleting them."
Title,Dynamic schedule module API
Title,"The @nestjs/schedule module provides a dynamic API that enables managing declarative cron jobs, timeouts and intervals. The API also enables creating and managing dynamic cron jobs, timeouts and intervals, where the properties are defined at runtime."
Title,Dynamic cron jobs
Title,"Obtain a reference to a CronJob instance by name from anywhere in your code using the SchedulerRegistry API. First, inject SchedulerRegistry using standard constructor injection:"
Title,typescript
Title,constructor(private schedulerRegistry: SchedulerRegistry) {}
Title,
Title,info Hint Import the SchedulerRegistry from the @nestjs/schedule package.
Title,
Title,Then use it in a class as follows. Assume a cron job was created with the following declaration:
Title,typescript
Title,"@Cron('* * 8 * * *', {"
Title,"name: 'notifications',"
Title,})
Title,triggerNotifications() {}
Title,Access this job using the following:
Title,```typescript
Title,const job = this.schedulerRegistry.getCronJob('notifications');
Title,job.stop();
Title,console.log(job.lastDate());
Title,```
Title,The getCronJob() method returns the named cron job. The returned CronJob object has the following methods:
Title,
Title,stop() - stops a job that is scheduled to run.
Title,start() - restarts a job that has been stopped.
Title,"setTime(time: CronTime) - stops a job, sets a new time for it, and then starts it"
Title,lastDate() - returns a DateTime representation of the date on which the last execution of a job occurred.
Title,nextDate() - returns a DateTime representation of the date when the next execution of a job is scheduled.
Title,"nextDates(count: number) - Provides an array (size count) of DateTime representations for the next set of dates that will trigger job execution. count defaults to 0, returning an empty array."
Title,
Title,
Title,info Hint Use toJSDate() on DateTime objects to render them as a JavaScript Date equivalent to this DateTime.
Title,
Title,"Create a new cron job dynamically using the SchedulerRegistry#addCronJob method, as follows:"
Title,``typescript
Title,"addCronJob(name: string, seconds: string) {"
Title,"const job = new CronJob(${seconds} * * * * *, () => {"
Title,this.logger.warn(time (${seconds}) for job ${name} to run!`);
Title,});
Title,"this.schedulerRegistry.addCronJob(name, job);"
Title,job.start();
Title,this.logger.warn(
Title,"job ${name} added for each minute at ${seconds} seconds!,"
Title,);
Title,}
Title,```
Title,"In this code, we use the CronJob object from the cron package to create the cron job. The CronJob constructor takes a cron pattern (just like the @Cron() decorator) as its first argument, and a callback to be executed when the cron timer fires as its second argument. The SchedulerRegistry#addCronJob method takes two arguments: a name for the CronJob, and the CronJob object itself."
Title,
Title,warning Warning Remember to inject the SchedulerRegistry before accessing it. Import CronJob from the cron package.
Title,
Title,"Delete a named cron job using the SchedulerRegistry#deleteCronJob method, as follows:"
Title,typescript
Title,deleteCron(name: string) {
Title,this.schedulerRegistry.deleteCronJob(name);
Title,this.logger.warn(`job ${name} deleted!`);
Title,}
Title,List all cron jobs using the SchedulerRegistry#getCronJobs method as follows:
Title,typescript
Title,getCrons() {
Title,const jobs = this.schedulerRegistry.getCronJobs();
Title,"jobs.forEach((value, key, map) => {"
Title,let next;
Title,try {
Title,next = value.nextDate().toJSDate();
Title,} catch (e) {
Title,next = 'error: next fire date is in the past!';
Title,}
Title,this.logger.log(`job: ${key} -> next: ${next}`);
Title,});
Title,}
Title,"The getCronJobs() method returns a map. In this code, we iterate over the map and attempt to access the nextDate() method of each CronJob. In the CronJob API, if a job has already fired and has no future firing date, it throws an exception."
Title,Dynamic intervals
Title,"Obtain a reference to an interval with the SchedulerRegistry#getInterval method. As above, inject SchedulerRegistry using standard constructor injection:"
Title,typescript
Title,constructor(private schedulerRegistry: SchedulerRegistry) {}
Title,And use it as follows:
Title,typescript
Title,const interval = this.schedulerRegistry.getInterval('notifications');
Title,clearInterval(interval);
Title,"Create a new interval dynamically using the SchedulerRegistry#addInterval method, as follows:"
Title,``typescript
Title,"addInterval(name: string, milliseconds: number) {"
Title,const callback = () => {
Title,this.logger.warn(Interval ${name} executing at time (${milliseconds})!`);
Title,};
Title,"const interval = setInterval(callback, milliseconds);"
Title,"this.schedulerRegistry.addInterval(name, interval);"
Title,}
Title,```
Title,"In this code, we create a standard JavaScript interval, then pass it to the SchedulerRegistry#addInterval method."
Title,"That method takes two arguments: a name for the interval, and the interval itself."
Title,"Delete a named interval using the SchedulerRegistry#deleteInterval method, as follows:"
Title,typescript
Title,deleteInterval(name: string) {
Title,this.schedulerRegistry.deleteInterval(name);
Title,this.logger.warn(`Interval ${name} deleted!`);
Title,}
Title,List all intervals using the SchedulerRegistry#getIntervals method as follows:
Title,typescript
Title,getIntervals() {
Title,const intervals = this.schedulerRegistry.getIntervals();
Title,intervals.forEach(key => this.logger.log(`Interval: ${key}`));
Title,}
Title,Dynamic timeouts
Title,"Obtain a reference to a timeout with the SchedulerRegistry#getTimeout method. As above, inject SchedulerRegistry using standard constructor injection:"
Title,typescript
Title,constructor(private readonly schedulerRegistry: SchedulerRegistry) {}
Title,And use it as follows:
Title,typescript
Title,const timeout = this.schedulerRegistry.getTimeout('notifications');
Title,clearTimeout(timeout);
Title,"Create a new timeout dynamically using the SchedulerRegistry#addTimeout method, as follows:"
Title,``typescript
Title,"addTimeout(name: string, milliseconds: number) {"
Title,const callback = () => {
Title,this.logger.warn(Timeout ${name} executing after (${milliseconds})!`);
Title,};
Title,"const timeout = setTimeout(callback, milliseconds);"
Title,"this.schedulerRegistry.addTimeout(name, timeout);"
Title,}
Title,```
Title,"In this code, we create a standard JavaScript timeout, then pass it to the SchedulerRegistry#addTimeout method."
Title,"That method takes two arguments: a name for the timeout, and the timeout itself."
Title,"Delete a named timeout using the SchedulerRegistry#deleteTimeout method, as follows:"
Title,typescript
Title,deleteTimeout(name: string) {
Title,this.schedulerRegistry.deleteTimeout(name);
Title,this.logger.warn(`Timeout ${name} deleted!`);
Title,}
Title,List all timeouts using the SchedulerRegistry#getTimeouts method as follows:
Title,typescript
Title,getTimeouts() {
Title,const timeouts = this.schedulerRegistry.getTimeouts();
Title,timeouts.forEach(key => this.logger.log(`Timeout: ${key}`));
Title,}
Title,Example
Title,A working example is available here.
Title,
Title,Validation
Title,"It is best practice to validate the correctness of any data sent into a web application. To automatically validate incoming requests, Nest provides several pipes available right out-of-the-box:"
Title,
Title,ValidationPipe
Title,ParseIntPipe
Title,ParseBoolPipe
Title,ParseArrayPipe
Title,ParseUUIDPipe
Title,
Title,"The ValidationPipe makes use of the powerful class-validator package and its declarative validation decorators. The ValidationPipe provides a convenient approach to enforce validation rules for all incoming client payloads, where the specific rules are declared with simple annotations in local class/DTO declarations in each module."
Title,Overview
Title,"In the Pipes chapter, we went through the process of building simple pipes and binding them to controllers, methods or to the global app to demonstrate how the process works. Be sure to review that chapter to best understand the topics of this chapter. Here, we'll focus on various real world use cases of the ValidationPipe, and show how to use some of its advanced customization features."
Title,Using the built-in ValidationPipe
Title,"To begin using it, we first install the required dependency."
Title,bash
Title,$ npm i --save class-validator class-transformer
Title,
Title,info Hint The ValidationPipe is exported from the @nestjs/common package.
Title,
Title,"Because this pipe uses the class-validator and class-transformer libraries, there are many options available. You configure these settings via a configuration object passed to the pipe. Following are the built-in options:"
Title,typescript
Title,export interface ValidationPipeOptions extends ValidatorOptions {
Title,transform?: boolean;
Title,disableErrorMessages?: boolean;
Title,exceptionFactory?: (errors: ValidationError[]) => any;
Title,}
Title,"In addition to these, all class-validator options (inherited from the ValidatorOptions interface) are available:"
Title,
Title,
Title,Option
Title,Type
Title,Description
Title,
Title,
Title,enableDebugMessages
Title,boolean
Title,"If set to true, validator will print extra warning messages to the console when something is not right."
Title,
Title,
Title,skipUndefinedProperties
Title,boolean
Title,If set to true then validator will skip validation of all properties that are undefined in the validating object.
Title,
Title,
Title,skipNullProperties
Title,boolean
Title,If set to true then validator will skip validation of all properties that are null in the validating object.
Title,
Title,
Title,skipMissingProperties
Title,boolean
Title,If set to true then validator will skip validation of all properties that are null or undefined in the validating object.
Title,
Title,
Title,whitelist
Title,boolean
Title,"If set to true, validator will strip validated (returned) object of any properties that do not use any validation decorators."
Title,
Title,
Title,forbidNonWhitelisted
Title,boolean
Title,"If set to true, instead of stripping non-whitelisted properties validator will throw an exception."
Title,
Title,
Title,forbidUnknownValues
Title,boolean
Title,"If set to true, attempts to validate unknown objects fail immediately."
Title,
Title,
Title,disableErrorMessages
Title,boolean
Title,"If set to true, validation errors will not be returned to the client."
Title,
Title,
Title,errorHttpStatusCode
Title,number
Title,This setting allows you to specify which exception type will be used in case of an error. By default it throws BadRequestException.
Title,
Title,
Title,exceptionFactory
Title,Function
Title,Takes an array of the validation errors and returns an exception object to be thrown.
Title,
Title,
Title,groups
Title,string[]
Title,Groups to be used during validation of the object.
Title,
Title,
Title,always
Title,boolean
Title,Set default for always option of decorators. Default can be overridden in decorator options
Title,
Title,
Title,strictGroups
Title,boolean
Title,"If groups is not given or is empty, ignore decorators with at least one group."
Title,
Title,
Title,dismissDefaultMessages
Title,boolean
Title,"If set to true, the validation will not use default messages. Error message always will be undefined        if"
Title,its not explicitly set.
Title,
Title,
Title,validationError.target
Title,boolean
Title,Indicates if target should be exposed in ValidationError.
Title,
Title,
Title,validationError.value
Title,boolean
Title,Indicates if validated value should be exposed in ValidationError.
Title,
Title,
Title,stopAtFirstError
Title,boolean
Title,"When set to true, validation of the given property will stop after encountering the first error. Defaults to false."
Title,
Title,
Title,
Title,info Notice Find more information about the class-validator package in its repository.
Title,
Title,Auto-validation
Title,"We'll start by binding ValidationPipe at the application level, thus ensuring all endpoints are protected from receiving incorrect data."
Title,typescript
Title,async function bootstrap() {
Title,const app = await NestFactory.create(AppModule);
Title,app.useGlobalPipes(new ValidationPipe());
Title,await app.listen(process.env.PORT ?? 3000);
Title,}
Title,bootstrap();
Title,"To test our pipe, let's create a basic endpoint."
Title,typescript
Title,@Post()
Title,create(@Body() createUserDto: CreateUserDto) {
Title,return 'This action adds a new user';
Title,}
Title,
Title,"info Hint Since TypeScript does not store metadata about generics or interfaces, when you use them in your DTOs, ValidationPipe may not be able to properly validate incoming data. For this reason, consider using concrete classes in your DTOs."
Title,"info Hint When importing your DTOs, you can't use a type-only import as that would be erased at runtime, i.e. remember to import {{ '{' }} CreateUserDto {{ '}' }} instead of import type {{ '{' }} CreateUserDto {{ '}' }}."
Title,
Title,"Now we can add a few validation rules in our CreateUserDto. We do this using decorators provided by the class-validator package, described in detail here. In this fashion, any route that uses the CreateUserDto will automatically enforce these validation rules."
Title,```typescript
Title,"import { IsEmail, IsNotEmpty } from 'class-validator';"
Title,export class CreateUserDto {
Title,@IsEmail()
Title,email: string;
Title,@IsNotEmpty()
Title,password: string;
Title,}
Title,```
Title,"With these rules in place, if a request hits our endpoint with an invalid email property in the request body, the application will automatically respond with a 400 Bad Request code, along with the following response body:"
Title,json
Title,{
Title,"""statusCode"": 400,"
Title,"""error"": ""Bad Request"","
Title,"""message"": [""email must be an email""]"
Title,}
Title,"In addition to validating request bodies, the ValidationPipe can be used with other request object properties as well. Imagine that we would like to accept :id in the endpoint path. To ensure that only numbers are accepted for this request parameter, we can use the following construct:"
Title,typescript
Title,@Get(':id')
Title,findOne(@Param() params: FindOneParams) {
Title,return 'This action returns a user';
Title,}
Title,"FindOneParams, like a DTO, is simply a class that defines validation rules using class-validator. It would look like this:"
Title,```typescript
Title,import { IsNumberString } from 'class-validator';
Title,export class FindOneParams {
Title,@IsNumberString()
Title,id: number;
Title,}
Title,```
Title,Disable detailed errors
Title,"Error messages can be helpful to explain what was incorrect in a request. However, some production environments prefer to disable detailed errors. Do this by passing an options object to the ValidationPipe:"
Title,typescript
Title,app.useGlobalPipes(
Title,new ValidationPipe({
Title,"disableErrorMessages: true,"
Title,"}),"
Title,);
Title,"As a result, detailed error messages won't be displayed in the response body."
Title,Stripping properties
Title,"Our ValidationPipe can also filter out properties that should not be received by the method handler. In this case, we can whitelist the acceptable properties, and any property not included in the whitelist is automatically stripped from the resulting object. For example, if our handler expects email and password properties, but a request also includes an age property, this property can be automatically removed from the resulting DTO. To enable such behavior, set whitelist to true."
Title,typescript
Title,app.useGlobalPipes(
Title,new ValidationPipe({
Title,"whitelist: true,"
Title,"}),"
Title,);
Title,"When set to true, this will automatically remove non-whitelisted properties (those without any decorator in the validation class)."
Title,"Alternatively, you can stop the request from processing when non-whitelisted properties are present, and return an error response to the user. To enable this, set the forbidNonWhitelisted option property to true, in combination with setting whitelist to true."
Title,
Title,Transform payload objects
Title,"Payloads coming in over the network are plain JavaScript objects. The ValidationPipe can automatically transform payloads to be objects typed according to their DTO classes. To enable auto-transformation, set transform to true. This can be done at a method level:"
Title,typescript
Title,@@filename(cats.controller)
Title,@Post()
Title,@UsePipes(new ValidationPipe({ transform: true }))
Title,async create(@Body() createCatDto: CreateCatDto) {
Title,this.catsService.create(createCatDto);
Title,}
Title,"To enable this behavior globally, set the option on a global pipe:"
Title,typescript
Title,app.useGlobalPipes(
Title,new ValidationPipe({
Title,"transform: true,"
Title,"}),"
Title,);
Title,"With the auto-transformation option enabled, the ValidationPipe will also perform conversion of primitive types. In the following example, the findOne() method takes one argument which represents an extracted id path parameter:"
Title,typescript
Title,@Get(':id')
Title,findOne(@Param('id') id: number) {
Title,console.log(typeof id === 'number'); // true
Title,return 'This action returns a user';
Title,}
Title,"By default, every path parameter and query parameter comes over the network as a string. In the above example, we specified the id type as a number (in the method signature). Therefore, the ValidationPipe will try to automatically convert a string identifier to a number."
Title,Explicit conversion
Title,"In the above section, we showed how the ValidationPipe can implicitly transform query and path parameters based on the expected type. However, this feature requires having auto-transformation enabled."
Title,"Alternatively (with auto-transformation disabled), you can explicitly cast values using the ParseIntPipe or ParseBoolPipe (note that ParseStringPipe is not needed because, as mentioned earlier, every path parameter and query parameter comes over the network as a string by default)."
Title,typescript
Title,@Get(':id')
Title,findOne(
Title,"@Param('id', ParseIntPipe) id: number,"
Title,"@Query('sort', ParseBoolPipe) sort: boolean,"
Title,) {
Title,console.log(typeof id === 'number'); // true
Title,console.log(typeof sort === 'boolean'); // true
Title,return 'This action returns a user';
Title,}
Title,
Title,info Hint The ParseIntPipe and ParseBoolPipe are exported from the @nestjs/common package.
Title,
Title,Mapped types
Title,As you build out features like CRUD (Create/Read/Update/Delete) it's often useful to construct variants on a base entity type. Nest provides several utility functions that perform type transformations to make this task more convenient.
Title,
Title,"Warning If your application uses the @nestjs/swagger package, see this chapter for more information about Mapped Types. Likewise, if you use the @nestjs/graphql package see this chapter. Both packages heavily rely on types and so they require a different import to be used. Therefore, if you used @nestjs/mapped-types (instead of an appropriate one, either @nestjs/swagger or @nestjs/graphql depending on the type of your app), you may face various, undocumented side-effects."
Title,
Title,"When building input validation types (also called DTOs), it's often useful to build create and update variations on the same type. For example, the create variant may require all fields, while the update variant may make all fields optional."
Title,Nest provides the PartialType() utility function to make this task easier and minimize boilerplate.
Title,"The PartialType() function returns a type (class) with all the properties of the input type set to optional. For example, suppose we have a create type as follows:"
Title,typescript
Title,export class CreateCatDto {
Title,name: string;
Title,age: number;
Title,breed: string;
Title,}
Title,"By default, all of these fields are required. To create a type with the same fields, but with each one optional, use PartialType() passing the class reference (CreateCatDto) as an argument:"
Title,typescript
Title,export class UpdateCatDto extends PartialType(CreateCatDto) {}
Title,
Title,info Hint The PartialType() function is imported from the @nestjs/mapped-types package.
Title,
Title,"The PickType() function constructs a new type (class) by picking a set of properties from an input type. For example, suppose we start with a type like:"
Title,typescript
Title,export class CreateCatDto {
Title,name: string;
Title,age: number;
Title,breed: string;
Title,}
Title,We can pick a set of properties from this class using the PickType() utility function:
Title,typescript
Title,"export class UpdateCatAgeDto extends PickType(CreateCatDto, ['age'] as const) {}"
Title,
Title,info Hint The PickType() function is imported from the @nestjs/mapped-types package.
Title,
Title,"The OmitType() function constructs a type by picking all properties from an input type and then removing a particular set of keys. For example, suppose we start with a type like:"
Title,typescript
Title,export class CreateCatDto {
Title,name: string;
Title,age: number;
Title,breed: string;
Title,}
Title,"We can generate a derived type that has every property except name as shown below. In this construct, the second argument to OmitType is an array of property names."
Title,typescript
Title,"export class UpdateCatDto extends OmitType(CreateCatDto, ['name'] as const) {}"
Title,
Title,info Hint The OmitType() function is imported from the @nestjs/mapped-types package.
Title,
Title,"The IntersectionType() function combines two types into one new type (class). For example, suppose we start with two types like:"
Title,```typescript
Title,export class CreateCatDto {
Title,name: string;
Title,breed: string;
Title,}
Title,export class AdditionalCatInfo {
Title,color: string;
Title,}
Title,```
Title,We can generate a new type that combines all properties in both types.
Title,typescript
Title,export class UpdateCatDto extends IntersectionType(
Title,"CreateCatDto,"
Title,"AdditionalCatInfo,"
Title,) {}
Title,
Title,info Hint The IntersectionType() function is imported from the @nestjs/mapped-types package.
Title,
Title,"The type mapping utility functions are composable. For example, the following will produce a type (class) that has all of the properties of the CreateCatDto type except for name, and those properties will be set to optional:"
Title,typescript
Title,export class UpdateCatDto extends PartialType(
Title,"OmitType(CreateCatDto, ['name'] as const),"
Title,) {}
Title,Parsing and validating arrays
Title,"TypeScript does not store metadata about generics or interfaces, so when you use them in your DTOs, ValidationPipe may not be able to properly validate incoming data. For instance, in the following code, createUserDtos won't be correctly validated:"
Title,typescript
Title,@Post()
Title,createBulk(@Body() createUserDtos: CreateUserDto[]) {
Title,return 'This action adds new users';
Title,}
Title,"To validate the array, create a dedicated class which contains a property that wraps the array, or use the ParseArrayPipe."
Title,typescript
Title,@Post()
Title,createBulk(
Title,@Body(new ParseArrayPipe({ items: CreateUserDto }))
Title,"createUserDtos: CreateUserDto[],"
Title,) {
Title,return 'This action adds new users';
Title,}
Title,"In addition, the ParseArrayPipe may come in handy when parsing query parameters. Let's consider a findByIds() method that returns users based on identifiers passed as query parameters."
Title,typescript
Title,@Get()
Title,findByIds(
Title,"@Query('ids', new ParseArrayPipe({ items: Number, separator: ',' }))"
Title,"ids: number[],"
Title,) {
Title,return 'This action returns users by ids';
Title,}
Title,This construction validates the incoming query parameters from an HTTP GET request like the following:
Title,bash
Title,"GET /?ids=1,2,3"
Title,WebSockets and Microservices
Title,"While this chapter shows examples using HTTP style applications (e.g., Express or Fastify), the ValidationPipe works the same for WebSockets and microservices, regardless of the transport method that is used."
Title,Learn more
Title,"Read more about custom validators, error messages, and available decorators as provided by the class-validator package here."
Title,
Title,Versioning
Title,
Title,info Hint This chapter is only relevant to HTTP-based applications.
Title,
Title,Versioning allows you to have different versions of your controllers or individual routes running within the same application. Applications change very often and it is not unusual that there are breaking changes that you need to make while still needing to support the previous version of the application.
Title,There are 4 types of versioning that are supported:
Title,
Title,
Title,URI Versioning
Title,The version will be passed within the URI of the request (default)
Title,
Title,
Title,Header Versioning
Title,A custom request header will specify the version
Title,
Title,
Title,Media Type Versioning
Title,The Accept header of the request will specify the version
Title,
Title,
Title,Custom Versioning
Title,Any aspect of the request may be used to specify the version(s). A custom function is provided to extract said version(s).
Title,
Title,
Title,URI Versioning Type
Title,"URI Versioning uses the version passed within the URI of the request, such as https://example.com/v1/route and https://example.com/v2/route."
Title,
Title,"warning Notice With URI Versioning the version will be automatically added to the URI after the global path prefix (if one exists), and before any controller or route paths."
Title,
Title,"To enable URI Versioning for your application, do the following:"
Title,typescript
Title,@@filename(main)
Title,const app = await NestFactory.create(AppModule);
Title,"// or ""app.enableVersioning()"""
Title,app.enableVersioning({
Title,"type: VersioningType.URI,"
Title,});
Title,await app.listen(process.env.PORT ?? 3000);
Title,
Title,"warning Notice The version in the URI will be automatically prefixed with v by default, however the prefix value can be configured by setting the prefix key to your desired prefix or false if you wish to disable it."
Title,info Hint The VersioningType enum is available to use for the type property and is imported from the @nestjs/common package.
Title,
Title,Header Versioning Type
Title,"Header Versioning uses a custom, user specified, request header to specify the version where the value of the header will be the version to use for the request."
Title,Example HTTP Requests for Header Versioning:
Title,"To enable Header Versioning for your application, do the following:"
Title,typescript
Title,@@filename(main)
Title,const app = await NestFactory.create(AppModule);
Title,app.enableVersioning({
Title,"type: VersioningType.HEADER,"
Title,"header: 'Custom-Header',"
Title,});
Title,await app.listen(process.env.PORT ?? 3000);
Title,The header property should be the name of the header that will contain the version of the request.
Title,
Title,info Hint The VersioningType enum is available to use for the type property and is imported from the @nestjs/common package.
Title,
Title,Media Type Versioning Type
Title,Media Type Versioning uses the Accept header of the request to specify the version.
Title,"Within the Accept header, the version will be separated from the media type with a semi-colon, ;. It should then contain a key-value pair that represents the version to use for the request, such as Accept: application/json;v=2. They key is treated more as a prefix when determining the version will to be configured to include the key and separator."
Title,"To enable Media Type Versioning for your application, do the following:"
Title,typescript
Title,@@filename(main)
Title,const app = await NestFactory.create(AppModule);
Title,app.enableVersioning({
Title,"type: VersioningType.MEDIA_TYPE,"
Title,"key: 'v=',"
Title,});
Title,await app.listen(process.env.PORT ?? 3000);
Title,"The key property should be the key and separator of the key-value pair that contains the version. For the example Accept: application/json;v=2, the key property would be set to v=."
Title,
Title,info Hint The VersioningType enum is available to use for the type property and is imported from the @nestjs/common package.
Title,
Title,Custom Versioning Type
Title,Custom Versioning uses any aspect of the request to specify the version (or versions). The incoming request is analyzed
Title,using an extractor function that returns a string or array of strings.
Title,"If multiple versions are provided by the requester, the extractor function can return an array of strings, sorted in"
Title,order of greatest/highest version to smallest/lowest version. Versions are matched to routes in order from highest to
Title,lowest.
Title,"If an empty string or array is returned from the extractor, no routes are matched and a 404 is returned."
Title,"For example, if an incoming request specifies it supports versions 1, 2, and 3, the extractor MUST return [3, 2, 1]. This ensures that the highest possible route version is selected first."
Title,"If versions [3, 2, 1] are extracted, but routes only exist for version 2 and 1, the route that matches version 2"
Title,is selected (version 3 is automatically ignored).
Title,
Title,warning Notice Selecting the highest matching version based on the array returned from extractor > does not reliably work with the Express adapter due to design limitations. A single version (either a string or
Title,array of 1 element) works just fine in Express. Fastify correctly supports both highest matching version
Title,selection and single version selection.
Title,
Title,"To enable Custom Versioning for your application, create an extractor function and pass it into your application"
Title,like so:
Title,```typescript
Title,@@filename(main)
Title,// Example extractor that pulls out a list of versions from a custom header and turns it into a sorted array.
Title,"// This example uses Fastify, but Express requests can be processed in a similar way."
Title,const extractor = (request: FastifyRequest): string | string[] =>
Title,[request.headers['custom-versioning-field'] ?? '']
Title,".flatMap(v => v.split(','))"
Title,.filter(v => !!v)
Title,.sort()
Title,.reverse()
Title,const app = await NestFactory.create(AppModule);
Title,app.enableVersioning({
Title,"type: VersioningType.CUSTOM,"
Title,"extractor,"
Title,});
Title,await app.listen(process.env.PORT ?? 3000);
Title,```
Title,Usage
Title,"Versioning allows you to version controllers, individual routes, and also provides a way for certain resources to opt-out of versioning. The usage of versioning is the same regardless of the Versioning Type your application uses."
Title,
Title,"warning Notice If versioning is enabled for the application but the controller or route does not specify the version, any requests to that controller/route will be returned a 404 response status. Similarly, if a request is received containing a version that does not have a corresponding controller or route, it will also be returned a 404 response status."
Title,
Title,Controller versions
Title,"A version can be applied to a controller, setting the version for all routes within the controller."
Title,To add a version to a controller do the following:
Title,typescript
Title,@@filename(cats.controller)
Title,@Controller({
Title,"version: '1',"
Title,})
Title,export class CatsControllerV1 {
Title,@Get('cats')
Title,findAll(): string {
Title,return 'This action returns all cats for version 1';
Title,}
Title,}
Title,@@switch
Title,@Controller({
Title,"version: '1',"
Title,})
Title,export class CatsControllerV1 {
Title,@Get('cats')
Title,findAll() {
Title,return 'This action returns all cats for version 1';
Title,}
Title,}
Title,Route versions
Title,"A version can be applied to an individual route. This version will override any other version that would effect the route, such as the Controller Version."
Title,To add a version to an individual route do the following:
Title,```typescript
Title,@@filename(cats.controller)
Title,"import { Controller, Get, Version } from '@nestjs/common';"
Title,@Controller()
Title,export class CatsController {
Title,@Version('1')
Title,@Get('cats')
Title,findAllV1(): string {
Title,return 'This action returns all cats for version 1';
Title,}
Title,@Version('2')
Title,@Get('cats')
Title,findAllV2(): string {
Title,return 'This action returns all cats for version 2';
Title,}
Title,}
Title,@@switch
Title,"import { Controller, Get, Version } from '@nestjs/common';"
Title,@Controller()
Title,export class CatsController {
Title,@Version('1')
Title,@Get('cats')
Title,findAllV1() {
Title,return 'This action returns all cats for version 1';
Title,}
Title,@Version('2')
Title,@Get('cats')
Title,findAllV2() {
Title,return 'This action returns all cats for version 2';
Title,}
Title,}
Title,```
Title,Multiple versions
Title,"Multiple versions can be applied to a controller or route. To use multiple versions, you would set the version to be an Array."
Title,To add multiple versions do the following:
Title,typescript
Title,@@filename(cats.controller)
Title,@Controller({
Title,"version: ['1', '2'],"
Title,})
Title,export class CatsController {
Title,@Get('cats')
Title,findAll(): string {
Title,return 'This action returns all cats for version 1 or 2';
Title,}
Title,}
Title,@@switch
Title,@Controller({
Title,"version: ['1', '2'],"
Title,})
Title,export class CatsController {
Title,@Get('cats')
Title,findAll() {
Title,return 'This action returns all cats for version 1 or 2';
Title,}
Title,}
Title,"Version ""Neutral"""
Title,"Some controllers or routes may not care about the version and would have the same functionality regardless of the version. To accommodate this, the version can be set to VERSION_NEUTRAL symbol."
Title,An incoming request will be mapped to a VERSION_NEUTRAL controller or route regardless of the version sent in the request in addition to if the request does not contain a version at all.
Title,
Title,"warning Notice For URI Versioning, a VERSION_NEUTRAL resource would not have the version present in the URI."
Title,
Title,To add a version neutral controller or route do the following:
Title,```typescript
Title,@@filename(cats.controller)
Title,"import { Controller, Get, VERSION_NEUTRAL } from '@nestjs/common';"
Title,@Controller({
Title,"version: VERSION_NEUTRAL,"
Title,})
Title,export class CatsController {
Title,@Get('cats')
Title,findAll(): string {
Title,return 'This action returns all cats regardless of version';
Title,}
Title,}
Title,@@switch
Title,"import { Controller, Get, VERSION_NEUTRAL } from '@nestjs/common';"
Title,@Controller({
Title,"version: VERSION_NEUTRAL,"
Title,})
Title,export class CatsController {
Title,@Get('cats')
Title,findAll() {
Title,return 'This action returns all cats regardless of version';
Title,}
Title,}
Title,```
Title,Global default version
Title,"If you do not want to provide a version for each controller/or individual routes, or if you want to have a specific version set as the default version for every controller/route that don't have the version specified, you could set the defaultVersion as follows:"
Title,typescript
Title,@@filename(main)
Title,app.enableVersioning({
Title,// ...
Title,defaultVersion: '1'
Title,// or
Title,"defaultVersion: ['1', '2']"
Title,// or
Title,defaultVersion: VERSION_NEUTRAL
Title,});
Title,Middleware versioning
Title,"Middlewares can also use versioning metadata to configure the middleware for a specific route's version. To do so, provide the version number as one of the parameters for the MiddlewareConsumer.forRoutes() method:"
Title,```typescript
Title,@@filename(app.module)
Title,"import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';"
Title,import { LoggerMiddleware } from './common/middleware/logger.middleware';
Title,import { CatsModule } from './cats/cats.module';
Title,import { CatsController } from './cats/cats.controller';
Title,@Module({
Title,"imports: [CatsModule],"
Title,})
Title,export class AppModule implements NestModule {
Title,configure(consumer: MiddlewareConsumer) {
Title,consumer
Title,.apply(LoggerMiddleware)
Title,".forRoutes({ path: 'cats', method: RequestMethod.GET, version: '2' });"
Title,}
Title,}
Title,```
Title,"With the code above, the LoggerMiddleware will only be applied to the version '2' of /cats endpoint."
Title,
Title,"info Notice Middlewares work with any versioning type described in the this section: URI, Header, Media Type or Custom."
Title,
Title,
Title,Adapters
Title,"The WebSockets module is platform-agnostic, hence, you can bring your own library (or even a native implementation) by making use of WebSocketAdapter interface. This interface forces to implement few methods described in the following table:"
Title,
Title,
Title,create
Title,Creates a socket instance based on passed arguments
Title,
Title,
Title,bindClientConnect
Title,Binds the client connection event
Title,
Title,
Title,bindClientDisconnect
Title,Binds the client disconnection event (optional*)
Title,
Title,
Title,bindMessageHandlers
Title,Binds the incoming message to the corresponding message handler
Title,
Title,
Title,close
Title,Terminates a server instance
Title,
Title,
Title,Extend socket.io
Title,"The socket.io package is wrapped in an IoAdapter class. What if you would like to enhance the basic functionality of the adapter? For instance, your technical requirements require a capability to broadcast events across multiple load-balanced instances of your web service. For this, you can extend IoAdapter and override a single method which responsibility is to instantiate new socket.io servers. But first of all, let's install the required package."
Title,
Title,warning Warning To use socket.io with multiple load-balanced instances you either have to disable polling by setting transports: ['websocket'] in your clients socket.io configuration or you have to enable cookie based routing in your load balancer. Redis alone is not enough. See here for more information.
Title,
Title,bash
Title,$ npm i --save redis socket.io @socket.io/redis-adapter
Title,"Once the package is installed, we can create a RedisIoAdapter class."
Title,```typescript
Title,import { IoAdapter } from '@nestjs/platform-socket.io';
Title,import { ServerOptions } from 'socket.io';
Title,import { createAdapter } from '@socket.io/redis-adapter';
Title,import { createClient } from 'redis';
Title,export class RedisIoAdapter extends IoAdapter {
Title,private adapterConstructor: ReturnType;
Title,async connectToRedis(): Promise {
Title,const pubClient = createClient({ url: redis://localhost:6379 });
Title,const subClient = pubClient.duplicate();
Title,"await Promise.all([pubClient.connect(), subClient.connect()]);"
Title,
Title,"this.adapterConstructor = createAdapter(pubClient, subClient);"
Title,
Title,}
Title,"createIOServer(port: number, options?: ServerOptions): any {"
Title,"const server = super.createIOServer(port, options);"
Title,server.adapter(this.adapterConstructor);
Title,return server;
Title,}
Title,}
Title,```
Title,"Afterward, simply switch to your newly created Redis adapter."
Title,```typescript
Title,const app = await NestFactory.create(AppModule);
Title,const redisIoAdapter = new RedisIoAdapter(app);
Title,await redisIoAdapter.connectToRedis();
Title,app.useWebSocketAdapter(redisIoAdapter);
Title,```
Title,Ws library
Title,"Another available adapter is a WsAdapter which in turn acts like a proxy between the framework and integrate blazing fast and thoroughly tested ws library. This adapter is fully compatible with native browser WebSockets and is far faster than socket.io package. Unluckily, it has significantly fewer functionalities available out-of-the-box. In some cases, you may just don't necessarily need them though."
Title,
Title,"info Hint ws library does not support namespaces (communication channels popularised by socket.io). However, to somehow mimic this feature, you can mount multiple ws servers on different paths (example: @WebSocketGateway({{ '{' }} path: '/users' {{ '}' }}))."
Title,
Title,"In order to use ws, we firstly have to install the required package:"
Title,bash
Title,$ npm i --save @nestjs/platform-ws
Title,"Once the package is installed, we can switch an adapter:"
Title,typescript
Title,const app = await NestFactory.create(AppModule);
Title,app.useWebSocketAdapter(new WsAdapter(app));
Title,
Title,info Hint The WsAdapter is imported from @nestjs/platform-ws.
Title,
Title,Advanced (custom adapter)
Title,"For demonstration purposes, we are going to integrate the ws library manually. As mentioned, the adapter for this library is already created and is exposed from the @nestjs/platform-ws package as a WsAdapter class. Here is how the simplified implementation could potentially look like:"
Title,```typescript
Title,@@filename(ws-adapter)
Title,import * as WebSocket from 'ws';
Title,"import { WebSocketAdapter, INestApplicationContext } from '@nestjs/common';"
Title,import { MessageMappingProperties } from '@nestjs/websockets';
Title,"import { Observable, fromEvent, EMPTY } from 'rxjs';"
Title,"import { mergeMap, filter } from 'rxjs/operators';"
Title,export class WsAdapter implements WebSocketAdapter {
Title,constructor(private app: INestApplicationContext) {}
Title,"create(port: number, options: any = {}): any {"
Title,"return new WebSocket.Server({ port, ...options });"
Title,}
Title,"bindClientConnect(server, callback: Function) {"
Title,"server.on('connection', callback);"
Title,}
Title,bindMessageHandlers(
Title,"client: WebSocket,"
Title,"handlers: MessageMappingProperties[],"
Title,"process: (data: any) => Observable,"
Title,) {
Title,"fromEvent(client, 'message')"
Title,.pipe(
Title,"mergeMap(data => this.bindMessageHandler(data, handlers, process)),"
Title,"filter(result => result),"
Title,)
Title,.subscribe(response => client.send(JSON.stringify(response)));
Title,}
Title,bindMessageHandler(
Title,"buffer,"
Title,"handlers: MessageMappingProperties[],"
Title,"process: (data: any) => Observable,"
Title,): Observable {
Title,const message = JSON.parse(buffer.data);
Title,const messageHandler = handlers.find(
Title,"handler => handler.message === message.event,"
Title,);
Title,if (!messageHandler) {
Title,return EMPTY;
Title,}
Title,return process(messageHandler.callback(message.data));
Title,}
Title,close(server) {
Title,server.close();
Title,}
Title,}
Title,```
Title,
Title,"info Hint When you want to take advantage of ws library, use built-in WsAdapter instead of creating your own one."
Title,
Title,"Then, we can set up a custom adapter using useWebSocketAdapter() method:"
Title,typescript
Title,@@filename(main)
Title,const app = await NestFactory.create(AppModule);
Title,app.useWebSocketAdapter(new WsAdapter(app));
Title,Example
Title,A working example that uses WsAdapter is available here.
Title,
Title,Exception filters
Title,"The only difference between the HTTP exception filter layer and the corresponding web sockets layer is that instead of throwing HttpException, you should use WsException."
Title,typescript
Title,throw new WsException('Invalid credentials.');
Title,
Title,info Hint The WsException class is imported from the @nestjs/websockets package.
Title,
Title,"With the sample above, Nest will handle the thrown exception and emit the exception message with the following structure:"
Title,typescript
Title,{
Title,"status: 'error',"
Title,message: 'Invalid credentials.'
Title,}
Title,Filters
Title,"Web sockets exception filters behave equivalently to HTTP exception filters. The following example uses a manually instantiated method-scoped filter. Just as with HTTP based applications, you can also use gateway-scoped filters (i.e., prefix the gateway class with a @UseFilters() decorator)."
Title,typescript
Title,@UseFilters(new WsExceptionFilter())
Title,@SubscribeMessage('events')
Title,"onEvent(client, data: any): WsResponse<any> {"
Title,const event = 'events';
Title,"return { event, data };"
Title,}
Title,Inheritance
Title,"Typically, you'll create fully customized exception filters crafted to fulfill your application requirements. However, there might be use-cases when you would like to simply extend the core exception filter, and override the behavior based on certain factors."
Title,"In order to delegate exception processing to the base filter, you need to extend BaseWsExceptionFilter and call the inherited catch() method."
Title,```typescript
Title,@@filename()
Title,"import { Catch, ArgumentsHost } from '@nestjs/common';"
Title,import { BaseWsExceptionFilter } from '@nestjs/websockets';
Title,@Catch()
Title,export class AllExceptionsFilter extends BaseWsExceptionFilter {
Title,"catch(exception: unknown, host: ArgumentsHost) {"
Title,"super.catch(exception, host);"
Title,}
Title,}
Title,@@switch
Title,import { Catch } from '@nestjs/common';
Title,import { BaseWsExceptionFilter } from '@nestjs/websockets';
Title,@Catch()
Title,export class AllExceptionsFilter extends BaseWsExceptionFilter {
Title,"catch(exception, host) {"
Title,"super.catch(exception, host);"
Title,}
Title,}
Title,```
Title,"The above implementation is just a shell demonstrating the approach. Your implementation of the extended exception filter would include your tailored business logic (e.g., handling various conditions)."
Title,
Title,Gateways
Title,"Most of the concepts discussed elsewhere in this documentation, such as dependency injection, decorators, exception filters, pipes, guards and interceptors, apply equally to gateways. Wherever possible, Nest abstracts implementation details so that the same components can run across HTTP-based platforms, WebSockets, and Microservices. This section covers the aspects of Nest that are specific to WebSockets."
Title,"In Nest, a gateway is simply a class annotated with @WebSocketGateway() decorator. Technically, gateways are platform-agnostic which makes them compatible with any WebSockets library once an adapter is created. There are two WS platforms supported out-of-the-box: socket.io and ws. You can choose the one that best suits your needs. Also, you can build your own adapter by following this guide."
Title,
Title,
Title,"info Hint Gateways can be treated as providers; this means they can inject dependencies through the class constructor. Also, gateways can be injected by other classes (providers and controllers) as well."
Title,
Title,Installation
Title,"To start building WebSockets-based applications, first install the required package:"
Title,bash
Title,@@filename()
Title,$ npm i --save @nestjs/websockets @nestjs/platform-socket.io
Title,@@switch
Title,$ npm i --save @nestjs/websockets @nestjs/platform-socket.io
Title,Overview
Title,"In general, each gateway is listening on the same port as the HTTP server, unless your app is not a web application, or you have changed the port manually. This default behavior can be modified by passing an argument to the @WebSocketGateway(80) decorator where 80 is a chosen port number. You can also set a namespace used by the gateway using the following construction:"
Title,typescript
Title,"@WebSocketGateway(80, { namespace: 'events' })"
Title,
Title,warning Warning Gateways are not instantiated until they are referenced in the providers array of an existing module.
Title,
Title,"You can pass any supported option to the socket constructor with the second argument to the @WebSocketGateway() decorator, as shown below:"
Title,typescript
Title,"@WebSocketGateway(81, { transports: ['websocket'] })"
Title,"The gateway is now listening, but we have not yet subscribed to any incoming messages. Let's create a handler that will subscribe to the events messages and respond to the user with the exact same data."
Title,typescript
Title,@@filename(events.gateway)
Title,@SubscribeMessage('events')
Title,handleEvent(@MessageBody() data: string): string {
Title,return data;
Title,}
Title,@@switch
Title,@Bind(MessageBody())
Title,@SubscribeMessage('events')
Title,handleEvent(data) {
Title,return data;
Title,}
Title,
Title,info Hint @SubscribeMessage() and @MessageBody() decorators are imported from @nestjs/websockets package.
Title,
Title,"Once the gateway is created, we can register it in our module."
Title,```typescript
Title,import { Module } from '@nestjs/common';
Title,import { EventsGateway } from './events.gateway';
Title,@@filename(events.module)
Title,@Module({
Title,providers: [EventsGateway]
Title,})
Title,export class EventsModule {}
Title,```
Title,You can also pass in a property key to the decorator to extract it from the incoming message body:
Title,typescript
Title,@@filename(events.gateway)
Title,@SubscribeMessage('events')
Title,handleEvent(@MessageBody('id') id: number): number {
Title,// id === messageBody.id
Title,return id;
Title,}
Title,@@switch
Title,@Bind(MessageBody('id'))
Title,@SubscribeMessage('events')
Title,handleEvent(id) {
Title,// id === messageBody.id
Title,return id;
Title,}
Title,"If you would prefer not to use decorators, the following code is functionally equivalent:"
Title,typescript
Title,@@filename(events.gateway)
Title,@SubscribeMessage('events')
Title,"handleEvent(client: Socket, data: string): string {"
Title,return data;
Title,}
Title,@@switch
Title,@SubscribeMessage('events')
Title,"handleEvent(client, data) {"
Title,return data;
Title,}
Title,"In the example above, the handleEvent() function takes two arguments. The first one is a platform-specific socket instance, while the second one is the data received from the client. This approach is not recommended though, because it requires mocking the socket instance in each unit test."
Title,"Once the events message is received, the handler sends an acknowledgment with the same data that was sent over the network. In addition, it's possible to emit messages using a library-specific approach, for example, by making use of client.emit() method. In order to access a connected socket instance, use @ConnectedSocket() decorator."
Title,typescript
Title,@@filename(events.gateway)
Title,@SubscribeMessage('events')
Title,handleEvent(
Title,"@MessageBody() data: string,"
Title,"@ConnectedSocket() client: Socket,"
Title,): string {
Title,return data;
Title,}
Title,@@switch
Title,"@Bind(MessageBody(), ConnectedSocket())"
Title,@SubscribeMessage('events')
Title,"handleEvent(data, client) {"
Title,return data;
Title,}
Title,
Title,info Hint @ConnectedSocket() decorator is imported from @nestjs/websockets package.
Title,
Title,"However, in this case, you won't be able to leverage interceptors. If you don't want to respond to the user, you can simply skip the return statement (or explicitly return a ""falsy"" value, e.g. undefined)."
Title,Now when a client emits the message as follows:
Title,typescript
Title,"socket.emit('events', { name: 'Nest' });"
Title,"The handleEvent() method will be executed. In order to listen for messages emitted from within the above handler, the client has to attach a corresponding acknowledgment listener:"
Title,typescript
Title,"socket.emit('events', { name: 'Nest' }, (data) => console.log(data));"
Title,Multiple responses
Title,"The acknowledgment is dispatched only once. Furthermore, it is not supported by native WebSockets implementation. To solve this limitation, you may return an object which consists of two properties. The event which is a name of the emitted event and the data that has to be forwarded to the client."
Title,typescript
Title,@@filename(events.gateway)
Title,@SubscribeMessage('events')
Title,handleEvent(@MessageBody() data: unknown): WsResponse<unknown> {
Title,const event = 'events';
Title,"return { event, data };"
Title,}
Title,@@switch
Title,@Bind(MessageBody())
Title,@SubscribeMessage('events')
Title,handleEvent(data) {
Title,const event = 'events';
Title,"return { event, data };"
Title,}
Title,
Title,info Hint The WsResponse interface is imported from @nestjs/websockets package.
Title,"warning Warning You should return a class instance that implements WsResponse if your data field relies on ClassSerializerInterceptor, as it ignores plain JavaScript object responses."
Title,
Title,"In order to listen for the incoming response(s), the client has to apply another event listener."
Title,typescript
Title,"socket.on('events', (data) => console.log(data));"
Title,Asynchronous responses
Title,"Message handlers are able to respond either synchronously or asynchronously. Hence, async methods are supported. A message handler is also able to return an Observable, in which case the result values will be emitted until the stream is completed."
Title,```typescript
Title,@@filename(events.gateway)
Title,@SubscribeMessage('events')
Title,onEvent(@MessageBody() data: unknown): Observable> {
Title,const event = 'events';
Title,"const response = [1, 2, 3];"
Title,return from(response).pipe(
Title,"map(data => ({ event, data })),"
Title,);
Title,}
Title,@@switch
Title,@Bind(MessageBody())
Title,@SubscribeMessage('events')
Title,onEvent(data) {
Title,const event = 'events';
Title,"const response = [1, 2, 3];"
Title,return from(response).pipe(
Title,"map(data => ({ event, data })),"
Title,);
Title,}
Title,```
Title,"In the example above, the message handler will respond 3 times (with each item from the array)."
Title,Lifecycle hooks
Title,There are 3 useful lifecycle hooks available. All of them have corresponding interfaces and are described in the following table:
Title,
Title,
Title,
Title,OnGatewayInit
Title,
Title,
Title,Forces to implement the afterInit() method. Takes library-specific server instance as an argument (and
Title,spreads the rest if required).
Title,
Title,
Title,
Title,
Title,OnGatewayConnection
Title,
Title,
Title,Forces to implement the handleConnection() method. Takes library-specific client socket instance as
Title,an argument.
Title,
Title,
Title,
Title,
Title,OnGatewayDisconnect
Title,
Title,
Title,Forces to implement the handleDisconnect() method. Takes library-specific client socket instance as
Title,an argument.
Title,
Title,
Title,
Title,
Title,info Hint Each lifecycle interface is exposed from @nestjs/websockets package.
Title,
Title,Server and Namespace
Title,"Occasionally, you may want to have a direct access to the native, platform-specific server instance. The reference to this object is passed as an argument to the afterInit() method (OnGatewayInit interface). Another option is to use the @WebSocketServer() decorator."
Title,typescript
Title,@WebSocketServer()
Title,server: Server;
Title,"Also, you can retrieve the corresponding namespace using the namespace attribute, as follows:"
Title,typescript
Title,@WebSocketServer({ namespace: 'my-namespace' })
Title,namespace: Namespace;
Title,
Title,warning Notice The @WebSocketServer() decorator is imported from the @nestjs/websockets package.
Title,
Title,Nest will automatically assign the server instance to this property once it is ready to use.
Title,
Title,Example
Title,A working example is available here.
Title,
Title,Guards
Title,"There is no fundamental difference between web sockets guards and regular HTTP application guards. The only difference is that instead of throwing HttpException, you should use WsException."
Title,
Title,info Hint The WsException class is exposed from @nestjs/websockets package.
Title,
Title,Binding guards
Title,"The following example uses a method-scoped guard. Just as with HTTP based applications, you can also use gateway-scoped guards (i.e., prefix the gateway class with a @UseGuards() decorator)."
Title,typescript
Title,@@filename()
Title,@UseGuards(AuthGuard)
Title,@SubscribeMessage('events')
Title,"handleEvent(client: Client, data: unknown): WsResponse<unknown> {"
Title,const event = 'events';
Title,"return { event, data };"
Title,}
Title,@@switch
Title,@UseGuards(AuthGuard)
Title,@SubscribeMessage('events')
Title,"handleEvent(client, data) {"
Title,const event = 'events';
Title,"return { event, data };"
Title,}
Title,
Title,Interceptors
Title,"There is no difference between regular interceptors and web sockets interceptors. The following example uses a manually instantiated method-scoped interceptor. Just as with HTTP based applications, you can also use gateway-scoped interceptors (i.e., prefix the gateway class with a @UseInterceptors() decorator)."
Title,typescript
Title,@@filename()
Title,@UseInterceptors(new TransformInterceptor())
Title,@SubscribeMessage('events')
Title,"handleEvent(client: Client, data: unknown): WsResponse<unknown> {"
Title,const event = 'events';
Title,"return { event, data };"
Title,}
Title,@@switch
Title,@UseInterceptors(new TransformInterceptor())
Title,@SubscribeMessage('events')
Title,"handleEvent(client, data) {"
Title,const event = 'events';
Title,"return { event, data };"
Title,}
Title,
Title,Pipes
Title,"There is no fundamental difference between regular pipes and web sockets pipes. The only difference is that instead of throwing HttpException, you should use WsException. In addition, all pipes will be only applied to the data parameter (because validating or transforming client instance is useless)."
Title,
Title,info Hint The WsException class is exposed from @nestjs/websockets package.
Title,
Title,Binding pipes
Title,"The following example uses a manually instantiated method-scoped pipe. Just as with HTTP based applications, you can also use gateway-scoped pipes (i.e., prefix the gateway class with a @UsePipes() decorator)."
Title,typescript
Title,@@filename()
Title,@UsePipes(new ValidationPipe({ exceptionFactory: (errors) => new WsException(errors) }))
Title,@SubscribeMessage('events')
Title,"handleEvent(client: Client, data: unknown): WsResponse<unknown> {"
Title,const event = 'events';
Title,"return { event, data };"
Title,}
Title,@@switch
Title,@UsePipes(new ValidationPipe({ exceptionFactory: (errors) => new WsException(errors) }))
Title,@SubscribeMessage('events')
Title,"handleEvent(client, data) {"
Title,const event = 'events';
Title,"return { event, data };"
Title,}
